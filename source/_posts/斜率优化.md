---
title: 斜率优化
date: 2019-04-03 21:11:53
mathjax: true
tags:
- ICPC
- 斜率优化
---

## 斜率优化

针对形如：
$$
dp(i)=\min _{j=1}^{i-1} (dp(j)+cost(i, j))
$$
的动态规划转移方程，可通过''斜率''的**单调性**进行优化。

## 题一、[HNOI2008]玩具装箱TOY

### 题意 [题目链接](<https://www.luogu.org/problemnew/show/P3195>)

给定长为 $1\le N\le 50000$ 的序列 $1\le C_i\le 10^7$，将序列分成若干连续段，每段 $[i, j]$ 的花费为
$$
((j - i+\sum_{k=i}^jC_k)-L)^2
$$
其中 $L$ 为常数，$1\le L \le 10^7$。要求计算总的最小花费代价。

### 解题思路

利用前缀和 $S_i$，区间 $[i, j]$ 序列和可表示成 $S_j - S_{i-1}$。容易想到 dp 转移方程为：
$$
dp(j)=\min_{i=0}^{j-1}(dp(i)+cost(i, j)) \\
cost(i, j) = ((j - (i + 1) + S_j - S_i) - L)^2
$$
将变量整理归类，记 $a_j=j+S_j, b_i=i+S_i+L+1$，则 $cost(i, j)$ 转化成：
$$
cost(i, j) = (a_j-b_i)^2 = a_j^2+b_i^2-2a_jb_i
$$
转移方程移项可得：
$$
2a_jb_i + dp(j)-a_j^2=dp(i)+b_i^2
$$
因为 $a_j$ 在 $j$ 固定时可认为是个定值，故问题相当于最小化 $dp(j)-a_j^2$，进而可以将问题看成是斜率为 $2a_j$ 的直线，找出一点 $(b_i, dp(i)+b_i^2)$ 使得直线在 $y$ 轴的截距 $dp(j) - a_j^2$ 最小。

![下凸壳](1554264317802.png)

<center>图 1. 下凸壳-灰色点和黑色点分别表示非凸壳点和凸壳点。</center>

显然，截距最小的关键点必然在**下凸壳**上，且下凸壳的每段斜率是**单调递增**的。

斜率为 $g$ 的直线截距最小所对应的最优点是，该点前一段斜率 $\lt g$，后一段斜率 $\gt g$。

注意 $1\le C_i  \Rightarrow S_i \lt S_{i + 1} \Rightarrow a_i=i+S_i \lt a_{i + 1}=(i + 1) + S_{i + 1}$，斜率 $a_i$ 是单调递增的，则对应的最优点位置也是单调的，所以这种情况可通过**双端队列**将复杂度优化到 $O(n)$。

## 题二、小A与最大子段和

### 题意 [题目链接](https://ac.nowcoder.com/acm/contest/545/A)

给定长为 $1\le N \le 2\times 10^5$ 的序列 $0 \le |A_i| \le 2000$，找一个非空连续子段 $B$，最大化：
$$
\sum_{i=1}^{|B|} i\times B_i
$$

### 解题思路

把问题进一步公式化：
$$
Ans = \max_{1\le i\le j\le N} \{\sum_{k=i}^j(k-i+1)\times A_k\} \tag 1
$$
为了去除 $\sum$ ，引入前缀和 $S_i$ 和 $V_i=\sum_{p=1}^i p\times A_p$，公式 (1) 转化成：
$$
Ans = \max_{0\le i\lt j\le N} \{(V_j-V_i)-i\times(S_j-S_i)\} \tag 2
$$
根据变量下标整理归类：
$$
Ans = -S_j\times i+(i\times S_i-V_i) + V_j \\
\Rightarrow S_j\times i+(Ans - V_j) = i\times S_i- V_i
$$
同"玩具装箱TOY"，此时相当于令截距 $Ans - V_j$ **最大**，所以此时需要维护点集 $(i, iS_i-V_i)$ 的**上凸壳**。

因为 $A_i$ 存在负数，故斜率 $S_i$ 并不具有单调性，所以需要**二分**确定最优点的位置。 

## 参考

1. [斜率优化DP](https://www.cnblogs.com/ka200812/archive/2012/08/03/2621345.html)

2. [斜率优化dp小结](https://blog.csdn.net/lxc779760807/article/details/51366552)

## 代码

### [HNOI2008]玩具装箱TOY

```c++
#include<bits/stdc++.h>
using namespace std;
typedef double db;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
#define fi first
#define se second
#define pb push_back
#define sz(x) ((int)(x).size())
#define all(x) begin(x),end(x)
#define rep(i,l,r) for(int i=(l);i<(r);++i)
#define per(i,l,r) for(int i=(r)-1;i>=(l);--i)
#define dd(x) cout << #x << "=" << x << ", "
#define de(x) cout << #x << "=" << x << endl
//-------
const int N = 5e5 + 7;
int n, L, C[N];
ll S[N], dp[N];
struct P {
	ll x, y;
	P() {}
	P(ll _x, ll _y) {
		x = _x, y = _y;
	}
	P operator-(const P &p) const {
		return P(x - p.x, y - p.y);
	}
	ll operator^(const P &p) const {
		return x * p.y - y * p.x;		
	}
};
#define X(i) (i + S[i] + L + 1)
#define Y(i) (dp[i] + X(i) * X(i))
int main() {
	scanf("%d%d", &n, &L);
	rep(i, 1, n + 1) scanf("%d", C + i);
	rep(i, 1, n + 1) S[i] = S[i - 1] + C[i];
	deque<P> Q; Q.push_back(P(X(0), Y(0)));
	rep(i, 1, n + 1) {
		ll g = 2 * (i + S[i]);
		while (sz(Q) > 1 && (Q[1].y - Q[0].y) < (Q[1].x - Q[0].x) * g) 
			Q.pop_front();
		dp[i] = Q[0].y - g * Q[0].x + (i + S[i]) * (i + S[i]);
		P a(X(i), Y(i));
		while (sz(Q) > 1 && ((Q[sz(Q) - 2] - a) ^ (Q.back() - a)) <= 0) 
			Q.pop_back();	
		Q.push_back(a);
	}	
	printf("%lld", dp[n]);
	return 0;
}
```

### 小A与最大子段和

```c++
#include<bits/stdc++.h>
using namespace std;
typedef double db;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
#define fi first
#define se second
#define pb push_back
#define sz(x) ((int)(x).size())
#define all(x) begin(x),end(x)
#define rep(i,l,r) for(int i=(l);i<(r);++i)
#define per(i,l,r) for(int i=(r)-1;i>=(l);--i)
#define dd(x) cout << #x << "=" << x << ", "
#define de(x) cout << #x << "=" << x << endl
//-------
const int N = 2e5 + 7;
int n, a[N];
ll S[N], V[N];
#define X(i) (i)
#define Y(i) (i * S[i] - V[i])
struct P {
	ll x, y;
	P() {} P(ll _x, ll _y) { x = _x, y = _y; } 
	P operator-(const P &p) const {
		return P(x - p.x, y - p.y);
	}
	ll operator^(const P &p) const {
		return x * p.y - y * p.x;
	}
};
bool chk(deque<P> &Q, int i, ll G) {
	return (Q[i + 1].y - Q[i].y) >= (Q[i + 1].x - Q[i].x) * G;	
}
int main() {
	scanf("%d", &n);
	rep(i, 1, n + 1) scanf("%d", a + i);	
	rep(i, 1, n + 1) S[i] = S[i - 1] + a[i];
	rep(i, 1, n + 1) V[i] = V[i - 1] + i * a[i];
		
	deque<P> Q; Q.push_back(P(X(0), Y(0)));
	ll ans = LLONG_MIN;
	rep(i, 1, n + 1) {
		// answer
		int l = 0, r = max(0, sz(Q) - 2);
		while (l + 1 < r) {
			int z = (l + r) >> 1;
			chk(Q, z, S[i]) ? l = z : r = z;	
		}
		int j = l;
		if (chk(Q, r, S[i])) j = r + 1;
		else if (chk(Q, l, S[i])) j = l + 1;
		else j = l;
		ll f = Q[j].y - S[i] * Q[j].x + V[i];
		ans = max(ans, f);
		// maintain
		P a(X(i), Y(i));
		while (sz(Q) > 1 && ((Q[sz(Q) - 2] - a) ^ (Q.back() - a)) >= 0)
			Q.pop_back();
		Q.push_back(a);
	}
	printf("%lld", ans);
	return 0;
}
```

