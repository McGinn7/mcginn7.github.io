{"meta":{"title":"Mcginn's Blog","subtitle":null,"description":null,"author":"Mcginn","url":"http://mcginn7.github.io","root":"/"},"pages":[],"posts":[{"title":"SGU 计划","slug":"SGU-计划","date":"2019-11-15T02:16:46.000Z","updated":"2019-11-15T13:06:57.547Z","comments":true,"path":"2019/11/15/SGU-计划/","link":"","permalink":"http://mcginn7.github.io/2019/11/15/SGU-计划/","excerpt":"","text":"计划计划一年内（截止 2021 年 1 月 1 日）把 SGU 500 刷完，形式以所有题目给出翻译后的简要题意和解题思路概要，代码贴 CodeForces 链接。 题目 Domino 题意 多米诺牌两端标有 0 至 6 的数字，以 形式表示，每张牌均可翻转。要求将 100 个多米诺牌横向放置成一排，相邻的多米诺牌数字需要相同。如 。判断是否存在方案，存在的话给出一种排列。 分析 将数字 0 至 6 视为图上的点，多米诺牌视为无向边，则问题转化成找出一条欧拉路径，而欧拉路径使用搜索+剪枝解决。 代码 Coprimes 题意 给定 $1\\le N \\le 10^4$，求 $[1, N)$ 范围内与 $N$ 互质的整数个数。 分析 求欧拉函数值 $φ(N)=N\\prod (1 - \\frac {1} {p_i})$，$O(\\sqrt N)$ 枚举质因子求解即可。 代码 参考代码 Traffic Lights 题意 分析 代码 Little shop of flowers 题意 给 $1\\le V \\le 100$ 个花瓶和 $1\\le F\\le 100$ 朵花，以及第 $i$ 朵花放入第 $j$ 个花瓶的美观度 $A_{ij}$。在不改变花的相对顺序条件下，将所有花插入到花瓶中，求最大的美观度之和且输出一种方案。 分析 经典的动态规划题目。$dp(i, j)$ 表示前 $i$ 个花瓶中已插入前 $j$ 朵花的最大美观度之和，转移方程： dp(i, j) = \\max\\{dp(i - 1, j), dp(i - 1, j - 1) + A_{ji}\\}代码 参考代码 Div 3 题意 给出 1, 12, 123, 1234, …, 12345678910, … 的序列，求前 $1\\le N \\le 2^{31}-1$ 个元素中是 3 的倍数的个数。 分析 打表找规律，余数序列为 100100…，即每 3 个元素中有 2 个是 3 的倍数。 代码 参考代码","categories":[],"tags":[]},{"title":"Pólya计数法","slug":"polya","date":"2019-10-31T11:54:39.000Z","updated":"2019-11-08T12:00:45.909Z","comments":true,"path":"2019/10/31/polya/","link":"","permalink":"http://mcginn7.github.io/2019/10/31/polya/","excerpt":"","text":"题目Necklace of Beads来源 POJ 1286 题意 使用 RGB 三种颜色对长为 $0\\le n\\le 23$ 的项链染色，求本质不同的方案数。一种方案如果经过旋转或翻转得到另一种方案，两种方案视为同一种。 注意 $n=0$ 在本题中会出现，测试数据输出 0。 分析 使用 Polya 计数公式求解，即对于正 $n$ 边形的顶点对称群 \\{ρ_n^0=\\iota,ρ_n,\\dots, ρ_n^{n-1}, τ_1, τ_2, \\dots, τ_n \\}的循环因子分解。 旋转置换 $ρ_n^i,i=0,1,\\dots n-1$ 的循环个数为 \\gcd(n, i)证明 旋转置换中的每个元素在一个有向圈 $s+ki=s(\\%\\ n)$ ，其中 $k$ 是最小正整数。那么 $n|ki$，令 $ki=lcm(n, i)=ni/\\gcd(n, i)$，则 $k=n/\\gcd(n, i)$。所以有向圈的长度为 $n/\\gcd(n, i)$，个数为 $n/k=\\gcd(n,i)$ 个。 根据定理 3 可得， |C(ρ_n^i)|=3^{\\gcd(n, i)} 反射置换 $τ_i$ 需要根据 $n$ 的奇偶性考虑。 当 $n$ 为奇数时，有 $n$ 个关于角点与其对边中点的连线的反射，每个反射置换的型为 (1, \\frac{n-1}{2}, 0, \\dots, 0)根据定理 3 可得 |C(τ_i)|=3^{\\frac{n+1}{2}}当 $n$ 为偶数时，有 $n/2$ 个关于对角点的反射和 $n/2$ 个关于对边中点连线的反射，两种置换的型分别为 (2, \\frac n2-1, 0, \\dots, 0)\\\\ (0, \\frac n 2, 0, \\dots, 0)根据置换的型和定理 3 可求得 $|C(f)|$，最后使用 Burnside 定理即可求解不同着色的方案数。 Color来源 POJ 2154，LG 4980 题意 给定长为 $N\\le 10^9$ 的项链，使用至多 $N$ 种颜色对项链上的珠子着色，考虑在旋转条件下的不同着色方案数，结果对 $1\\le P \\le 3\\times 10^4$ 取模。 分析 旋转置换 $ρ_n^i,i=0,1,\\dots n-1$ 的循环个数为 \\gcd(n, i)根据 Polya 定理，总方案数为 Answer = \\frac 1 n \\sum_{0\\le i \\lt n} |C(\\rho_n^i)| = \\frac 1 n \\sum_{0\\le i \\lt n} n^{\\gcd(n, i)} \\\\ = \\frac 1 n \\sum_{d|n}n^d\\sum_{0\\le i \\lt n}[\\gcd(n, i) =d] \\\\ = \\frac 1 n \\sum_{d|n}n^d\\sum_{0\\le i \\lt n}[\\gcd(n/d, i/d) =1] \\\\ = \\frac 1 n \\sum_{d|n}n^d\\sum_{0\\le i \\lt n/d}[\\gcd(n/d, i) =1] \\\\ = \\frac 1 n \\sum_{d|n}n^d\\phi(n/d) = \\sum_{d|n}n^{d-1}\\phi(n/d) \\\\$O(\\sqrt n)$ 枚举 $n$ 的所有约数 $d$（因为前 10 个质数乘积大于 $10^9$，因此约数个数最多只有 $2^{10}=1024$ 个），快速幂求 $n^{d-1}$，$O(\\sqrt {n/d})$ 求 $\\phi(n/d)$。 Magic Bracelet来源 POJ 2888 题意 给定长为 $1\\le n \\le 10^9$ 的项链，使用 $1\\le m \\le 10$ 种颜色对项链上的珠子着色，考虑旋转同构的不同着色方案数，结果对 9973 取模。此外，限制部分颜色对不能着色于相邻的珠子上。数据保证 $gcd(n, 9973)=1$。 分析 已知循环置换 $ρ_n^i$ 的循环个数为 $\\gcd(n, i)$。对于一个循环圈可表示为 $j+ki(\\mod n)$，则在同一个循环的元素 $x, y$ 要满足 $x \\mod \\gcd(n, i) = y \\mod \\gcd(n, i)$，即循环节大小为 $\\gcd(n, i)$。因为相邻珠子不能着限制颜色对，此时保证前 $\\gcd(n, i) + 1$ 个元素不出现禁止的颜色对即可，问题转化成求解 $k$ 个珠子的项链不出现禁止颜色对的方案数。 转化后的问题可以使用动态规划解决，$dp(i, j)$ 表示前 $i$ 个元素中最后一个元素的颜色为 $j$ 的方案数。记不能相邻的颜色对集合为 $E$，则转移方程为 dp(i, j) = \\sum_{(k,j)\\notin E}dp(i-1,k)由于 $n$ 很大而 $m$ 很小，因此可以使用矩阵 + 快速幂解决。另一方面，项链首尾相接的问题可以通过枚举第一个元素的颜色解决。 Birthday Toy来源 HDU 2865 题意 使用 $4\\le k \\le 10^9$ 种颜色对形如图 1的项链着色，项链包括 $3\\le N \\le 10^9$ 个小珠子以及一个中心的大珠子。要求相邻珠子不能同色，求旋转同构的不同着色方案数，结果对 $10^9+7$ 取模。 图 1. 特殊形状的项链分析 由于中心点的大珠子与所有小珠子均相邻，因此可从 $k$ 种颜色中先选一种颜色对大珠子着色，使得问题转化为使用 $k-1$ 种颜色对普通项链着色。 进而本问题与 POJ 2888 Magic Bracelet 类似，问题进一步转化成长为 $L$ 的项链相邻珠子不同构的着色方案数。使用动态规划思想解决，$dp(i, j)$ 表示前 $i$ 个珠子最后一个颜色为 $j$ 的方案数，转移方程为 dp(i, j) = \\sum_k{dp(i-1,k)} - dp(i-1, j)项链需要解决首尾相接问题，此时通过 $O(k)$ 枚举第一个元素的颜色解决。由于颜色数 $k$ 很大，因此不能使用线性递推的动态规划做法。 在枚举第一个元素的颜色时，不失一般性，假设第一个元素的颜色为 1，那么颜色 2,…,k 是等价的。可以理解为只用 2 种颜色着色，只是第 2 种颜色有 $k - 1$ 种替换， ​因此动态规划的状态只有 $dp(i, 1)$ 和 $dp(i, c), c=2,\\dots, k$，因此转移方程可写成 dp(i, 1) = dp(i-1, 1)+(k-1)dp(i, c) - dp(i-1,1) \\\\ dp(i, c) = dp(i-1,1)+(k-1)dp(i, c)-dp(i-1,c) = dp(i-1,1)+(k-2)dp(i-2,c)写成矩阵形式 \\begin{pmatrix} 0&k-1\\\\ 1&k-2 \\end{pmatrix} \\begin{pmatrix} dp(i-1,1)\\\\ dp(i-1,c) \\end{pmatrix} = \\begin{pmatrix} dp(i,1)\\\\ dp(i,c) \\end{pmatrix}使用快速幂优优化计划 $dp(i, 1)$，进而方案数为 Answer = \\frac 1 n \\sum_{d|n} dp(d, 1)φ(n / d)《组合数学》摘录置换群与对称群置换定义 设 $X$ 是一个有限集 $\\{1, 2, \\dots , n\\}$，$X$ 的每个置换 $f$ f(1)=i_1, f(2)=i_2, \\dots , f(n)=i_n可视为到其自身定义的一对一函数 $f:X\\rightarrow X$，用 $2\\times n $ 阵列表示： \\begin{pmatrix} 1&2&\\dots&n\\\\ i_1&i_2&\\dots&i_n \\end{pmatrix} \\tag1将 $\\{1, 2, \\dots, n\\}$ 的所有 $n!$ 个置换构成的集合记为 $S_n$。 运算 置换的合成运算“$\\circ$”满足结合律，但不满足交换律： (f\\circ g)\\circ h=f\\circ(g\\circ h) \\tag 2恒等置换 各数对应到自身的置换 $\\iota$： \\iota = \\begin{pmatrix} 1&2&\\dots&n \\\\ 1&2&\\dots&n \\\\ \\end{pmatrix} \\tag 3逆函数 如果 $f(s)=k$，那么 $f^{-1}(k)=s$。 置换群定义 若 $S_n$ 的非空子集 $G$ 为 $X$ 的一个置换群，则满足： $\\forall f, g\\in G, f\\circ g \\in G$，即合成运算的封闭性。 恒等置换 $\\iota \\in G$，即包含单位元。 $\\forall f \\in G，f^{-1}\\in G$，即逆元的封闭性。 特殊 $X=\\{1, 2, \\dots, n\\}$ 的所有置换的集合 $S_n$ 是一个置换群，记为 $n$ 阶对称群。集合 $G=\\{\\iota\\}$ 也是一个置换群。 性质 置换群满足消去律：若 $f\\circ g=f\\circ h$，那么 $g=h$。 Burnside定理计算集合 $X$ 的不等价着色数。 设 $G$ 是 $X$ 的一个置换群，$C$ 是一个着色集合，使着色 $c$ 保持不变的集合： G(c)=\\{f:f\\in G, f*c=c\\} \\tag{4}集合 $G(c)$ 称为 $c$ 的稳定核，任何着色的稳定核是一个置换群。 在 $f$ 作用下使着色 $c$ 保持不变的 $G$ 中所有着色的集合： C(f)=\\{c:c\\in C, f*c=c\\} \\tag 5定理1 对于每一种着色 $c$，$c$ 的稳定核 $G(c)$ 是一个置换群，且对 $G$ 中任意置换 $f$ 与 $g$，$gc=fc$当且仅当 $f^{-1}\\circ g$ 属于 $G(c)$。 推论1 设 $c$ 为 $C$ 中的一种着色，那么与 $c$ 等价的着色数等于 $G$ 中的置换个数除以 $c$ 的稳定核中的置换个数 |\\{f*c:f\\in G\\}|=\\frac{|G|}{|G(c)|} \\tag 6证明 对于 $h\\in G(c)$，有 $(f\\circ h)c=f(hc)=fc$，从而对于每个置换 $f$，恰好存在 $|G(c)|$ 个置换，这些置换作用在 $c$ 上跟 $f$ 有同样的效果。 定理2 设 $G$ 是 $X$ 的一个置换群，$C$ 是 $X$ 的一个着色集并且使得对于 $G$ 中的任意 $f$ 与 $C$ 中的任意 $c$，$f*c\\in C$，则 $C$ 中不等价的着色数 $N(G, C)$ 为 N(G, C)=\\frac1 {|G|} \\sum_{f\\in G}|C(f)| \\tag 7换言之，$C$ 中不等价的着色数等于使着色通过 $G$ 中的置换保持不变的着色的平均数。 证明 计数 $f*c=c$ 的对偶 $(f, c)$ 的个数，使用两种不同的方式计数，然后使计数相等。 一种从置换 $f$ 考察，根据定义计数结果为 \\sum_{f\\in G} |C(f)| \\tag 8一种从着色 $c$ 考察，每个 $c$ 对结果的贡献为 |G(c)|=\\frac{|G|}{(与 c 等价的着色数)} \\tag 9计数结果为 \\sum_{c \\in C} \\frac{|G|}{(与c等价的着色数)} \\tag {10}按等价类将着色归类，每个等价类的总贡献为 $|G|$，等价类的个数就是不等价类的着色数 $N(G, C)$，因此公式(10) 等于 N(G,C)\\times |G| \\tag {11}联立公式(8) 和公式(11) 得到 \\sum_{f\\in G}|C(f)|=N(G, C)\\times |G| \\tag {12}Pólya计数公式通过考虑置换的循环结构，计算可变得容易简便。 设 $f$ 是 $X=\\{1, 2, \\dots, n\\}$ 的一个置换，$D_f=(X, A_f)$ 是顶点集为 $X$ 且弧集为 A_f = \\{(i, f(i)):i\\in X\\}的有向图。该有向图有 $n$ 个顶点与 $n$ 条弧，各顶点的入度和出度等于1，因此弧集 $A_f$ 被划分为若干个有向圈，且每个顶点恰好只属于一个有向圈。 如果某些元素以循环的方式被置换且余下元素保持不变，那么称这样的置换为循环置换或简称循环。如果循环中的元素个数为 $k$，则称它为 $k-$循环。 设 $f$ 是集合 $X$ 的任意置换，关于合成运算 $f$ 有化成循环的因子分解 f=[i_1\\ i_2\\ \\dots\\ i_p]\\circ[j_1\\ j_2\\ \\dots\\ j_q]\\circ\\dots\\circ[l_1\\ l_2\\ \\dots\\ l_r] \\tag {13}公式(13) 称为 $f$ 循环因子分解。 对于 $f$ 分解中的每个循环，该循环中的所有元素着色相同，因此着色方案数与循环阶数无关，而与循环个数有关。置换 $f$ 的循环因子分解中的循环个数记为 \\#(f)定理3 设 $f$ 是集合 $X$ 的一个置换，假如用 $k$ 种颜色对 $X$ 的元素进行着色，令 $C$ 是 $X$ 的所有着色的集合，则 $f$ 保持 $C$ 中着色不变的着色数为 |C(f)|=k^{\\#(f)}假设 $f$ 的循环因子分解有 $e_i$ 个 $i$-循环，因 $X$ 的各元素在 $f$ 循环因子分解中恰好出现在一个训话中，所以 $e_i$ 是非负整数且满足 \\sum_{i=1}^{n}ie_i=n \\tag {14}称 $n$ 元组 $(e_1, e_2, \\dots, e_n)$ 是置换 $f$ 的型，记为 type(f)=(e_1, e_2, \\dots, e_n)循环数为 \\#(f)=e_1+e_2+\\dots+e_n因为置换的型仅取决于循环因子分解中循环的阶数，所以不同置换可以有相同的型，我们可引进 $n$ 个不定元 z_1, z_2, \\dots, z_n其中，$z_k$ 对应一个 $k$ 阶循环（$k=1, 2, \\dots, n$）。对于具有 $type(f)=(e_1, e_2, \\dots, e_n)$ 的每个置换 $f$，定义 $f$ 的单项式为 mon(f)=z_1^{e_1}z_2^{e_2}\\dots z_n^{e_n}设 $G$ 是 $X$ 的一个置换群。对 $G$ 中每个置换 $f$ 的单项式求和，得到关于 $G$ 中的置换按照型的生成函数 \\sum_{f\\in G} mon(f)=\\sum_{f\\in G}z_1^{e_1}z_2^{e_2}\\dots z_n^{e_n} \\tag{15}合并公式(15) 中的同类型，$z_1^{e_1}z_2^{e_2}\\dots z_n^{e_n}$ 的系数等于型为 $(e_1, e_2,\\dots, e_n)$ 的 $G$ 中的置换个数。 $G$ 的循环指数定义为该生成函数除以 $G$ 中的置换个数 $G$，即 P_G(z_1, z_2, \\dots , z_n) = \\frac 1 {|G|} \\sum_{f\\in G} z_1^{e_1}z_2^{e_2}\\dots z_n^{e_n}定理4 设 $X$ 是有 $n$ 个元素的一个集合，假设有 $k$ 种可用的颜色集可用来对 $X$ 的元素进行着色。令 $C$ 是 $X$ 的所有 $k^n$ 种着色的集合，$G$ 是 $X$ 的一个置换群。则不等价的着色数是用 $z_i=k(i=1,2,\\dots, n)$ 带入 $G$ 的循环指数中而得到的数，即 N(G,C)=P_G(k,k,\\dots, k)定理5（Polya定理） 设 $X$ 是一个元素集合，$G$ 是 $X$ 的一个置换群，$\\{u_1, u_2, \\dots, u_k\\}$ 是 $k$ 种颜色的一个集合，$C$ 是 $X$ 的任意着色集并且 $G$ 为 $C$ 上的一个置换群，那么根据各颜色的数目，$C$ 的不等价着色数的生成函数是由循环指数 $P_G(z_1, z_2, \\dots, z_n)$ 通过做变量代换 z_j=u_1^j+\\dots+u_k^j\\ (j=1, 2, \\dots, n)而得到的表达式 P_G(u_1+\\dots+u_k, u_1^2+\\dots+u_k^2,\\dots, u_1^n+\\dots+u_k^n) \\tag{16}换言之，公式(16) 中 u_1^{p_1}u_2^{p_2}\\dots u_k^{p_k}的系数等于 $X$ 中的 $p_i$ 个元素着颜色 $u_i$ 的 $C$ 中不等价的着色数。 参考代码Necklace of Beads12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;using namespace std;typedef double db;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define fi first#define se second#define pb push_back#define mp make_pair#define sz(x) ((int)(x).size())#define all(x) begin(x),end(x)#define rep(i,l,r) for(int i=(l);i&lt;(r);++i)#define per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)#define dd(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; \", \"#define de(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; endl//-------inline int __gcd(int x, int y) &#123; return !x ? y : __gcd(y % x, x); &#125;ll kpow(ll a, ll b) &#123; ll r = 1; while (b &gt; 0) &#123; if (b &amp; 1) r = r * a; a = a * a, b &gt;&gt;= 1; &#125; return r;&#125;int main() &#123; int n; while (~scanf(\"%d\", &amp;n) &amp;&amp; ~n) &#123; if (n == 0) &#123; puts(\"0\"); continue; &#125; ll ans = 0; // rotation rep(i, 0, n) &#123; ll circ = __gcd(n, i); ans += kpow(3, circ); &#125; // relection ans += (2 + (n &amp; 1)) * n * kpow(3, n / 2); ans /= 2 * n; printf(\"%I64d\\n\", ans); &#125; return 0;&#125; Color12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;using namespace std;typedef double db;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define fi first#define se second#define pb push_back#define mp make_pair#define sz(x) ((int)(x).size())#define all(x) begin(x),end(x)#define rep(i,l,r) for(int i=(l);i&lt;(r);++i)#define per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)#define dd(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; \", \"#define de(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; endl//-------const int N = 31625;int n, p;vector&lt;int&gt; primes;vector&lt;bool&gt; isprime;int kpow(int a, int b, int mod) &#123; a %= mod; int r = 1; while (b &gt; 0) &#123; if (b &amp; 1) r = r * a % mod; a = a * a % mod, b &gt;&gt;= 1; &#125; return r;&#125;void init() &#123; isprime.resize(N, true); isprime[0] = isprime[1] = false; rep(i, 2, N) if (isprime[i]) &#123; primes.push_back(i); for (int j = i * i; j &lt; N; j += i) isprime[j] = false; &#125;&#125;int phi(int n) &#123; int ret = n; rep(i, 0, sz(primes)) if (primes[i] &lt;= n) &#123; const int &amp;p = primes[i]; if (n % p == 0) &#123; ret -= ret / p; while (n % p == 0) n /= p; &#125; &#125; else break; if (n &gt; 1) ret -= ret / n; return ret; &#125;int main() &#123; init(); int cases; scanf(\"%d\", &amp;cases); rep(casei, 0, cases) &#123; int ans = 0; scanf(\"%d%d\", &amp;n, &amp;p); for (int d = 1; d * d &lt;= n; ++d) &#123; if (n % d) continue; ans += 1ll * kpow(n, d - 1, p) * phi(n / d) % p; if (d * d != n) ans += 1ll * kpow(n, n / d - 1, p) * phi(d) % p; ans %= p; &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125; Magic Bracelet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;using namespace std;typedef double db;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define fi first#define se second#define pb push_back#define mp make_pair#define sz(x) ((int)(x).size())#define all(x) begin(x),end(x)#define rep(i,l,r) for(int i=(l);i&lt;(r);++i)#define per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)#define dd(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; \", \"#define de(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; endl//-------const int P = 9973;const int M = 10;const int N = 31625;int n, m, k;vector&lt;int&gt; prime;bool isprime[N];struct Matrix &#123; int a[M][M]; void init(int x) &#123; rep(i, 0, m) rep(j, 0, m) a[i][j] = i == j ? x : 0; &#125; void fill(int x) &#123; rep(i, 0, m) rep(j, 0, m) a[i][j] = x; &#125; int trace() &#123; int ret = 0; rep(i, 0, m) ret += a[i][i]; return ret % P; &#125; Matrix operator*(const Matrix &amp;mat) const &#123; Matrix r; r.init(0); rep(i, 0, m) rep(j, 0, m) &#123; rep(k, 0, m) r.a[i][j] += a[i][k] * mat.a[k][j]; r.a[i][j] %= P; &#125; return r; &#125; Matrix operator^(int n) &#123; Matrix r, a = *this; r.init(1); while (n &gt; 0) &#123; if (n &amp; 1) r = r * a; a = a * a, n &gt;&gt;= 1; &#125; return r; &#125;&#125;;inline void inc(int &amp;x, int y) &#123; if ((x += y) &gt;= P) x -= P;&#125;void initPrime() &#123; memset(isprime, 1, sizeof(isprime)); isprime[0] = isprime[1] = false; rep(i, 2, N) &#123; if (isprime[i]) prime.push_back(i); for (int j = 0; i * prime[j] &lt; N; ++j) &#123; isprime[i * prime[j]] = false; if (i % prime[j] == 0) break; &#125; &#125;&#125;int phi(int n) &#123; int ret = n; rep(i, 0, sz(prime)) &#123; if (n &lt; prime[i]) break; if (n % prime[i] == 0) &#123; ret -= ret / prime[i]; while (n % prime[i] == 0) n /= prime[i]; &#125; &#125; if (n &gt; 1) ret -= ret / n; return ret;&#125;int f(int n, int d, Matrix &amp;a) &#123; int fd = (a ^ d).trace(); return phi(n / d) % P * fd % P;&#125;void exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) x = 1, y = 0; else &#123; exgcd(b, a % b, y, x); y -= a / b * x; &#125;&#125;int inv(int n) &#123; int x, y; exgcd(n, P, x, y); x = (x % P + P) % P; return x;&#125;int main() &#123; initPrime(); int cases; scanf(\"%d\", &amp;cases); while (cases-- &gt; 0) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); Matrix a; a.fill(1); rep(_k, 0, k) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); --x, --y; a.a[x][y] = a.a[y][x] = 0; &#125; int ans = 0; for (int d = 1; d * d &lt;= n; ++d) &#123; if (n % d) continue; inc(ans, f(n, d, a)); if (d * d != n) inc(ans, f(n, n / d, a)); &#125; ans = ans * inv(n) % P; printf(\"%d\\n\", ans); &#125; return 0;&#125; Birthday Toy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;using namespace std;typedef double db;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define fi first#define se second#define pb push_back#define mp make_pair#define sz(x) ((int)(x).size())#define all(x) begin(x),end(x)#define rep(i,l,r) for(int i=(l);i&lt;(r);++i)#define per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)#define dd(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; \", \"#define de(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; endl//-------const int P = 1e9 + 7;const int M = 2;const int N = 31625;int n, k;vector&lt;int&gt; prime;bool isprime[N];inline void inc(int &amp;x, int y) &#123; if ((x += y) &gt;= P) x -= P;&#125;int kpow(int a, int b) &#123; a %= P; int r = 1; while (b &gt; 0) &#123; if (b &amp; 1) r = 1ll * r * a % P; a = 1ll * a * a % P, b &gt;&gt;= 1; &#125; return r;&#125;struct Matrix &#123; int a[M][M]; void init(int x) &#123; rep(i, 0, M) rep(j, 0, M) a[i][j] = i == j ? x : 0; &#125; Matrix operator*(const Matrix &amp;mat) const &#123; Matrix r; r.init(0); rep(i, 0, M) rep(j, 0, M) rep(k, 0, M) inc(r.a[i][j], 1ll * a[i][k] * mat.a[k][j] % P); return r; &#125; Matrix operator^(int n) &#123; Matrix r, a = *this; r.init(1); while (n &gt; 0) &#123; if (n &amp; 1) r = r * a; a = a * a, n &gt;&gt;= 1; &#125; return r; &#125;&#125;;void initPrime() &#123; memset(isprime, true, sizeof(isprime)); isprime[0] = isprime[1] = false; rep(i, 2, N) &#123; if (isprime[i]) prime.push_back(i); for (int j = 0; i * prime[j] &lt; N; ++j) &#123; isprime[i * prime[j]] = false; if (i % prime[j] == 0) break; &#125; &#125;&#125;int phi(int n) &#123; int ret = n; rep(i, 0, sz(prime)) &#123; if (n &lt; prime[i]) break; if (n % prime[i] == 0) &#123; ret -= ret / prime[i]; while (n % prime[i] == 0) n /= prime[i]; &#125; &#125; if (n &gt; 1) ret -= ret / n; return ret;&#125;int f(int n, int m, int d, Matrix &amp;a) &#123; int fd = 1ll * m * (a ^ d).a[0][0] % P; return 1ll * fd * phi(n / d) % P;&#125;int main() &#123; initPrime(); while (~scanf(\"%d%d\", &amp;n, &amp;k)) &#123; int ans = 0; int m = k - 1; // #color for small beads Matrix a; a.a[0][0] = 0, a.a[0][1] = m - 1; a.a[1][0] = 1, a.a[1][1] = m - 2; for (int d = 1; d * d &lt;= n; ++d) &#123; if (n % d) continue; inc(ans, f(n, m, d, a)); if (d * d != n) inc(ans, f(n, m, n / d, a)); &#125; ans = 1ll * ans * kpow(n, P - 2) % P; ans = 1ll * ans * k % P; printf(\"%d\\n\", ans); &#125; return 0;&#125; 参考资料 Richard A. Brualdi. 组合数学 [M]. 机械工业出版社, 2012","categories":[],"tags":[{"name":"polya","slug":"polya","permalink":"http://mcginn7.github.io/tags/polya/"}]},{"title":"B-Tree","slug":"B-Tree","date":"2019-07-22T04:05:58.000Z","updated":"2019-07-22T04:09:09.000Z","comments":true,"path":"2019/07/22/B-Tree/","link":"","permalink":"http://mcginn7.github.io/2019/07/22/B-Tree/","excerpt":"","text":"简介简单来说，B-Tree 是针对大数据存取的平衡树，考虑了磁盘读取对查找效率的影响。 B-Tree 的主要思想是通过减少磁盘读取次数来提高数据存取性能，而磁盘读取次数与树高相关。故B-Tree 允许每个节点拥有多于 2 个的子节点来减小树高。 与二叉平衡树类似，B-Tree 中的每个节点存储若干键值（keys）以及子节点地址。 图 1. B-Tree 结构图 定义和性质阶（order）：将子节点的允许最大数量定义为阶，如图 1 为 5 阶树。 $m$ 阶的 B-Tree 满足以下定义： 每个节点最多能有 $m$ 个子节点。 每个内部节点至少有 $\\lceil \\frac m2\\rceil$ 个子节点，内部节点（Internal nodes）为除根节点和叶节点以外的节点。 拥有 $k+1$ 个子节点的非叶节点存有 $k$ 个键值。 每个节点中的键值按递增排序。 所有的叶节点高度一样。 操作对于平衡🌳的操作主要就是插入（Insertion）和删除（Deletion）。 以下操作均基于键值两两不同的假设进行讨论，同时键值的数量范围定义为 $[d, 2d]$，阶 $m=2d+1$。 插入首先找到键值归属的叶节点，插入到该节点中，节点的键值数量可能超过上限 $2d$，即当前键值数量为 $2d+1$。 此时用中位数将该节点划分成两个新的节点，每个新节点含有 $d$ 个键值，如图 2 所示。 之后将键值中位数插入到父节点中，父节点的键值数量 +1，也有可能超上限，故需要迭代更新。 图 2. 节点分裂 删除主要思路将内部节点中的删除操作转移至叶节点中，然后自下而上重新平衡，达到键值数量要求。 叶节点直接将对应的键值删除即可。 内部节点假设当前删除键值为 $k$，则 $k$ 的前继 $prev(k)$ 为左子树中的最大键值，后继 $succ(k)$ 为右子树中的最小键值。 $prev(k)$ 和 $succ(k)$ 均可替代 $k$ 作为分割左、右子树的新键值，同时这两个键值必然在叶节点中，进而将删除操作转移到叶节点中。 重平衡在叶节点删除键值后可能出现键值数量为 $d-1$ 导致下溢出。此时通过转移兄弟节点的键值来完成键值补充，主要分两种情况： 合并：当前节点的左、右兄弟节点均只有 $d$ 个键值，此时可与其中一个兄弟节点及父节点中的分割键值合并，新节点的键值数量为 $2d$，相当于节点分裂的逆操作。此时父节点的键值数量减 1，需要迭代重平衡。 图 3. 节点合并 旋转：假设右兄弟节点的键值大于 $d$ 个（左兄弟同理），将父节点的分割键值插入到当前节点中，右兄弟节点的第 1 个键值插入到父节点中。此时当前节点、兄弟节点和父节点的键值数量均满足键值数量要求，完成平衡操作。 图 4. 旋转操作 参考 wikipeadia geeksforgeeks","categories":[],"tags":[]},{"title":"AhoCorasick Algorithm","slug":"AhoCorasick-Algorithm","date":"2019-05-31T02:23:33.000Z","updated":"2019-06-01T02:09:54.855Z","comments":true,"path":"2019/05/31/AhoCorasick-Algorithm/","link":"","permalink":"http://mcginn7.github.io/2019/05/31/AhoCorasick-Algorithm/","excerpt":"","text":"简介AhoCorasick 算法（简称 AC 自动机），解决多模式串的字符匹配问题，即给定若干个单词串 $W_i$，求在文本串 $T$ 中的出现位置。KMP 算法解决单模式串的字符匹配，所以 AC 自动机可认为是 KMP 算法的扩展。 预备知识 字典树（Trie）：树上任意节点到根的路径所构成的子串，记为 $S(u)$，都是某个插入串的前缀。 KMP 算法：利用最长前后缀完成线性匹配。 核心思想AhoCorasick 本质上与 KMP 算法是一样的，都是通过相同前后缀减少重复计算问题，只是数据结构不同。 对应于 KMP，AC 自动机需要构建最长公共前后缀（LCPS，Longese Common proper Prefix and Suffix），即对于树上任意节点 $u$，找出最大树深的节点 $v$，满足 $S(v)$ 是 $S(u)$ 的真后缀。因为字典树上的任意节点 $x$ 所表示的 $S(x)$ 都是前缀，故起名最长公共前后缀。 通常将节点 $v$ 记为 $fail(u)$，表示串 $S(u)$ 失配时的跳转节点，出于可读性的考虑，本文记为 $lcps(u)$。 $lcps(u)$ 的构建过程：记节点 $u$ 的父节点为 $f(u)$，与其连边的字符为 $c$。若 $lcps(f(u))$ 存在 $c$ 的出边，则 $lcps(u)=trans(lcps(f(u)), c)$。否则继续找 $lcps(lcps(f(u)))$，直至找到或到达根节点（说明未找到）。 图 1. lcps(u) 的构建 检索过程假设已知 $lcps(u)$，且字典树节点 $u$ 与文本串 $T[0:i]$ 匹配，即 $T[i-|S(u)|+1:i] = S(u)$。继续匹配有两种情形： $trans(u, T[i+1]) \\neq NULL$，则匹配长度 +1。 $trans(u, T[i+1])=NULL$，与 KMP 类似，在字典树中找出最大深度（即最长前缀）的节点 $v$，满足 $S(v)$ 是 $S(u)$ 的真后缀，同时 $trans(v, T[i+1])\\neq NULL$。 令 $v = lcps(u)$，判断是否能匹配，否则继续判断 $lcps(lcps(u))$。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243const int N = 5e5 + 7; // sum(|Wi|)const int E = 26; // character set sizestruct AhoCorasick &#123; int root = 0; int n, lcps[N], trans[N][E]; int end[N]; // end[u] &gt; 0 : S(u) = Wi int new_node() &#123; memset(trans[n], 0, E * sizeof(int)); lcps[n] = root, end[n] = 0; return n++; &#125; void init() &#123; n = 0; root = new_node(); &#125; void insert(const char *str, int len) &#123; int u = root; for (int i = 0; i &lt; len; ++i) &#123; int c = str[i] - 'a'; if (!trans[u][c]) trans[u][c] = new_node(); u = trans[u][c]; &#125; ++end[u]; &#125; void LCPS() &#123; queue&lt;int&gt; Q(&#123;root&#125;); while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (int c = 0; c &lt; E; ++c) &#123; if (trans[u][c]) &#123; int v = lcps[u]; while (v != root &amp;&amp; !trans[v][c]) v = lcps[v]; lcps[trans[u][c]] = u == root ? root : trans[v][c]; Q.push(trans[u][c]); &#125; else trans[u][c] = trans[lcps[u]][c]; &#125; &#125; &#125;&#125;;","categories":[],"tags":[{"name":"AhoCorasick","slug":"AhoCorasick","permalink":"http://mcginn7.github.io/tags/AhoCorasick/"},{"name":"AC自动机","slug":"AC自动机","permalink":"http://mcginn7.github.io/tags/AC自动机/"}]},{"title":"Knuth-Morris-Pratt Algorithm","slug":"Knuth-Morris-Pratt-Algorithm","date":"2019-05-24T15:39:27.000Z","updated":"2019-07-26T08:50:05.000Z","comments":true,"path":"2019/05/24/Knuth-Morris-Pratt-Algorithm/","link":"","permalink":"http://mcginn7.github.io/2019/05/24/Knuth-Morris-Pratt-Algorithm/","excerpt":"","text":"KMP 算法解决在文本串（text）快速找出单词（word）的所有出现位置。 暴力匹配的时间复杂度为 $O(|T||W|)$，而 KMP 算法通过引入最长前后缀，将检索的时间复杂度降至线性。 最长前后缀 lps indicates longest proper prefix which is also suffix. 最长前后缀（LPS, Longest proper Prefix and Suffix）表示既是原串 $S$ 的真前缀也是后缀的最长子串 $T$，其中 $|T|\\lt |S|$。 LPS(aaa) = aa \\\\ LPS(abcdab)=ab检索过程假设已知单词串的每个前缀 $W[0: i]$ 的最长前后缀长度 $lps(i)$，且已经匹配 $T[i - j: i] = W[0:j]$。继续匹配有两种情形： $T[i+1]=W[j + 1]$，则匹配长度 +1。 $T[i+ 1] \\neq W[j+1]$，此时显然要重新找单词串的一个最长前缀 $W[0:k], k\\lt j$，使得 $T[i-k:i]=W[0:k]$ 且 $T[i + 1]=W[k+ 1]$，继续与 $i+1$ 结尾的文本串匹配。 图 1. 情形 2 示意图。虚线框表示相同部分。此时 $W[0:k]$ 与 $W[0:j]$ 的后缀相同，同时其本身是前缀。 令 $k=lps(j)$，若 $T[i+1]=W[k+1]$，则继续匹配。否则将 $k$ 视为新的 $j$，则转化成情形 2 相同的子问题。 时间复杂度：匹配成功的复杂度是线性的。而匹配失败时会减小单词串的前缀长度，减一长度至少对应一次的成功匹配，此时时间复杂度也是线性的。故算法总的时间复杂度是线性的。 预处理对于单词串的最长前后缀 $lps(i)$，本质上是单词串的自我匹配，即此时文本串为单词串。对应于检索过程中的两种情形，可以很容易地完成 $lps(i)$ 的构造。 参考代码1234567891011121314151617// n = |T|, m = |W|, index = [0, n)lps[0] = -1;for (int i = 1, j = -1; i &lt; m; ++i) &#123; while (j &gt;= 0 &amp;&amp; W[i] != W[j + 1]) j = lps[j]; j += W[i] == W[j + 1]; lps[i] = j;&#125;for (int i = 0, j = -1; i &lt; n; ++i) &#123; while (j &gt;= 0 &amp;&amp; T[i] != W[j + 1]) j = lps[j]; j += T[i] == W[j + 1]; if (j == m - 1) &#123; // match successfully j = lps[j]; &#125;&#125;","categories":[],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://mcginn7.github.io/tags/KMP/"}]},{"title":"ICPC Resolver 踩坑","slug":"ICPC-Resolver-踩坑","date":"2019-05-12T14:09:44.000Z","updated":"2019-05-22T05:41:41.127Z","comments":true,"path":"2019/05/12/ICPC-Resolver-踩坑/","link":"","permalink":"http://mcginn7.github.io/2019/05/12/ICPC-Resolver-踩坑/","excerpt":"","text":"应用场景从 DOMjudge 系统中导出数据，使用 ICPC Tools/Resolver 滚榜。 DOMjudge 版本：7.0.1。 Resolver 版本：2.0.1798。如果使用 DOMjudge 评测，建议使用 2.1 及以上版本。 数据操作 搜索 ICPC Tools，下载 ICPC Resolver.rar。 运行 award.sh，通过 REST 导入 event feed（一场比赛的所有信息流）。 123URL: http://59.77.134.102/domjudge/api/contests/5USER: amdinPassword: ******* 点击 save 保存为 “events.xml”。 目前版本（2.0.1798）的 Resolver 存在 bug，需要手动修订 events.xml 文件： 第 1、2 行重复 &lt;contest&gt;，删除其中一行。 &lt;problem&gt; 中的生成 &lt;id&gt; 从 0 开始，改成从 1 开始（否则导致部分提交不合法）。 删除信息不全的队伍，必要信息有： 1234567&lt;team&gt; &lt;id&gt;221801437&lt;/id&gt; &lt;name&gt;Teamaaa&lt;/name&gt; &lt;university&gt;福州大学&lt;/university&gt; &lt;university-short-name&gt;福州大学&lt;/university-short-name&gt; &lt;region&gt;Participants&lt;/region&gt;&lt;/team&gt; university-short-name 为滚榜中显示的学校名称，故这里写学校全称。 末尾添加 finalized 信息： 1234567&lt;finalized&gt; &lt;last-gold&gt;1&lt;/last-gold&gt; &lt;last-silver&gt;2&lt;/last-silver&gt; &lt;last-bronze&gt;3&lt;/last-bronze&gt; &lt;timestamp&gt;1557574214.130&lt;/timestamp&gt;&lt;/finalized&gt;&lt;/contest&gt; timestamp 可设置成任意值。 可使用该代码 icpc_resolver_revise_events_xml 修订 events.xml。 使用 award.sh 打开处理后的 events.xml，设置金银铜奖人数，然后导出新的 xml 文件，并重新修订 events.xml 文件。 由于 award.sh 金银铜每组上限 10 个，共 30 个。不符合中国国情，故需要在 events.xml 中手动修改 last-gold 等字段。若 last-gold=3, last-silver=10，则表示设置金奖 3 个，银奖 7 个。 生成的 &lt;award&gt; 的 citation 可设置成 “金奖”、“银奖” 中文显示。 调用以下指令开始滚榜： 1resolver.sh &lt;Path to CDP&gt; CDP（Contest Data Package）是提供榜单需要的数据目录，其中包括： config 目录，根据官方 wiki 设置即可，必要文件包括： contest.yaml：设置比赛标题、时长和封榜时间。 problemset.yaml：设置题目 id，题目名称。 groups.tsv, teams.tsv：从 DOMjudge 导出。 userdata.tsv：官方 wiki 提示必须，实际上似乎可去除。 events.xml：比赛信息； images/logo/team_id.png：学校图标，每个学校的在 events.xml 的第一支队伍 id，id 不包含前导 0； images/team/team_id.jpg：队伍照片，若出现 Out Of Memory 问题，则限制队伍照片的大小或者加大 resolver.sh 中 -Xmx 参数。 榜单目前并不支持队伍、学校的中文显示，需要使用压缩工具（如 Bandizip）打开 “resolver/lib/presentContest.jar”，使用支持中文的字体替换 “font/HELV.PFB” 即可。","categories":[],"tags":[]},{"title":"斜率优化","slug":"斜率优化","date":"2019-04-03T13:11:53.000Z","updated":"2019-04-03T13:33:24.557Z","comments":true,"path":"2019/04/03/斜率优化/","link":"","permalink":"http://mcginn7.github.io/2019/04/03/斜率优化/","excerpt":"","text":"斜率优化针对形如： dp(i)=\\min _{j=1}^{i-1} (dp(j)+cost(i, j))的动态规划转移方程，可通过’’斜率’’的单调性进行优化。 题一、[HNOI2008]玩具装箱TOY题意 题目链接给定长为 $1\\le N\\le 50000$ 的序列 $1\\le C_i\\le 10^7$，将序列分成若干连续段，每段 $[i, j]$ 的花费为 ((j - i+\\sum_{k=i}^jC_k)-L)^2其中 $L$ 为常数，$1\\le L \\le 10^7$。要求计算总的最小花费代价。 解题思路利用前缀和 $S_i​$，区间 $[i, j]​$ 序列和可表示成 $S_j - S_{i-1}​$。容易想到 dp 转移方程为： dp(j)=\\min_{i=0}^{j-1}(dp(i)+cost(i, j)) \\\\ cost(i, j) = ((j - (i + 1) + S_j - S_i) - L)^2将变量整理归类，记 $a_j=j+S_j, b_i=i+S_i+L+1$，则 $cost(i, j)$ 转化成： cost(i, j) = (a_j-b_i)^2 = a_j^2+b_i^2-2a_jb_i转移方程移项可得： 2a_jb_i + dp(j)-a_j^2=dp(i)+b_i^2因为 $a_j​$ 在 $j​$ 固定时可认为是个定值，故问题相当于最小化 $dp(j)-a_j^2​$，进而可以将问题看成是斜率为 $2a_j​$ 的直线，找出一点 $(b_i, dp(i)+b_i^2)​$ 使得直线在 $y​$ 轴的截距 $dp(j) - a_j^2​$ 最小。 图 1. 下凸壳。灰色点和黑色点分别表示非凸壳点和凸壳点。 显然，截距最小的关键点必然在下凸壳上，且下凸壳的每段斜率是单调递增的。 斜率为 $g$ 的直线截距最小所对应的最优点是，该点前一段斜率 $\\lt g$，后一段斜率 $\\gt g​$。 注意 $1\\le C_i \\Rightarrow S_i \\lt S_{i + 1} \\Rightarrow a_i=i+S_i \\lt a_{i + 1}=(i + 1) + S_{i + 1}$，斜率 $a_i$ 是单调递增的，则对应的最优点位置也是单调的，所以这种情况可通过双端队列将复杂度优化到 $O(n)​$。 题二、小A与最大子段和题意 题目链接给定长为 $1\\le N \\le 2\\times 10^5​$ 的序列 $0 \\le |A_i| \\le 2000​$，找一个非空连续子段 $B​$，最大化： \\sum_{i=1}^{|B|} i\\times B_i解题思路把问题进一步公式化： Ans = \\max_{1\\le i\\le j\\le N} \\{\\sum_{k=i}^j(k-i+1)\\times A_k\\} \\tag 1为了去除 $\\sum$ ，引入前缀和 $S_i$ 和 $V_i=\\sum_{p=1}^i p\\times A_p​$，公式 (1) 转化成： Ans = \\max_{0\\le i\\lt j\\le N} \\{(V_j-V_i)-i\\times(S_j-S_i)\\} \\tag 2根据变量下标整理归类： Ans = -S_j\\times i+(i\\times S_i-V_i) + V_j \\\\ \\Rightarrow S_j\\times i+(Ans - V_j) = i\\times S_i- V_i同”玩具装箱TOY”，此时相当于令截距 $Ans - V_j$ 最大，所以此时需要维护点集 $(i, iS_i-V_i)$ 的上凸壳。 因为 $A_i$ 存在负数，故斜率 $S_i$ 并不具有单调性，所以需要二分确定最优点的位置。 参考 斜率优化DP 斜率优化dp小结 代码[HNOI2008]玩具装箱TOY12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;typedef double db;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define fi first#define se second#define pb push_back#define sz(x) ((int)(x).size())#define all(x) begin(x),end(x)#define rep(i,l,r) for(int i=(l);i&lt;(r);++i)#define per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)#define dd(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; \", \"#define de(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; endl//-------const int N = 5e5 + 7;int n, L, C[N];ll S[N], dp[N];struct P &#123; ll x, y; P() &#123;&#125; P(ll _x, ll _y) &#123; x = _x, y = _y; &#125; P operator-(const P &amp;p) const &#123; return P(x - p.x, y - p.y); &#125; ll operator^(const P &amp;p) const &#123; return x * p.y - y * p.x; &#125;&#125;;#define X(i) (i + S[i] + L + 1)#define Y(i) (dp[i] + X(i) * X(i))int main() &#123; scanf(\"%d%d\", &amp;n, &amp;L); rep(i, 1, n + 1) scanf(\"%d\", C + i); rep(i, 1, n + 1) S[i] = S[i - 1] + C[i]; deque&lt;P&gt; Q; Q.push_back(P(X(0), Y(0))); rep(i, 1, n + 1) &#123; ll g = 2 * (i + S[i]); while (sz(Q) &gt; 1 &amp;&amp; (Q[1].y - Q[0].y) &lt; (Q[1].x - Q[0].x) * g) Q.pop_front(); dp[i] = Q[0].y - g * Q[0].x + (i + S[i]) * (i + S[i]); P a(X(i), Y(i)); while (sz(Q) &gt; 1 &amp;&amp; ((Q[sz(Q) - 2] - a) ^ (Q.back() - a)) &lt;= 0) Q.pop_back(); Q.push_back(a); &#125; printf(\"%lld\", dp[n]); return 0;&#125; 小A与最大子段和12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;typedef double db;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define fi first#define se second#define pb push_back#define sz(x) ((int)(x).size())#define all(x) begin(x),end(x)#define rep(i,l,r) for(int i=(l);i&lt;(r);++i)#define per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)#define dd(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; \", \"#define de(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; endl//-------const int N = 2e5 + 7;int n, a[N];ll S[N], V[N];#define X(i) (i)#define Y(i) (i * S[i] - V[i])struct P &#123; ll x, y; P() &#123;&#125; P(ll _x, ll _y) &#123; x = _x, y = _y; &#125; P operator-(const P &amp;p) const &#123; return P(x - p.x, y - p.y); &#125; ll operator^(const P &amp;p) const &#123; return x * p.y - y * p.x; &#125;&#125;;bool chk(deque&lt;P&gt; &amp;Q, int i, ll G) &#123; return (Q[i + 1].y - Q[i].y) &gt;= (Q[i + 1].x - Q[i].x) * G; &#125;int main() &#123; scanf(\"%d\", &amp;n); rep(i, 1, n + 1) scanf(\"%d\", a + i); rep(i, 1, n + 1) S[i] = S[i - 1] + a[i]; rep(i, 1, n + 1) V[i] = V[i - 1] + i * a[i]; deque&lt;P&gt; Q; Q.push_back(P(X(0), Y(0))); ll ans = LLONG_MIN; rep(i, 1, n + 1) &#123; // answer int l = 0, r = max(0, sz(Q) - 2); while (l + 1 &lt; r) &#123; int z = (l + r) &gt;&gt; 1; chk(Q, z, S[i]) ? l = z : r = z; &#125; int j = l; if (chk(Q, r, S[i])) j = r + 1; else if (chk(Q, l, S[i])) j = l + 1; else j = l; ll f = Q[j].y - S[i] * Q[j].x + V[i]; ans = max(ans, f); // maintain P a(X(i), Y(i)); while (sz(Q) &gt; 1 &amp;&amp; ((Q[sz(Q) - 2] - a) ^ (Q.back() - a)) &gt;= 0) Q.pop_back(); Q.push_back(a); &#125; printf(\"%lld\", ans); return 0;&#125;","categories":[],"tags":[{"name":"ICPC","slug":"ICPC","permalink":"http://mcginn7.github.io/tags/ICPC/"},{"name":"斜率优化","slug":"斜率优化","permalink":"http://mcginn7.github.io/tags/斜率优化/"}]},{"title":"Nowcoder-出题人的数组","slug":"Nowcoder-出题人的数组","date":"2019-03-31T12:11:49.000Z","updated":"2019-04-03T14:01:43.233Z","comments":true,"path":"2019/03/31/Nowcoder-出题人的数组/","link":"","permalink":"http://mcginn7.github.io/2019/03/31/Nowcoder-出题人的数组/","excerpt":"","text":"链接：https://ac.nowcoder.com/acm/contest/545/C来源：牛客网 题目描述出题人有两个数组 $A, B$，请你把两个数组归并起来使得 $Cost=∑i∗C_i$ 最小，要求两个原数组的顺序在新数组中保持不变。 输入描述第一行输入两个正整数 $n,m$，分别表示数组 $A, B$ 的长度。第二行输入 $n$ 个正整数，表示数组 $A$。第二行输入 $m$ 个正整数，表示数组 $B$ 。 输出描述一个正整数，表示最小代价 $Cost$。 示例 1输入输出3 31 3 52 6 475 备注$n, m \\le 100000$ $A_i, B_i \\le 100000$ 解题思路$O(nm)$ 动态规划很容易想到，但是复杂度太高且没有方法优化，那么就考虑贪心解法。 显然，合并后的数组 $C$ 格式为 $\\dots ABABA\\dots$，即一段 $A$ 接一段 $B$ 。 常见的贪心策略为，考虑相邻元素的交换是否会导致更优的结果。由于不能打乱原先的顺序，故总是后段的前缀替换前段的后缀，不失一般性，我们可以假设前段为 $A$，后段为 $B$。 记 $Cost(A) = \\sum_{i = 1} ^ {|A|}i\\times A_i$，则原先的贡献值为 $Cost(A)+Cost(B)+|A|\\times Sum(B)$，交换后的贡献值为 $Cost(A)+Cost(B)+|B|\\times Sum(A)$，则当 $|B|\\times Sum(A) \\lt |A|\\times Sum(B)$，即 \\frac{Sum(A)}{|A|} \\lt \\frac{Sum(B)}{|B|}也就是说，均值越大的段需要优先选择。 剩下的就是如何构造这些段，我们假设串 $A=A_1A_2$，当 $Average(A_1)\\lt Average(A_2)$ 时，在数组 $C$ 中总会合并成一段，根据这一性质在原数组中利用单调栈即可构造初始的段，之后就是从数组 $A,B​$ 贪心选择均值较大的段。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;typedef double db;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define fi first#define se second#define pb push_back#define sz(x) ((int)(x).size())#define all(x) begin(x),end(x)#define rep(i,l,r) for(int i=(l);i&lt;(r);++i)#define per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)#define dd(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; \", \"#define de(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; endl//-------const int N = 1e5 + 7;int n, m, A[N], B[N];struct Node &#123; int num; ll sum; Node() &#123;&#125; Node(int _num, ll _sum) &#123; num = _num, sum = _sum; &#125; Node operator+(const Node &amp;p) const &#123; return Node(num + p.num, sum + p.sum); &#125; bool operator&lt;(const Node &amp;p) const &#123; return sum * p.num &lt; p.sum * num; &#125;&#125; a[N], b[N];int gao(int n, int *r, Node *a) &#123; int top = 0; rep(i, 0, n) &#123; scanf(\"%d\", r + i); Node v(1, r[i]); while (top &gt; 0 &amp;&amp; a[top - 1] &lt; v) v = a[--top] + v; a[top++] = v; &#125; return top;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); int la = gao(n, A, a), lb = gao(m, B, b); n = m = 0; ll ans = 0; for (int i = 0, j = 0; i &lt; la || j &lt; lb; ) &#123; while (i &lt; la &amp;&amp; (j == lb || !(a[i] &lt; b[j]))) &#123; rep(k, n, n + a[i].num) ans += 1ll * (k + m + 1) * A[k]; n += a[i++].num; &#125; while (j &lt; lb &amp;&amp; (i == la || !(b[j] &lt; a[i]))) &#123; rep(k, m, m + b[j].num) ans += 1ll * (k + n + 1) * B[k]; m += b[j++].num; &#125; &#125; printf(\"%lld\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"ICPC","slug":"ICPC","permalink":"http://mcginn7.github.io/tags/ICPC/"},{"name":"贪心","slug":"贪心","permalink":"http://mcginn7.github.io/tags/贪心/"}]},{"title":"论文笔记 Tips and Tricks for Visual Question Answering","slug":"论文笔记-Tips-and-Tricks-for-Visual-Question-Answering","date":"2018-10-09T03:24:19.000Z","updated":"2018-11-12T03:27:34.887Z","comments":true,"path":"2018/10/09/论文笔记-Tips-and-Tricks-for-Visual-Question-Answering/","link":"","permalink":"http://mcginn7.github.io/2018/10/09/论文笔记-Tips-and-Tricks-for-Visual-Question-Answering/","excerpt":"","text":"简介​ 该论文作者取得了 2017 VQA Challenge 的第一，总结一些 tips 和 tricks 来提升 VQA 的表现。 ​ 这篇论文的每个实验使用不同的随机种子重复3次实验来统计结果。 模型 一些细节 所有问题的长度固定 14。 问题特征 $q$ 与图像特征 $\\hat v$ 的融合使用 Hadamard product（逐项相乘）。 h = f_q(q) \\circ f_v(\\hat v) 目标函数（损失函数） L=-\\sum_i^M\\sum_j^N s_{ij}\\log (\\hat s_{ij})-(1-s_{ij})\\log(1-\\hat s_{ij}) 作者使用了额外的数据集 Visual Genome(VG)，共 485,000。 关键点Sigmoid output 输出使用 sigmoid 将每个类别（或答案）归一化。 softmax 也可以用来归一化，但是会变成单个类别输出，而 sigmoid 可以输出多个类。这样可以适应一个问题有多个答案的情况。 Soft scores as ground truth targets VQA 中问题答案附有置信度，将答案向量化有 2 种做法：1）使用固定阈值将答案二值化；2）使用 sigmoid 或 softmax 来归一化答案。 做法1）就是 hard scores，每个类只有 0、1 两个选项。做法2）就是 soft scores，每个类都有一个浮点数的得分。 作者使用了两个简单的二值化进行对比 s'_{ij}=(s_{ij}>0.0) \\\\ s'_{ij}=(s_{ij}==1.0) Gated tanh activations 使用 gated tanh activations 作为激活函数，而不是常用的 Rectified Linear Unit（ReLU）。 激活函数 $f_a: x \\in R^m \\rightarrow y \\in R^n$ \\tilde y = tanh(Wx + b) \\\\ g = \\sigma(W'x+b') \\\\ y = \\tilde y \\circ g$W,W’,b,b’$ 为训练参数，$\\circ$ 表示 Hadamard product（逐项相乘）。 该激活函数之前被用于自然语言处理。 Bottom up attention 使用 bottom up attention 来提取图像特征，而不是直接使用 CNN 的特征层（feature map）。 Bottom up attention 基于 Faster R-CNN 框架，提取若干 Region of Interest（RoI）的特征，继而通过非线性层做 attention。论文里使用阈值来筛选出 $K$ 个 RoI 并设置了 100 的上限（作者将数量 $K$ 固定为 36，表现会差一些，但是减少了计算开销）。 Attention 的非线性层 a_i=w_af_a(v_i, q) \\\\ \\alpha = softmax(a) \\\\ \\hat v = sum_{i=1}^K \\alpha_i v_i$q$ 为问题表示向量，$v_i$ 为 RoI 的特征向量。 使用 bottom up attention 相对于传统的 CNN 提取特征，提升是很明显的。 Pretrained representations to initialize 论文提出了加入先验知识 $w_o^{text}$ 和 $w_o^{img}$ 来初始化输出层参数 \\hat s = \\sigma(w_o^{text}f_o^{text}(h)+w_o^{img}f_o^{img}(h)) $w_o^{text}$ 使用 GloVe word embedding 初始化。 $w_o^{img}$ 使用谷歌图片搜索 10 张对应图片并用 ResNet-10 提取特征，10 个特征向量均值化得到最终的向量表示。 这个做法提升了大约 0.87 个点。 Larger mini-batches 通常来说，mini-batches 越大效果越好，但是大到一定程度后就不会有明显提升了，训练速度会慢。 Smart shufﬂing batch 通常从数据中随机抽取。针对 VQA 这个问题来说，同个问题关联到不同图像会得到不一样的答案（balanced pair），所以作者提出了 smart shuffling 控制 balanced pair 的比例。 这个做法 VQA 得分与随机做法差不多，但是提升了 Accuracy over paris。","categories":[],"tags":[]},{"title":"Windows 下使用 Vim","slug":"Vim-for-windows-配置","date":"2018-10-08T11:43:06.092Z","updated":"2019-07-29T13:15:07.000Z","comments":true,"path":"2018/10/08/Vim-for-windows-配置/","link":"","permalink":"http://mcginn7.github.io/2018/10/08/Vim-for-windows-配置/","excerpt":"","text":"简要说明主要针对 ACM/ICPC 竞赛选手在 Windows 10 系统下使用 vim 编写 C/C++ 代码。 功能配置： 编译和运行 *.cpp 文件； 一键复制代码; 记事本打开代码。 git bash 和 gvim 都配置了一遍。gvim 使用 Windows 自带的 cmd 运行的话，鼠标是没办法移动光标的，并且配置相对 git bash 较麻烦，所以推荐使用 git bash。 Vimrc 配置 编辑安装路径下的 vimrc 文件，例如 “D:\\Git\\etc\\vimrc”，配置快捷键。 123456set nu ai ci si mouse=a ts=4 sts=4 sw=4nmap&lt;F2&gt; :vs %&lt;.in &lt;CR&gt;nmap&lt;F3&gt; :w !clip.exe &lt;CR&gt; &lt;CR&gt;nmap&lt;F4&gt; :!write % &lt;CR&gt;nmap&lt;F8&gt; :!./%&lt; &lt; %&lt;.in &lt;CR&gt;nmap&lt;F9&gt; :!g++ % -o %&lt; -O2 -g -Wall -std=c++11 &lt;CR&gt; 额外配置 vimrc 文件默认有一些配置，可根据需要修改。 123set vb \"这个不关的话，触发某些条件会闪屏set laststatus=1 \"窗口底部状态栏的行数（默认是2），这里设置成1。au FileType c,cpp setlocal comments-=:// comments+=f:// \"取消换行自动注释 设置 Ctrl + Alt + T 快捷键启动 Git Bash 终端。 创建 “git-bash.exe” 的快捷方式，打开快捷方式的属性窗口，修改起始位置，并设置快捷键。 打开控制面板，找到 “管理工具”， 将快捷方式复制到该文件夹中。","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"http://mcginn7.github.io/tags/vim/"},{"name":"git bash","slug":"git-bash","permalink":"http://mcginn7.github.io/tags/git-bash/"}]},{"title":"DOMjudge 配置","slug":"DOMjudge配置","date":"2018-10-04T15:29:36.000Z","updated":"2019-05-21T07:05:41.037Z","comments":true,"path":"2018/10/04/DOMjudge配置/","link":"","permalink":"http://mcginn7.github.io/2018/10/04/DOMjudge配置/","excerpt":"","text":"Domserver 部署PHP timezone php.ini 文件位置 CentOS/RedHat/Fedora = /etc/php.ini Ubuntu/Debian/LinuxMint = /etc/php5/apache2/php.ini 选择时区，通常定位为 “Asia/Shanghai” PHP: List of Supported Timezones 编辑 php.ini 文件 1date.timezone = \"Asia/Shanghai\" 重启 Apache Service。 1sudo service apache2 restart MySQL maximum connections原先编辑 \\etc\\mysql\\my.cnf 添加 max_connections = 1000，然后重启 apache2 即可。但是设置后一直为 214，因为该值受限于 table_open_ache 和 open_files_limit。 下面的方法在 Ubuntu 16.04 和 MySQL 5.7.23 版本实验成功： 运行下面的命令，设置 open_files_limit 1systemctl edit mysql 输入以下内容 12[Service]LimitNOFILE=8000 重启服务 12systemctl daemon-reloadsystemctl restart mysql 数据导入测试数据导入在 Problems 页面下可以编辑 Problem name, Time limit 这些信息，测试数据（Testcases）在页面上只能单点添加和修改，并且不能删除。 批量导入测试数据步骤： 先添加题目，填入”Problem name”、”Time limit” 和 “Memory limit” 等信息，其余的保存默认即可，但是暂不添加 “Testcases”。 点击该题目的导出按钮，下载得到一个压缩包。解压后的文件夹内容如下： 12345678910// 在Windows使用 tree/f 生成该目录文本信息│ domjudge-problem.ini│ problem.yaml│├─data│ ├─sample│ └─secret│└─problem_statement problem.pdf 目录 sample 和 secret 可自行创建，两个目录存放样例数据和隐藏数据（即测试数据）。 将数据 “0.in”，“0.ans” 放入对应的文件夹下，重新压缩成新的压缩包。 在题目的编辑页面，通过 Upload problem archive 上传新压缩包。注意 Contest 选项选择为 Do not add / update contest data，否则可能会上传失败。 队伍账号导入 Domjudge队伍导入 - 参考链接 需要在 home &gt; import / export 页面下，导入 teams.tsv 和 accounts.tsv 这两个文件。在编辑这两个文件时，需要使用 UTF-8 格式，否则会上传失败或导致乱码。 teams.tsv 该文件用于描述队伍信息，包含一版本行，接着每个队伍占用一行，每行包括用制表符（tab）分隔的字段。 首行为版本行，格式如下： FieldDescriptionExampleType1Labelteamsfixed string (always same value)2Version number1integer 队伍描述行，格式如下： FieldDescriptionExampleType1Team Number22integer2External ID24314integer3Group ID3integer4Team nameHoosstring5Institution nameFuzhou Universitystring6Institution short nameFZUstring7Country CodeCHNstring ISO 3166-1 alpha-3 8Affiliation External IDFuzhou Universitystring Group ID 对应 Categories 中的 ID，表示队伍的角色，如女队、打星队等。 accounts.tsv 该文件用于描述账号信息，同样包含版本行和账号行，每个账号占用一行。 首行版本行的格式如下： FieldDescriptionExampleType1Labelaccountsfixed string (always same value)2Version number1integer 账号描述行的格式如下： FieldDescriptionExampleType1Account Typeteamstring2Full Namewtfstring3Usernameteam099string4PasswordB!5MWJiystring Account Type 取值为：team, judge, admin, analyst。这里要导入队伍账号，所以该字段在这固定为 team。 注意：需要设置 Username 的格式才能将账号和队伍关联起来，规则为：Username 的整数部分需要和 team.tsv 中的 Team Number 一致。比如一支队伍 Team Number 为 99，则 Username 可以设置为 team-099。 导入样例 team.tsv 文件 1234teams 18 team008 3 三核战队 福州大学 FZDX CHN 福州大学18 team018 3 挂机不队 福州大学 FZDX CHN 福州大学31 team031 3 这都是什么鬼 福州大学 FZDX CHN 福州大学 accounts.tsv 文件 1234accounts 1team 三核战队 team008 T3yRt3team 挂机不队 team018 86MFyBteam 这都是什么鬼 team031 RTJr6e 评测机Unprivileged user and group1234// 下面这条命令是必须运行的useradd -d /nonexistent -U -M -s /bin/false domjudge-run// X=1~4，X通常等同于CPU核心数useradd -d /nonexistent -U -M -s /bin/false domjudge-run-X Linux Control Groups 每次重启都需要运行 judgehost/bin/create_cgroups，否则提交会编译错误。 问题集锦1. 比赛正常需要几台机器？个人认为正常应该至少需要 4 台机器，配置较高的作为主服务器，即 DOMserver，提供比赛的 web 页面；一台打印服务器，也安装 DOMserver，但开放 print 页面，达到比赛与打印分开，减少宕机对选手的影响；两台评测机，即 Judgehost，这样如果一台宕机，也有另一台继续评测，而不是完全中断评测，并且修复后可随时上线新的评测机。 由于安装的机器较多且安装包大，建议使用 apt-offline 打包需要的安装包，节省安装时间。 2. 气球状态页面返回 500 错误正式比赛开始时，contest 只能留有一个比赛。（个人不知道原因）。 3. 测试数据上传失败可能需要修改的几个文件： /etc/apache2/conf-avaliable/domjudge.conf 123456&lt;IfModule mod_php7.c&gt;php_value max_file_uploads 101php_value upload_max_filesize 128Mphp_value post_max_size 128Mphp_value memory_limit 512M&lt;/IfModule&gt; /etc/mysql/my.cnf 1234[mysqld]max_connections = 10000max_allowed_packet = 512Minnodb_log_file_size = 512M 4. 如何让 DOMJudge 支持多台打印机？修改 domserver/webapp/src/DOMJudgeBundle/Utils/Printing.php 中 cmd 指令： 1234567$cmd = \"enscript -C \" . $highlight . \" -d \" . $printername // 指定打印机名 . \" -b \" . escapeshellarg($header) . \" -a 0-10 \" . \" -f Courier9 \"// . \" -p $tmp \" . escapeshellarg($filename) . \" 2&gt;&amp;1\"; 去除 -p $tmp ，添加 -d 参数，指定打印机打印。多台打印机则让打印机名轮转即可。","categories":[],"tags":[{"name":"domjudge","slug":"domjudge","permalink":"http://mcginn7.github.io/tags/domjudge/"}]},{"title":"论文笔记 Semantic Compositional Networks for Visual Captioning","slug":"论文笔记 Semantic Compositional Networks for Visual Captioning","date":"2018-08-18T12:58:18.000Z","updated":"2018-10-08T12:55:41.089Z","comments":true,"path":"2018/08/18/论文笔记 Semantic Compositional Networks for Visual Captioning/","link":"","permalink":"http://mcginn7.github.io/2018/08/18/论文笔记 Semantic Compositional Networks for Visual Captioning/","excerpt":"","text":"简介​ 该论文提出了语义组合网络(Semantic Compositional Network, SCN)，其有效利用语义概念（标签）来达到效果比较好的图文生成。 Semantic compositional networks 模型基础 使用CNN提取图像特征，RNN作文字生成。 文字生成的概率公式： p(\\bold X | \\bold I) = \\prod _{t=1}^Tp(x_t|x_0, \\dots , x_{t-1}, v) $ \\bold X = (x_1, \\dots , x_T)$ 表示文字序列，$v$ 为提取的图像特征。 LSTM的转换函数： h_t = \\sigma(Wx_{t-1}+Uh_{t-1}+\\mathbb{1}(t=1)\\cdot Cv)​ 图像特征仅在开始输入一次。 语义概念检测 作者将语义标签检测作为多标签分类问题。 首先先从训练集的文字说明中提取常见的 $K \\approx 1000$个单词作为分类标签 $y_i = [y_{i1}，\\dots，y_{iK}] \\in \\{0, 1\\}^K$。 标签$s_i$使用MLP来预测(Ps：这里可能是在CNN的基础上加入MLP)， s_i = \\sigma(MLP(v_i))$s_i$表示每个标签的概率，也可以理解为权重。 优化目标函数： \\frac 1N\\sum_{i=1}^N \\sum_{k=1}^K {(y_{ik}\\log s_{ik}+(1-y_{ik}\\log(1-s_{ik})))} SCN-RNN 这一步就是将语义标签嵌入到RNN中。 嵌入相关公式： \\hat x_{t-1}=W_bs\\bigodot W_cx_{t-1} \\\\ \\hat h_{t-1} = U_bs\\bigodot U_ch_{t-1} \\\\ z=\\mathbb{1}(t=1)\\cdot Cv \\\\ h_t = \\sigma(W_a\\hat x_{t-1} + U_a\\hat h_{t-1} + z) 视频文字生成(video caption) 视频的图像特征包括两部分：均值池化2D CNN提取的图像特征和3D CNN提取的特征，两个特征连接起来作为视频的图像特征。 结果 在数据集COCO和Youtube2Text的各个评估指标全面提升。","categories":[],"tags":[]},{"title":"The Binding of Isaac:Afterbirth+总结","slug":"The Binding of Isaac Afterbirth+总结","date":"2018-07-19T07:02:03.000Z","updated":"2018-07-21T07:20:04.070Z","comments":true,"path":"2018/07/19/The Binding of Isaac Afterbirth+总结/","link":"","permalink":"http://mcginn7.github.io/2018/07/19/The Binding of Isaac Afterbirth+总结/","excerpt":"","text":"献血袋：扣半颗红心（子宫层一颗），掉落随机数量（通常1）的硬币。献血袋很强，很容易刷起来。 手术刀：在地上制造褐色和蓝色两个通道并传送，传送出来时有短暂无敌，可以做到： 白嫖卖血机，喂黑小孩，进出刺房等； 进BOSS房和挑战房时，开箱子后直接传出去。 在白心的隐藏房，使用存血罐可以吐出白心。配合1+1和肉刀可以生成N多肉哥。 钥匙通常留给商店使用。 睫毛膏是负面道具，不要拿。 商店高概率刷出复眼（复制本房间的道具，未购买的道具也可以复制），最好等出了打折券再用。 20分钟内打败妈腿会开Boss Rush房；30分钟内打败妈心开启Blue Womb(蓝色子宫，打hush)房。使用MaMa Mega!可以强制开启br和bw。","categories":[],"tags":[]},{"title":"论文阅读记录","slug":"论文阅读记录","date":"2018-07-17T02:33:16.000Z","updated":"2018-07-17T02:57:19.822Z","comments":true,"path":"2018/07/17/论文阅读记录/","link":"","permalink":"http://mcginn7.github.io/2018/07/17/论文阅读记录/","excerpt":"","text":"2014 Generative Adversarial Networks An Annotated Proof of Generative Adversarial Networks with Implementation Notes Conditional Generative Adversarial Nets 2016 Conditional Image Synthesis With Auxiliary Classifier GANs InfoGAN: Interpretable Representation Learning by Information Maximizing Generative Adversarial Nets 2017 Wasserstein GAN 令人拍案叫绝的Wasserstein GAN Improved Training of Wasserstein GANs","categories":[],"tags":[]},{"title":"Ubuntu离线安装软件包","slug":"apt-offline管理Ubuntu离线安装软件包","date":"2018-06-05T11:27:37.000Z","updated":"2018-06-06T06:26:39.635Z","comments":true,"path":"2018/06/05/apt-offline管理Ubuntu离线安装软件包/","link":"","permalink":"http://mcginn7.github.io/2018/06/05/apt-offline管理Ubuntu离线安装软件包/","excerpt":"","text":"参考链接 apt-offline离线安装指南 https://blog.sleeplessbeastie.eu/2014/01/30/how-to-manage-packages-on-an-off-line-debian-system/ http://manpages.ubuntu.com/manpages/precise/man8/apt-offline.8.html#contenttoc4 https://www.debian.org/ https://camicri.github.io/camicri-cube/#/ 应用场景 需要升级/安装软件的电脑无网络。 软件要安装到多台电脑上，且软件较大，下载时间长。 方案 由于apt-offline的安装有依赖，离线安装会失败，所以需要借助Camicri Cube来完成apt-offline的安装。 不用Camicri Cube完成全部安装是因为它貌似不支持命令行，只有可视化界面操作。如果安装的包较多，就比较麻烦。而apt-offline支持命令行操作，一次性可以打包多个安装包，比较方便。 Camicri Cube完成离线系统升级 在离线电脑上打开Camicri Cube，创建一个project，关闭后打包Cube目录下相应的project。 在联网电脑上，将打包文件解压到Cube目录下的project目录，然后用Cube打开这个project。 点击 Cube -&gt; Repository -&gt; Download Repositories 进行下载更新。 点击 Asterisk -&gt; Upgradable ， Cube -&gt; Download -&gt; Mark All Updates for Download ， Cube -&gt; Download -&gt; Download All Marked Packages ，就可以完成软件包的升级。 在上方的搜索框输入apt-offline和vim，点download进行下载。 在联网电脑的project打包后传到离线电脑上，覆盖原先的project，然后用Cube打开。 Cube -&gt; System -&gt; Update Computer’s Repositories 更新Repository。 Cube -&gt; Install -&gt; Mark All Downloaded for Installation , Cube -&gt; Install -&gt; Install All Marked Packages ，完成安装软件。 apt-offline下载及安装离线软件包 假设要在离线电脑安装mysql-server，先在离线电脑运行以下命令来，完成安装包的行为和定义签名文件： 1apt-offline set debian-install.sig --install-packages mysql-server 将生成的debian-install.sig文件上传到联网电脑执行下载并打包： 1apt-offline get debian-install.sig --bundle debian-install.zip 将打包好的debian-install.zip传到离线电脑上，运行下面的命令来更新APT database: 1sudo apt-offline install debian-install.zip 最后运行apt-get来完成安装： 1sudo apt-get install mysql-server","categories":[],"tags":[]}]}